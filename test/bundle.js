/*! For license information please see bundle.js.LICENSE.txt */
(()=>{"use strict";var __webpack_modules__={"../main.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _src_js_annotationtoolkit_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/js/annotationtoolkit.mjs */ "../src/js/annotationtoolkit.mjs");\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_src_js_annotationtoolkit_mjs__WEBPACK_IMPORTED_MODULE_0__.AnnotationToolkit);\n\n//# sourceURL=webpack://js/../main.mjs?')},"../src/js/addcss.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addCSS: () => (/* binding */ addCSS)\n/* harmony export */ });\n/**\r\n * \r\n * A regular expression pattern to check for in existing CSS links in the document, used to avoid duplicating CSS files. If the pattern is found in the document, the new link is not added. For consistency, the pattern is also checked against the url parameter to make sure it will exist in the document after adding the new link. If the pattern is not found in the url, an error is logged to the console and the file is not added\r\n * test\r\n * @param {string} url - The URL of the CSS file to add.\r\n * @param {string} [nameToCheck] - The name pattern to check in the URL. If provided,\r\n * @returns {void}\r\n */\r\nfunction addCSS(url, nameToCheck){\r\n    if(nameToCheck){\r\n        let pattern=`\\/${nameToCheck}\\.(?:min\\.)?css`;\r\n        let urlMatchesPattern = url.match(pattern);\r\n\r\n        if(!urlMatchesPattern){\r\n            console.error(`addCSS error: pattern(${pattern}) not found in url (${url})`)\r\n            return;\r\n        }\r\n\r\n        let found = Array.from(document.head.getElementsByTagName('link')).filter(link=>{\r\n            // console.log(link.href,'testing against',pattern)\r\n            return link.href.match(pattern)\r\n        });\r\n\r\n        if(found.length>0){\r\n            // console.log('Not adding CSS - already found in document head')\r\n            return;\r\n        }\r\n\r\n    }\r\n    \r\n    console.log('Adding css:',url);\r\n    let link = document.createElement('link');\r\n    link.rel='stylesheet';\r\n    link.href=url;\r\n    document.head.appendChild(link);\r\n}\r\n\r\n\n\n//# sourceURL=webpack://js/../src/js/addcss.mjs?")},"../src/js/annotationtoolbar.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AnnotationToolbar: () => (/* binding */ AnnotationToolbar)\n/* harmony export */ });\n/* harmony import */ var _papertools_default_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./papertools/default.mjs */ \"../src/js/papertools/default.mjs\");\n/* harmony import */ var _papertools_wand_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./papertools/wand.mjs */ \"../src/js/papertools/wand.mjs\");\n/* harmony import */ var _papertools_brush_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./papertools/brush.mjs */ \"../src/js/papertools/brush.mjs\");\n/* harmony import */ var _papertools_point_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./papertools/point.mjs */ \"../src/js/papertools/point.mjs\");\n/* harmony import */ var _papertools_pointtext_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./papertools/pointtext.mjs */ \"../src/js/papertools/pointtext.mjs\");\n/* harmony import */ var _papertools_rectangle_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./papertools/rectangle.mjs */ \"../src/js/papertools/rectangle.mjs\");\n/* harmony import */ var _papertools_ellipse_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./papertools/ellipse.mjs */ \"../src/js/papertools/ellipse.mjs\");\n/* harmony import */ var _papertools_style_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./papertools/style.mjs */ \"../src/js/papertools/style.mjs\");\n/* harmony import */ var _papertools_linestring_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./papertools/linestring.mjs */ \"../src/js/papertools/linestring.mjs\");\n/* harmony import */ var _papertools_polygon_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./papertools/polygon.mjs */ \"../src/js/papertools/polygon.mjs\");\n/* harmony import */ var _papertools_select_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./papertools/select.mjs */ \"../src/js/papertools/select.mjs\");\n/* harmony import */ var _papertools_transform_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./papertools/transform.mjs */ \"../src/js/papertools/transform.mjs\");\n/* harmony import */ var _papertools_raster_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./papertools/raster.mjs */ \"../src/js/papertools/raster.mjs\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass AnnotationToolbar{\r\n  /**\r\n   * Constructs an AnnotationToolbar instance.\r\n   *\r\n   * @param {Object} paperScope - The Paper.js scope object.\r\n   * @param {string[]} [tools] - An array of tool names to use. If not provided, all available tools will be used.\r\n   * @throws {Error} Throws an error if `tools` is provided but not an array.\r\n   */\r\n    constructor(paperScope, tools){\r\n        // tools should be an array of strings, or null/falsey\r\n        if(tools && !Array.isArray(tools)){\r\n            throw('Bad option: if present, tools must be an Array of tool names to use.');\r\n        }\r\n        this.ui = makeUI();\r\n        this.paperScope=paperScope;\r\n\r\n        this.currentMode = null;\r\n        this.setModeTimeout = null;\r\n        \r\n        let toolLayer=new paperScope.Layer();\r\n        toolLayer.isGeoJSONFeatureCollection=false;\r\n        toolLayer.name = 'toolLayer';\r\n        paperScope.project.addLayer(toolLayer);\r\n\r\n        this.toolConstructors = {\r\n            default:_papertools_default_mjs__WEBPACK_IMPORTED_MODULE_0__.DefaultTool,\r\n            select: _papertools_select_mjs__WEBPACK_IMPORTED_MODULE_10__.SelectTool,\r\n            transform: _papertools_transform_mjs__WEBPACK_IMPORTED_MODULE_11__.TransformTool,\r\n            style:  _papertools_style_mjs__WEBPACK_IMPORTED_MODULE_7__.StyleTool,\r\n            rectangle: _papertools_rectangle_mjs__WEBPACK_IMPORTED_MODULE_5__.RectangleTool,\r\n            ellipse: _papertools_ellipse_mjs__WEBPACK_IMPORTED_MODULE_6__.EllipseTool,\r\n            point: _papertools_point_mjs__WEBPACK_IMPORTED_MODULE_3__.PointTool,\r\n            text: _papertools_pointtext_mjs__WEBPACK_IMPORTED_MODULE_4__.PointTextTool,\r\n            polygon: _papertools_polygon_mjs__WEBPACK_IMPORTED_MODULE_9__.PolygonTool,\r\n            brush: _papertools_brush_mjs__WEBPACK_IMPORTED_MODULE_2__.BrushTool,\r\n            wand: _papertools_wand_mjs__WEBPACK_IMPORTED_MODULE_1__.WandTool,\r\n            linestring : _papertools_linestring_mjs__WEBPACK_IMPORTED_MODULE_8__.LinestringTool,\r\n            raster: _papertools_raster_mjs__WEBPACK_IMPORTED_MODULE_12__.RasterTool,\r\n        }   \r\n        this.tools = {};\r\n\r\n        // if array of tools was passed in, use that. Otherwise use all available ones listed in the toolConstructors dictionary\r\n        let toolsToUse = tools || Object.keys(this.toolConstructors);\r\n        // make sure the default tool is always included\r\n        if(toolsToUse.indexOf('default') == -1){\r\n            toolsToUse = ['default', ...toolsToUse];\r\n        }\r\n        toolsToUse.forEach(toolname => {\r\n            if(!this.toolConstructors[toolname]){\r\n                console.warn(`The requested tool is invalid: ${toolname}. No constructor found for that name.`);\r\n                return;\r\n            }\r\n\r\n            let toolObj = this.tools[toolname] = new this.toolConstructors[toolname](this.paperScope);\r\n            let toolbarControl = toolObj.getToolbarControl();\r\n            if(toolbarControl) this.addToolbarControl(toolbarControl);\r\n\r\n            // if(toolObj !== tools.default){\r\n            toolObj.addEventListener('deactivated',ev => {\r\n                //If deactivation is triggered by another tool being activated, this condition will fail\r\n                if(ev.target == this.paperScope.getActiveTool()){\r\n                    this.tools.default.activate();\r\n                }\r\n            });\r\n            \r\n        })\r\n        this.tools.default.activate();\r\n\r\n        this.setMode();\r\n\r\n        //items emit events on the paper project; add listeners to update the toolbar status as needed       \r\n        paperScope.project.on({\r\n            \r\n            'item-replaced':()=>{\r\n                this.setMode();\r\n            },\r\n\r\n            'item-selected':()=>{\r\n                this.setMode()\r\n            },\r\n            'item-deselected':()=>{\r\n                this.setMode()\r\n            },\r\n            'item-removed':()=>{\r\n                this.setMode()\r\n            },\r\n            'items-changed':()=>{\r\n                this.setMode();\r\n            }\r\n        });\r\n\r\n    }\r\n    \r\n    /**\r\n     * Sets the mode of the toolbar based on the currently selected items in the project. Individual tools will be enabled and disabled by this. If the currently active tool is not supported for the selected item(s) it will be deactivated.\r\n     * \r\n     * @memberof AnnotationToolbar\r\n     * @instance\r\n     * @function setMode\r\n     */\r\n    setMode() {\r\n        let self = this;\r\n        this.setModeTimeout && clearTimeout(this.setModeTimeout);\r\n        this.setModeTimeout = setTimeout(() => {\r\n            this.setModeTimeout = null;\r\n            let selection = this.paperScope.findSelectedItems();\r\n            let activeTool = this.paperScope.getActiveTool();\r\n            if (selection.length === 0) {\r\n                this.currentMode = 'select';\r\n            } else if (selection.length === 1) {\r\n                let item = selection[0];\r\n                let def = item.annotationItem || {};\r\n                let type = def.type;\r\n                if (def.subtype) type += ':' + def.subtype;\r\n                let mode = type === null ? 'new' : type;\r\n                this.currentMode = mode;\r\n            } else {\r\n                this.currentMode = 'multiselection';\r\n            }\r\n        \r\n            if (activeTool.getToolbarControl().isEnabledForMode(this.currentMode) === false) {\r\n                activeTool.deactivate(true);\r\n                this.tools.default.activate();\r\n            }\r\n        \r\n\r\n            Object.values(this.tools).forEach(toolObj => {\r\n                let t = toolObj.getToolbarControl();\r\n                t && (t.isEnabledForMode(self.currentMode) ? t.button.enable() : t.button.disable());\r\n            });\r\n    \r\n\r\n            activeTool.selectionChanged();\r\n        }, 0);\r\n    }\r\n\r\n/**\r\n * Adds a toolbar control to the Annotation Toolbar.\r\n *\r\n * @memberof AnnotationToolbar\r\n * @instance\r\n * @function addToolbarControl\r\n * @param {Object} toolbarControl - The toolbar control to be added.\r\n * @throws {Error} Throws an error if the toolbar control's button element is not found.\r\n */    \r\n    addToolbarControl(toolbarControl){\r\n        toolbarControl.button && toolbarControl.button.element && this.ui.buttongroup.buttons.push(toolbarControl.button)\r\n        toolbarControl.dropdown && this.ui.dropdowns.append(toolbarControl.dropdown);\r\n        toolbarControl.isEnabledForMode(this.currentMode) ? toolbarControl.button.enable() : toolbarControl.button.disable();\r\n    }\r\n\r\n/**\r\n * Shows the Annotation Toolbar.\r\n *\r\n */\r\n    show(){\r\n        $(this.ui.buttongroup.element).show();\r\n    }\r\n/**\r\n * Hides the Annotation Toolbar.\r\n *\r\n */\r\n    hide(){\r\n        $(this.ui.buttongroup.element).hide();\r\n    }\r\n    \r\n/**\r\n * Adds the Annotation Toolbar to an OpenSeadragon viewer.\r\n *\r\n * @memberof AnnotationToolbar\r\n * @instance\r\n * @function addToOpenSeadragon\r\n * @param {Object} viewer - The OpenSeadragon viewer.\r\n * \r\n * @description\r\n * This method adds the Annotation Toolbar to an OpenSeadragon viewer. It creates an OpenSeadragon.ButtonGroup with the toolbar buttons and adds it to the OpenSeadragon.ControlAnchor.TOP_LEFT position of the viewer. The `.viewer-controls-topleft` class is added to the viewer controls.\r\n */\r\n    addToOpenSeadragon(viewer){\r\n        let bg = new OpenSeadragon.ButtonGroup({buttons:this.ui.buttongroup.buttons,element:this.ui.buttongroup.element});\r\n        viewer.addControl(bg.element,{anchor:OpenSeadragon.ControlAnchor.TOP_LEFT});\r\n        // get the new OpenSeadragon.Control object\r\n        this.control = viewer.controls[viewer.controls.length-1];\r\n        this.viewer = viewer;//save reference so we can remove/destroy this toolbar\r\n        let handler = event=>{\r\n            console.log('Mouse nav changed',event);\r\n            // this.control.setVisible(true);\r\n            // if mouse nav is enabled, enable autoFade, otherwise disable\r\n            if(event.overlay == this.paperScope.overlay){\r\n                this.control.autoFade = event.enabled;\r\n            }\r\n        }\r\n        this._mousenavhandler = handler;\r\n        this.viewer.addHandler('mouse-nav-changed',handler);\r\n        $(this.ui.buttongroup.element).append(this.ui.dropdowns);\r\n        $(viewer.controls.topleft).addClass('viewer-controls-topleft');\r\n        $('.toggles .btn').attr('style','');\r\n    }\r\n/**\r\n * Destroys the Annotation Toolbar.\r\n *\r\n * @memberof AnnotationToolbar\r\n * @function destroy\r\n */\r\n    destroy(){\r\n        if(this.viewer){\r\n            this.viewer.removeControl(this.ui.buttongroup.element);\r\n            $(this.viewer.controls.topleft).removeClass('viewer-controls-topleft');\r\n            this.viewer.removeHandler(this._mousenavhandler);\r\n        } \r\n        this.ui.dropdowns.parent().remove();\r\n    } \r\n}\r\n/**\r\n * Creates the user interface for the Annotation Toolbar.\r\n *\r\n * @function makeUI\r\n * @returns {Object} The user interface object containing the button group and dropdowns.\r\n */\r\nfunction makeUI(){\r\n    //make a container div\r\n    let t = $('<div>',{class:'annotation-ui-drawing-toolbar btn-group btn-group-sm mode-selection'});\r\n    let bg = {buttons:[],element:t[0]};\r\n    let dropdowns=$('<div>',{class:'dropdowns'}).appendTo(t);\r\n    return {\r\n        buttongroup:bg,\r\n        dropdowns:dropdowns,\r\n    }\r\n}\r\n\r\n\n\n//# sourceURL=webpack://js/../src/js/annotationtoolbar.mjs?")},"../src/js/annotationtoolkit.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AnnotationToolkit: () => (/* binding */ AnnotationToolkit)\n/* harmony export */ });\n/* harmony import */ var _annotationui_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./annotationui.mjs */ \"../src/js/annotationui.mjs\");\n/* harmony import */ var _paper_overlay_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./paper-overlay.mjs */ \"../src/js/paper-overlay.mjs\");\n/* harmony import */ var _paperitems_annotationitem_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./paperitems/annotationitem.mjs */ \"../src/js/paperitems/annotationitem.mjs\");\n/* harmony import */ var _paperitems_multipolygon_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./paperitems/multipolygon.mjs */ \"../src/js/paperitems/multipolygon.mjs\");\n/* harmony import */ var _paperitems_placeholder_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./paperitems/placeholder.mjs */ \"../src/js/paperitems/placeholder.mjs\");\n/* harmony import */ var _paperitems_linestring_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./paperitems/linestring.mjs */ \"../src/js/paperitems/linestring.mjs\");\n/* harmony import */ var _paperitems_multilinestring_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./paperitems/multilinestring.mjs */ \"../src/js/paperitems/multilinestring.mjs\");\n/* harmony import */ var _paperitems_raster_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./paperitems/raster.mjs */ \"../src/js/paperitems/raster.mjs\");\n/* harmony import */ var _paperitems_point_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./paperitems/point.mjs */ \"../src/js/paperitems/point.mjs\");\n/* harmony import */ var _paperitems_pointtext_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./paperitems/pointtext.mjs */ \"../src/js/paperitems/pointtext.mjs\");\n/* harmony import */ var _paperitems_rectangle_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./paperitems/rectangle.mjs */ \"../src/js/paperitems/rectangle.mjs\");\n/* harmony import */ var _paperitems_ellipse_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./paperitems/ellipse.mjs */ \"../src/js/paperitems/ellipse.mjs\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//to do:\r\n// - Add configuration options (as a class, modeled after OpenSeadragon??)\r\n// --- Document configuration options. JSDocs?\r\n\r\n//extend paper prototypes to add functionality\r\n//property definitions\r\nObject.defineProperty(paper.Item.prototype, 'hierarchy', hierarchyDef())\r\nObject.defineProperty(paper.Item.prototype, 'descendants', descendantsDef())\r\nObject.defineProperty(paper.Item.prototype, 'displayName', displayNamePropertyDef())\r\nObject.defineProperty(paper.Item.prototype, 'fillOpacity', itemFillOpacityPropertyDef())\r\nObject.defineProperty(paper.Item.prototype, 'strokeOpacity', itemStrokeOpacityPropertyDef())\r\nObject.defineProperty(paper.Item.prototype, 'rescale', itemRescalePropertyDef())\r\nObject.defineProperty(paper.Style.prototype, 'fillOpacity', fillOpacityPropertyDef())\r\nObject.defineProperty(paper.Style.prototype, 'strokeOpacity', strokeOpacityPropertyDef())\r\nObject.defineProperty(paper.Style.prototype, 'rescale', rescalePropertyDef())\r\nObject.defineProperty(paper.CompoundPath.prototype, 'descendants', descendantsDefCompoundPath())//this must come after the Item prototype def to override it\r\nObject.defineProperty(paper.Project.prototype, 'hierarchy', hierarchyDef())\r\nObject.defineProperty(paper.Project.prototype, 'descendants', descendantsDefProject())\r\nObject.defineProperty(paper.Project.prototype, 'fillOpacity', itemFillOpacityPropertyDef())\r\nObject.defineProperty(paper.View.prototype, 'fillOpacity', viewFillOpacityPropertyDef())\r\nObject.defineProperty(paper.View.prototype, '_fillOpacity',{value: 1, writable: true});//initialize to opaque\r\nObject.defineProperty(paper.Project.prototype, 'strokeOpacity', itemStrokeOpacityPropertyDef())\r\nObject.defineProperty(paper.TextItem.prototype, 'content', textItemContentPropertyDef())\r\n\r\n//extend remove function to emit events for GeoJSON type annotation objects\r\nlet origRemove=paper.Item.prototype.remove;\r\npaper.Item.prototype.remove=function(){\r\n    (this.isGeoJSONFeature || this.isGeoJSONFeatureCollection) && this.project.emit('item-removed',{item: this});\r\n    origRemove.call(this);\r\n    (this.isGeoJSONFeature || this.isGeoJSONFeatureCollection) && this.emit('removed',{item:this});\r\n}\r\n//function definitions\r\npaper.Group.prototype.insertChildren=getInsertChildrenDef();\r\npaper.Color.prototype.toJSON = paper.Color.prototype.toCSS;//for saving/restoring colors as JSON\r\npaper.Style.prototype.toJSON = styleToJSON;\r\npaper.Style.prototype.set= styleSet;\r\npaper.View.prototype.getImageData = paperViewGetImageData;\r\npaper.View.prototype._multiplyOpacity = true;\r\npaper.PathItem.prototype.toCompoundPath = toCompoundPath;\r\npaper.PathItem.prototype.applyBounds = applyBounds;\r\npaper.Item.prototype.select = paperItemSelect;\r\npaper.Item.prototype.deselect = paperItemDeselect;\r\npaper.Item.prototype.toggle = paperItemToggle;\r\npaper.Item.prototype.updateFillOpacity = updateFillOpacity;\r\npaper.Item.prototype.updateStrokeOpacity = updateStrokeOpacity;\r\npaper.Project.prototype.updateFillOpacity = updateFillOpacity;\r\n//to do: should these all be installed on project instead of scope?\r\npaper.PaperScope.prototype.findSelectedNewItem = findSelectedNewItem;\r\npaper.PaperScope.prototype.findSelectedItems = findSelectedItems;\r\npaper.PaperScope.prototype.findSelectedItem = findSelectedItem;\r\npaper.PaperScope.prototype.createFeatureCollectionLayer = createFeatureCollectionLayer;\r\npaper.PaperScope.prototype.scaleByCurrentZoom = function (v) { return v / this.view.getZoom(); };\r\npaper.PaperScope.prototype.getActiveTool = function(){ return this.tool ? this.tool._toolObject : null; }        \r\n\r\n/**\r\n * A class for creating and managing annotation tools on an OpenSeadragon viewer.\r\n * @class\r\n * @extends OpenSeadragon.EventSource\r\n */\r\nclass AnnotationToolkit extends OpenSeadragon.EventSource{\r\n    /**\r\n     * Create a new AnnotationToolkit instance.\r\n     * @constructor\r\n     * @param {OpenSeadragon.Viewer} openSeadragonViewer - The OpenSeadragon viewer object.\r\n     * @param {object} [opts] - The configuration options.\r\n     */\r\n    constructor(openSeadragonViewer, opts) {\r\n        super();\r\n        // TO DO: make the options object actually do something\r\n        if(opts){\r\n            console.warn('Configuration options for AnnotationToolkit are not yet supported')\r\n        }\r\n\r\n        this._defaultStyle = {\r\n            fillColor: new paper.Color('white'),\r\n            strokeColor: new paper.Color('black'),\r\n            fillOpacity:1,\r\n            strokeOpacity:1,\r\n            strokeWidth: 1,\r\n            rescale: {\r\n                strokeWidth: 1\r\n            }\r\n        };\r\n        this.viewer = openSeadragonViewer;\r\n\r\n        this.viewer.addOnceHandler('close', ()=>this.destroy()); //TO DO: make this an option, not a hard-coded default\r\n\r\n        this.overlay = new _paper_overlay_mjs__WEBPACK_IMPORTED_MODULE_1__.PaperOverlay(this.viewer);\r\n\r\n        this.overlay.paperScope.project.defaultStyle = new paper.Style();\r\n        this.overlay.paperScope.project.defaultStyle.set(this.defaultStyle);\r\n        this.overlay.autoRescaleItems(true);\r\n\r\n        // OpenSeadragon.extend(AnnotationToolkit.prototype, OpenSeadragon.EventSource.prototype);\r\n        // OpenSeadragon.EventSource.call(this);\r\n        \r\n        this.viewer.annotationToolkit = this;\r\n\r\n        _paperitems_annotationitem_mjs__WEBPACK_IMPORTED_MODULE_2__.AnnotationItemFactory.register(_paperitems_multipolygon_mjs__WEBPACK_IMPORTED_MODULE_3__.MultiPolygon);\r\n        _paperitems_annotationitem_mjs__WEBPACK_IMPORTED_MODULE_2__.AnnotationItemFactory.register(_paperitems_placeholder_mjs__WEBPACK_IMPORTED_MODULE_4__.Placeholder);\r\n        _paperitems_annotationitem_mjs__WEBPACK_IMPORTED_MODULE_2__.AnnotationItemFactory.register(_paperitems_linestring_mjs__WEBPACK_IMPORTED_MODULE_5__.Linestring);\r\n        _paperitems_annotationitem_mjs__WEBPACK_IMPORTED_MODULE_2__.AnnotationItemFactory.register(_paperitems_multilinestring_mjs__WEBPACK_IMPORTED_MODULE_6__.MultiLinestring);\r\n        _paperitems_annotationitem_mjs__WEBPACK_IMPORTED_MODULE_2__.AnnotationItemFactory.register(_paperitems_raster_mjs__WEBPACK_IMPORTED_MODULE_7__.Raster);\r\n        _paperitems_annotationitem_mjs__WEBPACK_IMPORTED_MODULE_2__.AnnotationItemFactory.register(_paperitems_point_mjs__WEBPACK_IMPORTED_MODULE_8__.Point);\r\n        _paperitems_annotationitem_mjs__WEBPACK_IMPORTED_MODULE_2__.AnnotationItemFactory.register(_paperitems_pointtext_mjs__WEBPACK_IMPORTED_MODULE_9__.PointText);\r\n        _paperitems_annotationitem_mjs__WEBPACK_IMPORTED_MODULE_2__.AnnotationItemFactory.register(_paperitems_rectangle_mjs__WEBPACK_IMPORTED_MODULE_10__.Rectangle);\r\n        _paperitems_annotationitem_mjs__WEBPACK_IMPORTED_MODULE_2__.AnnotationItemFactory.register(_paperitems_ellipse_mjs__WEBPACK_IMPORTED_MODULE_11__.Ellipse);\r\n\r\n        paper.Item.fromGeoJSON = _paperitems_annotationitem_mjs__WEBPACK_IMPORTED_MODULE_2__.AnnotationItemFactory.itemFromGeoJSON;\r\n        paper.Item.fromAnnotationItem = _paperitems_annotationitem_mjs__WEBPACK_IMPORTED_MODULE_2__.AnnotationItemFactory.itemFromAnnotationItem;\r\n    }\r\n\r\n    /**\r\n     * Get the default style for the annotation items.\r\n     * @returns {object} The default style object.\r\n     */\r\n    get defaultStyle(){\r\n        return this._defaultStyle;\r\n    }\r\n    /**\r\n     * Add an annotation UI to the toolkit.\r\n     * @param {object} [opts={}] - The options for the annotation UI.\r\n     * @returns {AnnotationUI} The annotation UI object.\r\n     */\r\n    addAnnotationUI(opts = {}){\r\n        if (!this._annotationUI) this._annotationUI = new _annotationui_mjs__WEBPACK_IMPORTED_MODULE_0__.AnnotationUI(this, opts);\r\n        return this._annotationUI;\r\n    }\r\n    /**\r\n     * Destroy the toolkit and its components.\r\n     */\r\n    destroy() {\r\n        this.raiseEvent('before-destroy');\r\n        let tool=this.overlay.paperScope && this.overlay.paperScope.getActiveTool();\r\n        if(tool) tool.deactivate(true);\r\n\r\n        this.viewer.annotationToolkit = null;\r\n        this._annotationUI && this._annotationUI.destroy();\r\n        this.overlay.destroy();\r\n    }\r\n    /**\r\n     * Close the toolkit and remove its feature collections.\r\n     */\r\n    close() {\r\n        this.raiseEvent('before-close');\r\n        let tool=this.overlay.paperScope && this.overlay.paperScope.getActiveTool();\r\n        if(tool) tool.deactivate(true);\r\n\r\n        this.addFeatureCollections([],true);\r\n    }\r\n    /**\r\n     * Set the global visibility of the toolkit.\r\n     * @param {boolean} [show=false] - Whether to show or hide the toolkit.\r\n     */\r\n    setGlobalVisibility(show = false){\r\n        this.overlay.paperScope.view._element.setAttribute('style', 'visibility:' + (show ? 'visible;' : 'hidden;'));\r\n    }\r\n    /**\r\n     * Add feature collections to the toolkit from GeoJSON objects.\r\n     * @param {object[]} featureCollections - The array of GeoJSON objects representing feature collections.\r\n     * @param {boolean} replaceCurrent - Whether to replace the current feature collections or not.\r\n     */\r\n    addFeatureCollections(featureCollections,replaceCurrent){\r\n        this.loadGeoJSON(featureCollections,replaceCurrent);\r\n        this.overlay.rescaleItems();\r\n        this.overlay.paperScope.project.emit('items-changed');\r\n    }\r\n    /**\r\n     * Get the feature collection layers in the toolkit.\r\n     * @returns {paper.Layer[]} The array of paper layer objects representing feature collections.\r\n     */\r\n    getFeatureCollectionLayers(){\r\n        return this.overlay.paperScope.project.layers.filter(l=>l.isGeoJSONFeatureCollection);\r\n    }\r\n    /**\r\n     * Get the features in the toolkit.\r\n     * @returns {paper.Item[]} The array of paper item objects representing features.\r\n     */\r\n    getFeatures(){\r\n        return this.overlay.paperScope.project.getItems({match:i=>i.isGeoJSONFeature});\r\n    }\r\n    /**\r\n     * Convert the feature collections in the toolkit to GeoJSON objects.\r\n     * @returns {object[]} The array of GeoJSON objects representing feature collections.\r\n     */\r\n    toGeoJSON(){\r\n        //find all featureCollection items and convert to GeoJSON compatible structures\r\n        return this.overlay.paperScope.project.getItems({match:i=>i.isGeoJSONFeatureCollection}).map(layer=>{\r\n            let geoJSON = {\r\n                type:'FeatureCollection',\r\n                features: layer.descendants.filter(d=>d.annotationItem).map(d=>d.annotationItem.toGeoJSONFeature()),\r\n                properties:{\r\n                    defaultStyle: layer.defaultStyle.toJSON(),\r\n                    userdata: layer.userdata,\r\n                },\r\n                label:layer.displayName,\r\n            }\r\n            return geoJSON;\r\n        })\r\n    }\r\n    /**\r\n     * Convert the feature collections in the toolkit to a JSON string.\r\n     * @param {function} [replacer] - The replacer function for JSON.stringify().\r\n     * @param {number|string} [space] - The space argument for JSON.stringify().\r\n     * @returns {string} The JSON string representing the feature collections.\r\n     */\r\n    toGeoJSONString(replacer,space){\r\n        return JSON.stringify(this.toGeoJSON(),replacer,space);\r\n    }\r\n    /**\r\n     * Load feature collections from GeoJSON objects and add them to the toolkit.\r\n     * @param {object[]} geoJSON - The array of GeoJSON objects representing feature collections.\r\n     * @param {boolean} replaceCurrent - Whether to replace the current feature collections or not.\r\n     */\r\n    loadGeoJSON(geoJSON, replaceCurrent){\r\n        if(replaceCurrent){\r\n            this.overlay.paperScope.project.getItems({match:i=>i.isGeoJSONFeatureCollection}).forEach(layer=>layer.remove());\r\n        }\r\n        if(!Array.isArray(geoJSON)){\r\n            geoJSON = [geoJSON];\r\n        }\r\n        geoJSON.forEach(obj=>{\r\n            if(obj.type=='FeatureCollection'){\r\n                let layer = this.overlay.paperScope.createFeatureCollectionLayer(obj.label);\r\n                let props = (obj.properties || {});\r\n                layer.userdata = Object.assign({},props.userdata);\r\n                layer.defaultStyle.set(props.defaultStyle);\r\n                obj.features.forEach(feature=>{\r\n                    let item = paper.Item.fromGeoJSON(feature);\r\n                    layer.addChild(item);\r\n                })\r\n            }\r\n            else{\r\n                console.warn('GeoJSON object not loaded: wrong type. Only FeatureCollection objects are currently supported');\r\n            }\r\n        })\r\n    }\r\n    \r\n};\r\n\r\n\r\n\r\n\r\n\r\n// private functions\r\n\r\n/**\r\n * Create a compound path from a path item.\r\n * @returns {paper.CompoundPath} The compound path object.\r\n */\r\nfunction toCompoundPath() {\r\n    if (this.constructor !== paper.CompoundPath) {\r\n        let np = new paper.CompoundPath({ children: [this], fillRule: 'evenodd' });\r\n        np.selected = this.selected;\r\n        this.selected = false;\r\n        return np;\r\n    }\r\n    return this;\r\n}\r\n/**\r\n * Apply bounds to a path item.\r\n * @param {paper.Item[]} boundingItems - The array of paper items to use as bounds.\r\n */\r\nfunction applyBounds(boundingItems) {\r\n    if (boundingItems.length == 0)\r\n        return;\r\n    let intersection;\r\n    if (boundingItems.length == 1) {\r\n        let bounds = boundingItems[0];\r\n        intersection = bounds.intersect(this, { insert: false });\r\n    }\r\n    else if (bounding.length > 1) {\r\n        let bounds = new paper.CompoundPath(bounding.map(b => b.clone().children).flat());\r\n        intersection = bounds.intersect(this, { insert: false });\r\n        bounds.remove();\r\n    }\r\n    if (this.children) {\r\n        //compound path\r\n        this.removeChildren();\r\n        this.addChildren(intersection.children ? intersection.children : [intersection]);\r\n    }\r\n    else {\r\n        //simple path\r\n        this.segments = intersection.segments ? intersection.segments : intersection.firstChild.segments;\r\n    }\r\n\r\n}\r\n/**\r\n * Select a paper item and emit events.\r\n * @param {boolean} [keepOtherSelectedItems=false] - Whether to keep other selected items or not.\r\n */\r\nfunction paperItemSelect(keepOtherSelectedItems) {\r\n    if(!keepOtherSelectedItems){\r\n        this.project._scope.findSelectedItems().forEach(item => item.deselect());\r\n    }\r\n    this.selected = true;\r\n    this.emit('selected');\r\n    this.project.emit('item-selected', { item: this });\r\n}\r\n/**\r\n * Deselect a paper item and emit events.\r\n * @param {boolean} [keepOtherSelectedItems=false] - Whether to keep other selected items or not.\r\n */\r\nfunction paperItemDeselect(keepOtherSelectedItems) {\r\n    if(!keepOtherSelectedItems){\r\n        this.project._scope.findSelectedItems().forEach(item => item.deselect(true));\r\n        return;\r\n    }\r\n    this.selected = false;\r\n    this.emit('deselected');\r\n    this.project.emit('item-deselected', { item: this });\r\n}\r\n/**\r\n * Toggle the selection of a paper item and emit events.\r\n * @param {boolean} [keepOtherSelectedItems=false] - Whether to keep other selected items or not.\r\n */\r\nfunction paperItemToggle(keepOtherSelectedItems) {\r\n    this.selected ? this.deselect(keepOtherSelectedItems) : this.select(keepOtherSelectedItems);\r\n}\r\n\r\n/**\r\n * Find the selected new item in the project scope.\r\n * @returns {paper.Item} The selected new item, or null if none exists.\r\n */\r\nfunction findSelectedNewItem() {\r\n    //to do: change this to use type=='Feature' and geometry==null to match GeoJSON spec and AnnotationItemPlaceholder definition\r\n    return this.project.getItems({ selected:true, match: function (i) { return i.isGeoJSONFeature && i.initializeGeoJSONFeature; } })[0];\r\n}\r\n/**\r\n * Find the selected items in the project scope.\r\n * @returns {paper.Item[]} The array of selected items, or an empty array if none exists.\r\n */\r\nfunction findSelectedItems() {\r\n    return this.project.getItems({ selected: true, match: function (i) { return i.isGeoJSONFeature; } });\r\n}\r\n/**\r\n * Find the first selected item in the project scope.\r\n * @returns {paper.Item} The first selected item, or null if none exists.\r\n */\r\nfunction findSelectedItem() {\r\n    return this.findSelectedItems()[0];\r\n}\r\n/**\r\n * Create a new feature collection layer in the project scope.\r\n * @param {string} [displayLabel=null] - The display label for the feature collection layer.\r\n * @returns {paper.Layer} The paper layer object representing the feature collection.\r\n */\r\nfunction createFeatureCollectionLayer(displayLabel=null) {\r\n    let layer = new paper.Layer();\r\n    this.project.addLayer(layer);\r\n    layer.isGeoJSONFeatureCollection = true;\r\n    let layerNum = this.project.layers.filter(l=>l.isGeoJSONFeatureCollection).length;\r\n    layer.name = layer.displayName = displayLabel!==null ? displayLabel : `Annotation Layer ${layerNum}`;\r\n    layer.defaultStyle = new paper.Style(this.project.defaultStyle);\r\n    this.project.emit('feature-collection-added',{layer:layer});\r\n    return layer;\r\n}\r\n\r\n/**\r\n * Update the fill opacity of a paper item and its descendants.\r\n */\r\nfunction updateFillOpacity(){\r\n    this._computedFillOpacity = this.hierarchy.filter(item=>'fillOpacity' in item && (item._multiplyOpacity||item==this)).reduce((prod,item)=>prod*item.fillOpacity,1);\r\n    if(this.fillColor){\r\n        this.fillColor.alpha = this._computedFillOpacity;\r\n    }\r\n}\r\n/**\r\n * Update the stroke opacity of a paper item and its descendants.\r\n */\r\nfunction updateStrokeOpacity(){\r\n    if(this.strokeColor){\r\n        this.strokeColor.alpha = this.hierarchy.filter(item=>'strokeOpacity' in item && (item._multiplyOpacity||item==this)).reduce((prod,item)=>prod*item.strokeOpacity,1);\r\n    }\r\n}\r\n/**\r\n * Define the fill opacity property for a paper style object.\r\n * The fill opacity property controls the opacity of the fill color in a style object.\r\n * @returns {object} The property descriptor object.\r\n * @property {function} set - The setter function for the fill opacity property.\r\n *   @param {number} o - The fill opacity value. Should be a number between 0 and 1.\r\n * @property {function} get - The getter function for the fill opacity property.\r\n *   @returns {number} The fill opacity value. If not set, returns 1 (fully opaque).\r\n */\r\nfunction fillOpacityPropertyDef(){\r\n    return {\r\n        set: function opacity(o){\r\n            this._fillOpacity = this._values.fillOpacity = o;\r\n        },\r\n        get: function opacity(){\r\n            return typeof this._fillOpacity === 'undefined' ? 1 : this._fillOpacity;\r\n        }\r\n    }\r\n}\r\n/**\r\n * Define the stroke opacity property for a paper style object.\r\n * The stroke opacity property controls the opacity of the stroke color in a style object.\r\n * @returns {object} The property descriptor object.\r\n * @property {function} set - The setter function for the stroke opacity property.\r\n *   @param {number} o - The stroke opacity value. Should be a number between 0 and 1.\r\n * @property {function} get - The getter function for the stroke opacity property.\r\n *   @returns {number} The stroke opacity value. If not set, returns 1 (fully opaque).\r\n */\r\nfunction strokeOpacityPropertyDef(){\r\n    return {\r\n        set: function opacity(o){\r\n            this._strokeOpacity = this._values.strokeOpacity = o;\r\n        },\r\n        get: function opacity(){\r\n            return typeof this._strokeOpacity === 'undefined' ? 1 : this._strokeOpacity;\r\n        }\r\n    }\r\n}\r\n/**\r\n * Define the fill opacity property for a paper item object.\r\n * The fill opacity property defines the opacity of the fill color used in a paper item object's style.\r\n * @returns {object} The property descriptor object.\r\n * @property {function} set - The setter function for the fill opacity property.\r\n *   @param {number} opacity - The opacity value for the fill color.\r\n * @property {function} get - The getter function for the fill opacity property.\r\n *   @returns {number} The opacity value of the fill color.\r\n */\r\nfunction itemFillOpacityPropertyDef(){\r\n    return {\r\n        set: function opacity(o){\r\n            (this.style || this.defaultStyle).fillOpacity = o;\r\n            this.descendants.forEach(item=>item.updateFillOpacity())\r\n        },\r\n        get: function opacity(){\r\n            return (this.style || this.defaultStyle).fillOpacity;\r\n        }\r\n    }\r\n}\r\n/**\r\n * Define the fill opacity property for a paper view object.\r\n * The fill opacity property defines the opacity of the fill color used in a paper view object's style.\r\n * @returns {object} The property descriptor object.\r\n * @property {function} set - The setter function for the fill opacity property.\r\n *   @param {number} opacity - The opacity value for the fill color.\r\n * @property {function} get - The getter function for the fill opacity property.\r\n *   @returns {number} The opacity value of the fill color.\r\n */\r\nfunction viewFillOpacityPropertyDef(){\r\n    return {\r\n        set: function opacity(o){\r\n            this._fillOpacity = o;\r\n            this._project.descendants.forEach(item=>item.updateFillOpacity())\r\n        },\r\n        get: function opacity(){\r\n            return this._fillOpacity;\r\n        },\r\n    }\r\n}\r\n\r\n/**\r\n * Define the stroke opacity property for a paper item object.\r\n * The stroke opacity property defines the opacity of the stroke color used in a paper item object's style.\r\n * @returns {object} The property descriptor object.\r\n * @property {function} set - The setter function for the stroke opacity property.\r\n *   @param {number} opacity - The opacity value for the stroke color.\r\n * @property {function} get - The getter function for the stroke opacity property.\r\n *   @returns {number} The opacity value of the stroke color.\r\n */\r\nfunction itemStrokeOpacityPropertyDef(){\r\n    return {\r\n        set: function opacity(o){\r\n            this._strokeOpacity = o;\r\n            this.descendants.forEach(item=>item.updateStrokeOpacity())\r\n        },\r\n        get: function opacity(){\r\n            return typeof this._strokeOpacity === 'undefined' ? 1 : this._strokeOpacity;\r\n        }\r\n    }\r\n}\r\n/**\r\n * Define the rescale property for a paper style object.\r\n * The rescale property defines the scaling factor applied to a paper style object.\r\n * @returns {object} The property descriptor object.\r\n * @property {function} set - The setter function for the rescale property.\r\n *   @param {number} rescale - The scaling factor value.\r\n * @property {function} get - The getter function for the rescale property.\r\n *   @returns {number} The scaling factor value.\r\n */\r\nfunction rescalePropertyDef(){\r\n    return {\r\n        set: function rescale(o){\r\n            this._rescale = this._values.rescale = o;\r\n        },\r\n        get: function rescale(){\r\n            return this._rescale;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Define the rescale property for a paper item object.\r\n * The rescale property defines the scaling factor applied to a paper item object's style.\r\n * @returns {object} The property descriptor object.\r\n * @property {function} set - The setter function for the rescale property.\r\n *   @param {number} rescale - The scaling factor value.\r\n * @property {function} get - The getter function for the rescale property.\r\n *   @returns {number} The scaling factor value.\r\n */\r\nfunction itemRescalePropertyDef(){\r\n    return {\r\n        set: function rescale(o){\r\n            this._style.rescale = o;\r\n        },\r\n        get: function rescale(){\r\n            return this._style.rescale;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Define the display name property for a paper item object.\r\n * The display name property defines the name used to identify a paper item object.\r\n * @returns {object} The property descriptor object.\r\n * @property {function} set - The setter function for the display name property.\r\n *   @param {string} input - The display name value.\r\n * @property {function} get - The getter function for the display name property.\r\n *   @returns {string} The display name value.\r\n */\r\nfunction displayNamePropertyDef(){\r\n    return {\r\n        set: function displayName(input){\r\n            if(Array.isArray(input)){\r\n                this._displayName = new String(input[0]);\r\n                this._displayName.source=input[1];\r\n            }\r\n            else{\r\n                this._displayName = input;\r\n            }\r\n            this.name = this._displayName;\r\n            this.emit('display-name-changed',{displayName:this._displayName});\r\n        },\r\n        get: function displayName(){\r\n            return this._displayName;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Define the hierarchy property for a paper item or project object.\r\n * The hierarchy property represents the parent-child relationship of paper item or project objects.\r\n * @returns {object} The property descriptor object.\r\n * @property {function} get - The getter function for the hierarchy property.\r\n *   @returns {paper.Item[]} The array of paper item objects representing the hierarchy.\r\n */\r\nfunction hierarchyDef(){\r\n    return {\r\n        get: function hierarchy(){\r\n            return this.parent ? this.parent.hierarchy.concat(this) : this.project ? this.project.hierarchy.concat(this) : [this.view, this];\r\n        }\r\n    }\r\n}\r\n/**\r\n * Define the descendants property for a paper item or project object.\r\n * The descendants property represents all the descendants (children and their children) of a paper item or project object.\r\n * @returns {object} The property descriptor object.\r\n * @property {function} get - The getter function for the descendants property.\r\n *   @returns {paper.Item[]} The array of paper item objects representing the descendants.\r\n */\r\nfunction descendantsDef(){\r\n    return {\r\n        get: function descendants(){\r\n            return (this.children ? this.children.map(child=>child.descendants).flat() : []).concat(this.isGeoJSONFeature ? [this] : []);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Define the descendants property for a paper compound path object.\r\n * The descendants property represents the compound path object itself as its only descendant.\r\n * @returns {object} The property descriptor object.\r\n * @property {function} get - The getter function for the descendants property.\r\n *   @returns {paper.Item[]} The array containing only the compound path object.\r\n */\r\nfunction descendantsDefCompoundPath(){\r\n    return {\r\n        get: function descendants(){\r\n            return [this];\r\n        }\r\n    }\r\n}\r\n/**\r\n * Define the descendants property for a paper project object.\r\n * The descendants property represents all the descendants (layers and their children) of a paper project object.\r\n * @returns {object} The property descriptor object.\r\n * @property {function} get - The getter function for the descendants property.\r\n *   @returns {paper.Item[]} The array of paper item objects representing the descendants.\r\n */\r\nfunction descendantsDefProject(){\r\n    return {\r\n        get: function descendants(){\r\n            return this.layers ? this.layers.filter(layer=>layer.isGeoJSONFeatureCollection).map(child=>child.descendants).flat() : [this];\r\n        }\r\n    }\r\n}\r\n/**\r\n * Define the set method for a paper style object.\r\n * @param {object|paper.Style} style - The style object to set.\r\n */\r\nfunction styleSet(style){\r\n\r\n    var isStyle = style instanceof paper.Style,\r\n        values = isStyle ? style._values : style;\r\n    if (values) {\r\n        for (var key in values) {\r\n            // console.log('setting',key)\r\n            if (key in this._defaults || paper.Style.prototype.hasOwnProperty(key)) {\r\n                var value = values[key];\r\n                this[key] = value && isStyle && value.clone\r\n                        ? value.clone() : value ;\r\n            }\r\n        }\r\n    }\r\n\t\r\n}\r\n/**\r\n * Convert a paper style object to a JSON object.\r\n * @returns {object} The JSON object representing the style.\r\n */\r\nfunction styleToJSON(){\r\n    let output={};\r\n    Object.keys(this._values).forEach(key=>{\r\n        output[key] = this[key];//invoke getter\r\n    })\r\n    return output;\r\n}\r\n/**\r\n * Get the image data of a paper view element.\r\n * @returns {ImageData} The image data object of the view element.\r\n */\r\nfunction paperViewGetImageData(){\r\n    return this.element.getContext('2d').getImageData(0,0,this.element.width, this.element.height);\r\n}\r\n\r\n/**\r\n * Get the insert children method definition for a paper group object.\r\n * The insert children method emits events when children are added to the paper group object.\r\n * @returns {function} The insert children method that emits events when children are added.\r\n */\r\nfunction getInsertChildrenDef(){\r\n    let origInsertChildren = paper.Group.prototype.insertChildren.original || paper.Group.prototype.insertChildren;\r\n    function insertChildren(){ \r\n        let output = origInsertChildren.apply(this,arguments); \r\n        let index = arguments[0], children=Array.from(arguments[1]);\r\n        children&&children.forEach((child,i)=>{\r\n            if(child.isGeoJSONFeature){\r\n                let idx = typeof index !== 'undefined' ? index+1 : -1; \r\n                this.emit('child-added',{item:child,index:idx});\r\n            } \r\n        });\r\n        return output;\r\n    }\r\n    insertChildren.original = origInsertChildren;\r\n    return insertChildren;\r\n}\r\n\r\n/**\r\n * Define the fill opacity property for a paper style object.\r\n * @returns {object} The property descriptor object with the following properties:\r\n * - get: A function that returns the fill opacity value (a number between 0 and 1).\r\n * - set: A function that sets the fill opacity value (a number between 0 and 1).\r\n */\r\nfunction textItemContentPropertyDef(){\r\n    let _set = paper.TextItem.prototype._setContent || Object.getOwnPropertyDescriptor(paper.TextItem.prototype, 'content').set;\r\n    paper.TextItem.prototype._setContent = _set;\r\n    return{\r\n        get: function() {\r\n            return this._content;\r\n        },\r\n        set: function(content) {\r\n            _set.call(this, content);\r\n            this.emit('content-changed');\r\n        },\r\n    }\r\n}\n\n//# sourceURL=webpack://js/../src/js/annotationtoolkit.mjs?")},"../src/js/annotationui.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AnnotationUI: () => (/* binding */ AnnotationUI)\n/* harmony export */ });\n/* harmony import */ var _addcss_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./addcss.mjs */ \"../src/js/addcss.mjs\");\n/* harmony import */ var _annotationtoolbar_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./annotationtoolbar.mjs */ \"../src/js/annotationtoolbar.mjs\");\n/* harmony import */ var _layerui_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./layerui.mjs */ \"../src/js/layerui.mjs\");\n/* harmony import */ var _filedialog_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./filedialog.mjs */ \"../src/js/filedialog.mjs\");\n//requires jquery, jqueryui\r\n//styles in annotationui.css\r\n//import 'https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js';\r\n//import 'https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js';\r\n\r\n\r\n\r\n\r\n\r\n(0,_addcss_mjs__WEBPACK_IMPORTED_MODULE_0__.addCSS)('https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.css','jquery-ui');\r\n(0,_addcss_mjs__WEBPACK_IMPORTED_MODULE_0__.addCSS)('https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css','font-awesome/6.1.1/css/all');\r\n(0,_addcss_mjs__WEBPACK_IMPORTED_MODULE_0__.addCSS)(`${\"file:///C:/Users/tbass/Desktop/osd-paperjs-annotation/src/js/annotationui.mjs\".match(/(.*?)js\\/[^\\/]*$/)[1]}css/annotationui.css`,'annotationui');\r\n(0,_addcss_mjs__WEBPACK_IMPORTED_MODULE_0__.addCSS)(`${\"file:///C:/Users/tbass/Desktop/osd-paperjs-annotation/src/js/annotationui.mjs\".match(/(.*?)js\\/[^\\/]*$/)[1]}css/osd-button.css`,'osd-button');\r\n(0,_addcss_mjs__WEBPACK_IMPORTED_MODULE_0__.addCSS)(`${\"file:///C:/Users/tbass/Desktop/osd-paperjs-annotation/src/js/annotationui.mjs\".match(/(.*?)js\\/[^\\/]*$/)[1]}css/editablecontent.css`,'editablecontent');\r\n\r\n\r\nclass AnnotationUI{\r\n/**\r\n * Creates an instance of AnnotationUI.\r\n *\r\n * @class\r\n * @param {Object} annotationToolkit - The annotation toolkit object.\r\n * @param {Object} opts - The options for the AnnotationUI.\r\n * @param {boolean} [opts.autoOpen=true] - Determines if the AnnotationUI should be automatically opened.\r\n * @param {Array} [opts.featureCollections=[]] - An array of feature collections to load.\r\n * @param {boolean} [opts.addButton=true] - Determines if the AnnotationUI button should be added.\r\n * @param {boolean} [opts.addToolbar=true] - Determines if the AnnotationToolbar should be added.\r\n * @param {string[]} [opts.tools=null] - An array of tool names to use in the AnnotationToolbar. If not provided, all available tools will be used.\r\n * @param {boolean} [opts.addLayerDialog=true] - Determines if the LayerUI dialog should be added.\r\n * @param {boolean} [opts.addFileButton=true] - Determines if the file button should be added for saving/loading annotations.\r\n * @param {boolean} [opts.buttonTogglesToolbar=true] - Determines if the AnnotationToolbar visibility is toggled by the AnnotationUI button.\r\n * @param {boolean} [opts.buttonTogglesLayerUI=true] - Determines if the LayerUI visibility is toggled by the AnnotationUI button.\r\n */\r\n    constructor(annotationToolkit,opts){\r\n        let defaultOpts = {\r\n            autoOpen:true,\r\n            featureCollections:[],\r\n            addButton:true,\r\n            addToolbar:true,\r\n            tools: null,\r\n            addLayerDialog:true,\r\n            addFileButton:true,\r\n            buttonTogglesToolbar:true,\r\n            buttonTogglesLayerUI:true,\r\n        }\r\n        opts = this.options = Object.assign(defaultOpts,opts);\r\n        let _viewer = this._viewer = annotationToolkit.viewer;//shorter alias\r\n        this._isOpen = !!opts.autoOpen;\r\n\r\n        \r\n        //AnnotationToolbar: UI for interactive tools\r\n        this._toolbar = new _annotationtoolbar_mjs__WEBPACK_IMPORTED_MODULE_1__.AnnotationToolbar(annotationToolkit.overlay.paperScope, opts.tools);\r\n        if(opts.addToolbar){\r\n            this._toolbar.addToOpenSeadragon(_viewer);\r\n        }\r\n\r\n\r\n        //FileDialog: UI for loading/saving data\r\n        this._fileDialog = new _filedialog_mjs__WEBPACK_IMPORTED_MODULE_3__.FileDialog(annotationToolkit,{appendTo:_viewer.element});\r\n        this._filebutton = null;\r\n        if(opts.addFileButton){\r\n        \r\n       //Handles the click event of the file button.\r\n            this._filebutton = annotationToolkit.overlay.addViewerButton({\r\n                onClick:()=>{\r\n                    this._fileDialog.toggle();\r\n                },\r\n                faIconClasses:'fa-solid fa-save',\r\n                tooltip:'Save/Load Annotations',\r\n            })\r\n        }       \r\n\r\n        //LayerUI: UI for managing collections/features\r\n        let dialogOpts={\r\n            filename:_viewer.world.getItemAt(0) && this._viewer.world.getItemAt(0).source.name,\r\n            positioningElement:(this,_viewer.navigator || this._viewer).element,\r\n            appendTo:this._viewer.element,\r\n            toolbar:this._toolbar,\r\n        }\r\n        this._layerUI = new _layerui_mjs__WEBPACK_IMPORTED_MODULE_2__.LayerUI(annotationToolkit.overlay.paperScope, dialogOpts);\r\n        if(opts.addLayerDialog){\r\n            this._createJqueryUIdialog();\r\n        }\r\n \r\n\r\n        opts.autoOpen ? (this._layerUI.show(),this._toolbar.show()) : (this._layerUI.hide(),this._toolbar.hide());\r\n\r\n        //Button for controlling LayerUI and/or AnnotationToolbar\r\n        this._button = null;\r\n        if(opts.addButton){           \r\n            this._button = annotationToolkit.overlay.addViewerButton({\r\n                onClick:()=>{\r\n                    this._isOpen = !this._isOpen;\r\n                    if(this._isOpen){\r\n                        this.options.buttonTogglesToolbar && this._toolbar.show();\r\n                        this.options.buttonTogglesLayerUI && this._layerUI.show();\r\n                    } else{\r\n                        this.options.buttonTogglesToolbar && this._toolbar.hide();\r\n                        this.options.buttonTogglesLayerUI && this._layerUI.hide();\r\n                    }\r\n                },\r\n                faIconClasses:'fa-solid fa-pencil',\r\n                tooltip:'Annotation Interface',\r\n            })\r\n        }\r\n\r\n        if(opts.featureCollections){\r\n            annotationToolkit.loadGeoJSON(opts.featureCollections);\r\n        }\r\n    }\r\n    destroy(){\r\n        this._layerUI.destroy();\r\n        this._toolbar.destroy();\r\n        if(this._button){\r\n            let idx = this._viewer.buttonGroup.buttons.indexOf(this._button);\r\n            if(idx>-1){\r\n                this._viewer.buttonGroup.buttons.splice(idx,1);\r\n            }\r\n            this._button.element.remove();//should this be \"button.destroy()\" or \"button.remove()\"?\r\n        }\r\n        if(this._filebutton){\r\n            let idx = this._viewer.buttonGroup.buttons.indexOf(this._filebutton);\r\n            if(idx>-1){\r\n                this._viewer.buttonGroup.buttons.splice(idx,1);\r\n            }\r\n            this._filebutton.element.remove();//should this be \"button.destroy()\" or \"button.remove()\"?\r\n        }\r\n        \r\n    }\r\n\r\n    get toolbar(){\r\n        return this._toolbar;\r\n    }\r\n    _createJqueryUIdialog(){\r\n        let element = this._layerUI.element;\r\n\r\n        let positioningElement=$((this._viewer.navigator || this._viewer).element);\r\n\r\n        element.on('element-added',function(ev){\r\n            let el = $(ev.target);\r\n            refreshDialogPosition(el);\r\n        })\r\n        element.dialog({\r\n            open:onOpen,\r\n            resize:limitHeight,\r\n            autoOpen:false,\r\n            closeOnEscape:false,\r\n            height:'auto',\r\n            appendTo:this._viewer.element,\r\n        });\r\n        element.closest('.ui-dialog').draggable('option','containment','parent')\r\n        \r\n        this._layerUI.addHandler('show',()=>{\r\n            element.dialog('open');\r\n        });\r\n        this._layerUI.addHandler('hide',()=>{\r\n            element.dialog('close');\r\n        });\r\n        this._layerUI.addHandler('destroy',()=>{\r\n            element.dialog('destroy');\r\n        })\r\n\r\n        //reset viewer's mouse tracker to parent container of viewer instead of inner container, so tracker captures UI dialogs as well\r\n        //to do: reset this on removal of the annotationUI?\r\n        this._viewer.outerTracker.setTracking(false);\r\n        this._viewer.outerTracker.element = this._viewer.element;\r\n        this._viewer.outerTracker.setTracking(true);\r\n\r\n        let fb=$('<button>',{class:'file-button'}).text('File')\r\n        .prependTo(element.dialog('instance').classesElementLookup['ui-dialog-title'])\r\n        .on('click',()=>{\r\n            this._fileDialog.dialog('open');    \r\n        });\r\n        fb.button({\r\n            showLabel:true,\r\n        })\r\n\r\n\r\n        function onOpen(){\r\n            positionDialog();\r\n        }\r\n        \r\n        function positionDialog(pos){\r\n            let defaultPos={my:'right top', at:'right top', of:positioningElement}\r\n            if(positioningElement.hasClass('navigator')){\r\n                defaultPos={my:'right top', at:'right bottom', of:positioningElement}\r\n            }\r\n            \r\n            pos = pos || defaultPos;\r\n\r\n            element.dialog('option','position',pos);\r\n            window.setTimeout(limitHeight,0)        \r\n        }\r\n        function limitHeight(){\r\n            let topOfFCList = element.offset().top;\r\n            let bottomOfVisibleWindow = $(window).height();\r\n            let maxheight = bottomOfVisibleWindow - topOfFCList - (element.outerHeight()-element.height())-5;\r\n            element.css({maxHeight:maxheight})\r\n        }\r\n        function refreshDialogPosition(scrolltoelement){\r\n            let pos = element.dialog('option','position');\r\n            positionDialog(pos);\r\n            scrolltoelement && setTimeout(()=>{\r\n                //scrolltoelement[0].scrollIntoView(false)\r\n                scrolltoelement[0].scrollIntoView({block: \"nearest\", inline: \"nearest\"})\r\n            }, 0);\r\n        }\r\n    }\r\n    \r\n}\r\n\r\n\n\n//# sourceURL=webpack://js/../src/js/annotationui.mjs?")},"../src/js/featurecollectionui.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FeatureCollectionUI: () => (/* binding */ FeatureCollectionUI)\n/* harmony export */ });\n/* harmony import */ var _featureui_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./featureui.mjs */ \"../src/js/featureui.mjs\");\n/* harmony import */ var _utils_editablecontent_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/editablecontent.mjs */ \"../src/js/utils/editablecontent.mjs\");\n\r\n\r\n\r\n/**\r\n * A user interface for managing feature collections.\r\n * @class\r\n */\r\nclass FeatureCollectionUI{\r\n    /**\r\n     * Create a new FeatureCollectionUI instance.\r\n     * @constructor\r\n     * @param {paper.Layer} layer - The paper layer object.\r\n     * @param {object} init - The initialization options.\r\n     */\r\n    constructor(layer,init){\r\n        let self=this;\r\n        // this.toolbar = init.toolbar;\r\n        this.element = makeFeatureCollectionElement();\r\n        this._editableName = new _utils_editablecontent_mjs__WEBPACK_IMPORTED_MODULE_1__.EditableContent();\r\n        this.element.find('.annotation-name.name').empty().append(this._editableName.element);\r\n        this._editableName.onChanged=function(text){\r\n            self.label = text;\r\n        }\r\n\r\n        this._featurelist=this.element.find('.features-list');\r\n        this._featurelist.sortable({\r\n            contain:'parent',\r\n            connectWith:`${init.guiSelector} .features-list`,\r\n            update:function(){\r\n                self._featurelist.children().each(function(idx,c){\r\n                    self.layer.addChild($(c).data('feature').paperItem);\r\n                })\r\n            },\r\n        });\r\n        this.layer = layer;\r\n        this.layer.on({\r\n            'selection:mouseenter':function(){self.element.addClass('svg-hovered').trigger('mouseover')},\r\n            'selection:mouseleave':function(){self.element.removeClass('svg-hovered').trigger('mouseout')},\r\n            'selected':function(){self.element.addClass('selected').trigger('selected')},\r\n            'deselected':function(){self.element.removeClass('selected').trigger('deselected')},\r\n            'display-name-changed':function(ev){\r\n                self.updateLabel();\r\n            },\r\n            'removed':function(){\r\n                self.remove();\r\n            },\r\n            'child-added':function(ev){\r\n                let featureUI = ev.item.FeatureUI || new _featureui_mjs__WEBPACK_IMPORTED_MODULE_0__.FeatureUI(ev.item);\r\n                self._addFeature(featureUI);\r\n            }\r\n        });\r\n\r\n        // expose this object as a property of the paper.js layer\r\n        this.layer.featureCollectionUI = this;\r\n\r\n        /**\r\n         * Get the features in the feature collection.\r\n         * @returns {FeatureUI[]} The array of features.\r\n         */\r\n        this.features = function(){\r\n            return self._featurelist.find('.feature').map(function(_,el){\r\n                return $(el).data('feature');\r\n            }).toArray();\r\n        }\r\n        /**\r\n         * Remove the feature collection UI element.\r\n         */\r\n        this.remove = function(){\r\n            self.element.remove();\r\n        }\r\n        /**\r\n         * Get the number of features in the feature collection.\r\n         * @returns {number} The number of features.\r\n         */\r\n        this.numFeatures = function(){\r\n            return self.features().length;\r\n        }\r\n\r\n        /**\r\n         * Add a feature to the feature collection UI element.\r\n         * @param {FeatureUI} f - The feature to add.\r\n         * @returns {jQuery} The jQuery object of the feature element.\r\n         */\r\n        this._addFeature=function(f){\r\n            f.paperItem.updateFillOpacity();\r\n            self._featurelist.append(f.element);\r\n            self._sortableDebounce && window.clearTimeout(self._sortableDebounce);\r\n            self._sortableDebounce = window.setTimeout(()=>$(`${init.guiSelector} .features-list .feature`).length>100 ? self._featurelist.sortable('disable') : self._featurelist.sortable('refresh'), 15);\r\n            return f.element; \r\n        }\r\n        /**\r\n         * Create a new feature and add it to the paper layer.\r\n         * @returns {paper.Item} The paper item object of the new feature.\r\n         */\r\n        this.createFeature=function(){\r\n            //define a new feature\r\n            let props = this.layer.defaultStyle;\r\n            let clonedProperties = {\r\n                fillColor:new paper.Color(props.fillColor),\r\n                strokeColor:new paper.Color(props.strokeColor),\r\n                rescale:$.extend(true,{},props.rescale),\r\n                fillOpacity:props.fillOpacity,\r\n                strokeOpacity:props.strokeOpacity,\r\n                strokeWidth:props.strokeWidth,\r\n            }\r\n            let style = new paper.Style(clonedProperties);\r\n            let geoJSON = {\r\n                type:'Feature',\r\n                geometry:null,\r\n                properties:style,\r\n            }\r\n            let placeholder = paper.Item.fromGeoJSON(geoJSON);\r\n            this.layer.addChild(placeholder);\r\n            return placeholder;\r\n        }\r\n\r\n        this.ui={\r\n            setOpacity:setOpacity,\r\n            setFillOpacity:setFillOpacity,\r\n        }\r\n\r\n        /**\r\n         * Set the opacity of the paper layer.\r\n         * @param {number} o - The opacity value between 0 and 1.\r\n         */\r\n        function setOpacity(o){\r\n            self.layer.opacity = o;\r\n        }\r\n        /**\r\n         * Set the fill opacity of the paper layer.\r\n         * @param {number} o - The fill opacity value between 0 and 1.\r\n         */\r\n        function setFillOpacity(o){\r\n            self.layer.fillOpacity = o;\r\n        }\r\n        \r\n        \r\n        self.element.data({featureCollection:self});//bind reference to self to the element, for use with rearranging/sorting layers\r\n\r\n        self.label = this.layer.displayName;\r\n\r\n        if(!self._featurelist.sortable('option','disabled') == false){\r\n            self._featurelist.sortable('refresh');\r\n        }\r\n        \r\n\r\n        self.element.on('click',function(ev){\r\n            ev.stopPropagation();\r\n        })\r\n        self.element.find('.toggle-list').on('click',function(ev){\r\n            let numFeatures = self._featurelist.children().length;\r\n            self.element.find('.num-annotations').text(numFeatures);\r\n            self.element.find('.features-summary').attr('data-num-elements',numFeatures);\r\n            self.element.find('.features').toggleClass('collapsed');\r\n            ev.stopPropagation();\r\n            ev.preventDefault();\r\n        });\r\n\r\n        self.element.find('.annotation-header [data-action]').on('click',function(ev){\r\n            //don't bubble up\r\n            ev.stopPropagation();\r\n            ev.preventDefault();\r\n            let action = $(ev.target).data('action');\r\n            switch(action){\r\n                case 'trash': self.removeLayer(true); break;\r\n                // case 'edit': self.editClicked(); break;\r\n                case 'style': self.openStyleEditor(ev); break;\r\n                case 'show': self.toggleVisibility(); break;\r\n                case 'hide': self.toggleVisibility(); break;\r\n                default: console.log('No function set for action:',action);\r\n            }\r\n            \r\n        });\r\n        self.element.find('.new-feature').on('click',function(ev){\r\n            ev.stopPropagation();\r\n            let item = self.createFeature();\r\n            item.select();\r\n        });\r\n\r\n        return this;\r\n    }\r\n    /**\r\n     * Get the label of the feature collection.\r\n     * @returns {string} The label of the feature collection.\r\n     */\r\n    get label(){\r\n        return this.layer.displayName;\r\n    }\r\n    /**\r\n     * Set the label of the feature collection.\r\n     * @param {string} l - The new label of the feature collection.\r\n     * @returns {string} The new label of the feature collection.\r\n     */\r\n    set label(l){\r\n        return this.setLabel(l)\r\n    }\r\n    /**\r\n     * Set the label of the feature collection with a source.\r\n     * @param {string} text - The new label of the feature collection.\r\n     * @param {string} source - The source of the label (e.g. 'user-defined' or 'initializing').\r\n     * @returns {string} The new label of the feature collection.\r\n     */\r\n    setLabel(text,source){\r\n        let l = new String(text);\r\n        l.source=source;\r\n        this.layer.displayName = l;\r\n        this.updateLabel();\r\n        return l;\r\n    }\r\n    /**\r\n     * Update the label of the feature collection in the UI element.\r\n     */\r\n    updateLabel(){\r\n        this._editableName.setText(this.label);\r\n    }\r\n    /**\r\n     * Toggle the visibility of the feature collection UI element and the paper layer.\r\n     */\r\n    toggleVisibility(){\r\n        this.element.toggleClass('annotation-hidden');\r\n        this.layer.visible = !this.element.hasClass('annotation-hidden');\r\n    }\r\n    /**\r\n     * Remove the paper layer associated with the feature collection.\r\n     * @param {boolean} [confirm=true] - Whether to confirm before removing or not.\r\n     */\r\n    removeLayer(confirm = true){\r\n        if(confirm && window.confirm('Remove this layer?')==true){\r\n            this.layer.remove();\r\n        } else {\r\n\r\n        }\r\n    }\r\n    /**\r\n     * Handle the edit clicked event on the UI element.\r\n     */\r\n    editClicked(){\r\n        let header = this.element.find('.annotation-header');\r\n        header.addClass('editing');\r\n        let ce = header.find('.edit').attr('contenteditable',true).focus();\r\n        ce.data('previous-text',ce.text());\r\n        let range = document.createRange();\r\n        range.selectNodeContents(ce[0]);\r\n        let selection = window.getSelection();\r\n        selection.removeAllRanges();\r\n        selection.addRange(range);  \r\n    }\r\n    /**\r\n     * Open the style editor for the feature collection.\r\n     * @param {object} ev - The event object.\r\n     */\r\n    openStyleEditor(ev){\r\n        let heard = this.layer.project.emit('edit-style',{item:this.layer});\r\n        if(!heard){\r\n            console.warn('No event listeners are registered for paperScope.project for event \\'edit-style\\'');\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Create an HTML element for the feature collection UI.\r\n * @returns {jQuery} The jQuery object of the HTML element.\r\n */\r\nfunction makeFeatureCollectionElement(){\r\n    let html = `\r\n    <div class='feature-collection'>\r\n        <div class='annotation-header hoverable-actions'>\r\n            <span class=\"visibility-toggle\"><span class=\"fa fa-eye\" data-action=\"hide\"></span><span class=\"fa fa-eye-slash\" data-action=\"show\"></span></span>\r\n            <span class='annotation-name name'></span>\r\n            <span class='onhover fa-solid fa-palette' data-action='style' title='Open style editor'></span>\r\n            <span class='onhover fa-solid fa-trash-can' data-action='trash' title='Remove feature collection'></span>\r\n        </div>\r\n        <div class=\"flex-row features\">\r\n            <div class=\"toggle-list btn-group btn-group-sm\"><button class=\"btn btn-default\"><span class='fa-solid fa-caret-down' data-action=\"collapse-down\"></span><span class='fa-solid fa-caret-up' data-action=\"collapse-up\"></span></button></div>\r\n            <div class=\"annotation-details\">\r\n                <div>\r\n                    <div class='features-summary feature-item name'><span class='num-annotations'></span> annotation element<span class='pluralize'></span></div>\r\n                    <div class='features-list'></div>\r\n                </div>\r\n                <div class='new-feature feature'><span class='fa fa-plus' data-action=\"add-feature\"></span>Add feature</div>\r\n            </div>\r\n        </div>\r\n    </div>\r\n    `;\r\n    return $(html);\r\n}\n\n//# sourceURL=webpack://js/../src/js/featurecollectionui.mjs?")},"../src/js/featureui.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FeatureUI: () => (/* binding */ FeatureUI)\n/* harmony export */ });\n/* harmony import */ var _utils_editablecontent_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/editablecontent.mjs */ \"../src/js/utils/editablecontent.mjs\");\n\r\n/**\r\n * A user interface for managing features.\r\n * @class\r\n */\r\nclass FeatureUI{\r\n    /**\r\n     * Create a new FeatureUI instance.\r\n     * @constructor\r\n     * @param {paper.Item} paperItem - The paper item object.\r\n     */\r\n    constructor(paperItem){\r\n        \r\n        let self=this;\r\n        this.paperItem=paperItem;\r\n        let el = this._element = makeFeatureElement();\r\n        this.paperItem.FeatureUI = this;\r\n        this._editableName = new _utils_editablecontent_mjs__WEBPACK_IMPORTED_MODULE_0__.EditableContent();\r\n        el.find('.feature-item.name').empty().append(this._editableName.element);\r\n        this._editableName.onChanged = function(text){\r\n            self.setLabel(text,'user-defined');\r\n        };\r\n        \r\n        // let guid= 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g,function(c) {\r\n        //     let r = Math.random() * 16|0;\r\n        //     let v = c == 'x' ? r : (r&0x3|0x8);\r\n        //     return v.toString(16);\r\n        // });\r\n\r\n        \r\n        el.data({feature:self});\r\n        el.find('[data-action]').on('click', function(ev){\r\n            //don't bubble up\r\n            ev.stopPropagation();\r\n            ev.preventDefault();\r\n            let action = $(ev.target).data('action');\r\n            switch(action){\r\n                case 'trash': self.removeItem(); break;\r\n                case 'edit': self.editClicked(); break;\r\n                case 'bounds': self.useAsBoundingElement(); break;\r\n                case 'style':self.openStyleEditor(ev); break;\r\n                case 'zoom-to':self.centerItem(); break;\r\n                default: console.log('No function set for action:',action);\r\n            }\r\n            \r\n        });\r\n        \r\n        // $(this._editableName.element).on('value-changed',function(ev,val){\r\n        //     self.setLabel(val,'user-defined');\r\n        // });\r\n        el.on('click',function(ev){\r\n            ev.stopPropagation();\r\n            self.paperItem.toggle((ev.metaKey || ev.ctrlKey));\r\n        })\r\n\r\n        \r\n        \r\n        // el.on('focusout','.editablecontent.editing .edit', function(){\r\n        //     let parent=$(this).closest('.editablecontent');\r\n        //     let oldtext = $(this).data('previous-text');\r\n        //     let newtext = $(this).text().trim();\r\n        //     if(newtext !== oldtext) parent.find('.edit').trigger('value-changed',newtext);\r\n        //     parent.removeClass('editing');\r\n        //     $(this).removeAttr('contenteditable').text(newtext);\r\n        // });\r\n        // el.on('keypress','.editablecontent.editing .edit', function(ev){\r\n        //     ev.stopPropagation();\r\n        //     if(ev.which==13){\r\n        //         ev.preventDefault();\r\n        //         $(this).blur();\r\n        //     }\r\n        // });\r\n        // el.on('keydown keyup','.editablecontent.editing .edit',function(ev){ev.stopPropagation()})\r\n        \r\n        this.element = el;\r\n        this.paperItem.on({\r\n            'selected':function(){ el.addClass('selected').trigger('selected'); },\r\n            'deselected':function(){ el.removeClass('selected').trigger('deselected'); },\r\n            'selection:mouseenter':function(){el.addClass('item-hovered')},\r\n            'selection:mouseleave':function(){el.removeClass('item-hovered')},\r\n            'item-replaced':function(ev){\r\n                // console.log('item-replaced',ev);\r\n                //check label first because it is dynamically fetched from the referenced this.paperItem object\r\n                if(self.label.source=='user-defined'){\r\n                    ev.item.displayName = self.label;\r\n                }\r\n                self.paperItem = ev.item;\r\n                self.paperItem.FeatureUI=self;\r\n                self.updateLabel();\r\n            },\r\n            'display-name-changed':function(ev){\r\n                self.updateLabel();\r\n            },\r\n            'removed':function(ev){\r\n                if(ev.item == self.paperItem){\r\n                    self.remove();\r\n                }\r\n            }\r\n        });\r\n\r\n        if(this.paperItem.selected){\r\n            this.paperItem.emit('selected');\r\n        }\r\n\r\n        this.label ? this.updateLabel() : this.setLabel('Creating...', 'initializing');\r\n        \r\n    }\r\n    /**\r\n     * Get the label of the feature.\r\n     * @returns {string} The label of the feature.\r\n     */\r\n    get label(){\r\n        return this.paperItem.displayName;\r\n    }\r\n    /**\r\n     * Set the label of the feature.\r\n     * @param {string} l - The new label of the feature.\r\n     * @returns {string} The new label of the feature.\r\n     */\r\n    set label(l){\r\n        return this.setLabel(l)\r\n    }\r\n    /**\r\n     * Set the label of the feature with a source.\r\n     * @param {string} text - The new label of the feature.\r\n     * @param {string} source - The source of the label (e.g. 'user-defined' or 'initializing').\r\n     * @returns {string} The new label of the feature.\r\n     */\r\n    setLabel(text,source){\r\n        let l = new String(text);\r\n        l.source=source;\r\n        this.paperItem.displayName = l;\r\n        this.updateLabel();\r\n        return l;\r\n    }\r\n    /**\r\n     * Update the label of the feature in the UI element.\r\n     */\r\n    updateLabel(){\r\n        // this._element.find('.feature-item.name').text(this.label);//.trigger('value-changed',[l]);\r\n        this._editableName.setText(this.label);\r\n    }\r\n    /**\r\n     * Remove the paper item associated with the feature.\r\n     */\r\n    removeItem(){        \r\n        //clean up paperItem\r\n        this.paperItem.remove();\r\n        this.paperItem.deselect();\r\n    }\r\n    /**\r\n     * Remove the UI element associated with the feature.\r\n     */\r\n    remove(){\r\n        this._element.remove().trigger('removed');\r\n    }\r\n    /**\r\n     * Handle the edit clicked event on the UI element.\r\n     */\r\n    editClicked(){\r\n        let header = this._element.find('.editablecontent');\r\n        header.addClass('editing');\r\n        let ce = header.find('.edit').attr('contenteditable',true).focus();\r\n        ce.data('previous-text',ce.text());\r\n        let range = document.createRange();\r\n        range.selectNodeContents(ce[0]);\r\n        let selection = window.getSelection();\r\n        selection.removeAllRanges();\r\n        selection.addRange(range);\r\n    }\r\n    /**\r\n     * Use the feature as a bounding element.\r\n     * @param {boolean} [toggle=false] - Whether to toggle the bounding element status or not.\r\n     * @returns {boolean} Whether the feature is used as a bounding element or not.\r\n     */\r\n    useAsBoundingElement(toggle=false){\r\n        if(!this.paperItem.canBeBoundingElement) return false;\r\n        let element = this._element.find('[data-action=\"bounds\"]');\r\n        if(toggle){\r\n            element.find('[data-action=\"bounds\"]').toggleClass('active');\r\n        } else {\r\n            element.find('[data-action=\"bounds\"]').addClass('active');\r\n        }\r\n        let isActive = element.hasClass('active');\r\n        this.paperItem.isBoundingElement = isActive;\r\n        return isActive;\r\n    }   \r\n    /**\r\n     * Open the style editor for the feature.\r\n     */ \r\n    openStyleEditor(){\r\n        let heard = this.paperItem.project.emit('edit-style',{item:this.paperItem});\r\n        if(!heard){\r\n            console.warn('No event listeners are registered for paperScope.project for event \\'edit-style\\'');\r\n        }\r\n    }\r\n    /**\r\n     * Center the feature in the viewport.\r\n     * @param {boolean} [immediately=false] - Whether to center the feature immediately or not.\r\n     */\r\n    centerItem(immediately = false){\r\n        let viewport = this.paperItem.project.overlay.osdViewer.viewport;\r\n        let bounds = this.paperItem.bounds;\r\n        let center = viewport.imageToViewportCoordinates(bounds.center.x,bounds.center.y);\r\n        let scale=1.5;\r\n        let xy = viewport.imageToViewportCoordinates(bounds.center.x - bounds.width/scale, bounds.center.y - bounds.height/scale);\r\n        let wh = viewport.imageToViewportCoordinates(2*bounds.width/scale, 2*bounds.height/scale);\r\n        let rect=new OpenSeadragon.Rect(xy.x, xy.y, wh.x,wh.y);\r\n        let vb = viewport.getBounds();\r\n        if(rect.width > vb.width || rect.height > vb.height){\r\n            viewport.fitBounds(rect, immediately);\r\n        }\r\n        else{\r\n            viewport.panTo(center, immediately);\r\n        }\r\n        // console.log('centerItem clicked',rect)\r\n    }\r\n    \r\n}\r\n\r\n/**\r\n * Create an HTML element for the feature UI.\r\n * @returns {jQuery} The jQuery object of the HTML element.\r\n */\r\nfunction makeFeatureElement(){\r\n    let html = `\r\n    <div class='feature'>\r\n        <div class='hoverable-actions'>\r\n            <span class='onhover fa-solid fa-crop-simple bounding-element' data-action=\"bounds\" title='Bounding element'></span>\r\n            <span class='feature-item name'></span>\r\n            <span class='onhover fa-solid fa-palette' data-action='style' title='Open style editor'></span>\r\n            <span class='onhover fa-solid fa-binoculars' data-action='zoom-to' title='View this feature'></span>\r\n            <span class='onhover fa-solid fa-trash-can' data-action='trash' title='Remove'></span>\r\n        </div>\r\n    </div>\r\n    `;\r\n    return $(html);\r\n}\n\n//# sourceURL=webpack://js/../src/js/featureui.mjs?")},"../src/js/filedialog.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FileDialog: () => (/* binding */ FileDialog)\n/* harmony export */ });\n/* harmony import */ var _utils_editablecontent_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/editablecontent.mjs */ \"../src/js/utils/editablecontent.mjs\");\n\r\n\r\nclass FileDialog{\r\n\r\n    /**\r\n     * Creates an instance of the FileDialog.\r\n     *\r\n     * @param {any} atk - The AnnotationToolKit object.\r\n     * @param {object} opts - Additional options for the file dialog.\r\n     */\r\n    constructor(atk, opts){\r\n        let _this=this;\r\n        this.element = $(fileDialogHtml()).appendTo('body');\r\n        this.element.dialog({closeOnEscape:false,autoOpen:false,modal:false,open:initDlg,width:'auto','appendTo':opts.appendTo});\r\n        // this.dialog = function(...args){ this.element.dialog(...args) }\r\n\r\n        this.element.find('button[data-action=\"geojson-load\"]').on('click',loadGeoJSON)\r\n        this.element.find('button[data-action=\"geojson-save\"]').on('click',saveGeoJSON)\r\n        this.element.find('button[data-action=\"svg-export\"]').on('click',exportSVG)\r\n        this.element.find('button[data-action=\"png-export\"]').on('click',exportPNG)\r\n        this.element.find('button[data-action=\"ls-store\"]').on('click',localstorageStore)\r\n        this.element.find('button[data-action=\"ls-load\"]').on('click',localstorageLoad)\r\n        /**\r\n         * Gets the name of the currently displayed file.\r\n         *\r\n         * @returns {string} The file name.\r\n         */\r\n        function getFileName(){\r\n            return atk.viewer.world.getItemAt(0) ? atk.viewer.world.getItemAt(0).source.name : '';\r\n        }\r\n        function initDlg(){\r\n            _this.element.find('.featurecollection-list').empty();\r\n            _this.element.find('.finalize').empty();\r\n        }\r\n                /**\r\n         * Sets up the feature collection list in the dialog.\r\n         *\r\n         * @param {Array} fcarray - An array of feature collections.\r\n         * @returns {jQuery} The feature collection list element.\r\n         */\r\n        function setupFeatureCollectionList(fcarray){\r\n            let list = _this.element.find('.featurecollection-list').empty();\r\n            let els = fcarray.map(function(fc){\r\n                let label = fc.label || fc.displayName; //handle geoJSON objects or paper.Layers\r\n                let d = $('<div>');\r\n                $('<input>',{type:'checkbox',checked:true}).appendTo(d).data('fc',fc);\r\n                $('<label>').text(label).appendTo(d);\r\n                return d;\r\n            });\r\n            list.append(els);\r\n            return list;\r\n        }\r\n        /**\r\n         * Loads a GeoJSON file.\r\n         */\r\n        function loadGeoJSON(){\r\n            initDlg();\r\n            let finput = $('<input>',{type:'file',accept:'text/geojson,.geojson,text/json,.json'});\r\n            finput.on('change',function(){\r\n                // console.log('File picked',this.files[0]);\r\n                let file = this.files[0];\r\n                let fr = new FileReader();\r\n                let geoJSON=[];\r\n                fr.onload=function(){\r\n                    try{\r\n                        geoJSON = JSON.parse(this.result);\r\n                    }catch(e){\r\n                        alert('Bad file - JSON could not be parsed');\r\n                        return;\r\n                    }\r\n                    if(!Array.isArray(geoJSON)) geoJSON = [geoJSON];\r\n                    let type = Array.from(new Set(geoJSON.map(e=>e.type)))\r\n                    if(type.length==0){\r\n                        _this.element.find('.featurecollection-list').text('Bad file - no Features or FeatureCollections were found')\r\n                    }\r\n                    if(type.length > 1){\r\n                        alert('Bad file - valid geoJSON consists of an array of objects with single type (FeatureCollection or Feature)');\r\n                        return;\r\n                    }\r\n                    //type.length==1\r\n                    //convert list of features into a featurecolletion\r\n                    if(type[0]=='Feature'){\r\n                        let fc = [{\r\n                            type:'FeatureCollection',\r\n                            features:geoJSON,\r\n                            properties:{\r\n                                label:file.name\r\n                            }\r\n                        }];\r\n                        geoJSON = fc;\r\n                    }\r\n                    setupFeatureCollectionList(geoJSON);\r\n                    let replace = $('<button>').appendTo(_this.element.find('.finalize')).text('Replace existing layers');\r\n                    replace.on('click',function(){ atk.addFeatureCollections(geoJSON,true); });\r\n                    let add = $('<button>').appendTo(_this.element.find('.finalize')).text('Add new layers');\r\n                    add.on('click',function(){ atk.addFeatureCollections(geoJSON,false); });\r\n                }\r\n                fr.readAsText(file);\r\n            })\r\n            finput.trigger('click');\r\n        }\r\n        /**\r\n         * Loads the feature collections from the local storage.\r\n         */\r\n        function localstorageLoad(){\r\n            initDlg();\r\n            let geoJSON=[];\r\n            let filename=getFileName();\r\n            let lskeys=Object.keys(window.localStorage);\r\n            let list = _this.element.find('.featurecollection-list').empty();\r\n            let div=$('<div>',{class:'localstorage-key-list'}).appendTo(list);\r\n            let items=lskeys.sort((a,b)=>a.localeCompare(b)).map(key=>$('<div>',{class:'localstorage-key',style:`order: ${key==filename?0:1}`}).text(key));\r\n            div.append(items);\r\n            $(list).find('.localstorage-key').on('click',function(){\r\n                let lsdata = window.localStorage.getItem($(this).text());\r\n                if(!lsdata){\r\n                    alert(`No data found in local storage for key=${$(this).text()}`);\r\n                    return;\r\n                }\r\n                try{\r\n                    geoJSON = JSON.parse(lsdata);\r\n                }catch(e){\r\n                    alert('Bad data - JSON could not be parsed');\r\n                    return;\r\n                }\r\n                setupFeatureCollectionList(geoJSON);\r\n                let replace = $('<button>').appendTo(_this.element.find('.finalize')).text('Replace existing layers');\r\n                replace.on('click',function(){ atk.addFeatureCollections(geoJSON, true); });\r\n                let add = $('<button>').appendTo(_this.element.find('.finalize')).text('Add new layers');\r\n                add.on('click',function(){ atk.addFeatureCollections(geoJSON, false); });\r\n            })\r\n            \r\n            \r\n        }\r\n        /**\r\n         * Saves the feature collections as a GeoJSON file.\r\n         */        \r\n        function saveGeoJSON(){\r\n            initDlg();\r\n            let fcs = atk.toGeoJSON();\r\n            let list = setupFeatureCollectionList(fcs);\r\n            let finishbutton = setupFinalize('Create file','Choose file name:',getFileName()+'-FeatureCollections.json');\r\n            finishbutton.on('click',function(){\r\n                $(this).parent().find('.download-link').remove();\r\n                \r\n                let toSave=list.find('input:checked').toArray().map(function(cb){return $(cb).data('fc')});\r\n                let txt = JSON.stringify(toSave);\r\n                let blob = new Blob([txt],{type:'text/json'});\r\n                let filename=$(this).data('label'); \r\n                let dl = $('<div>',{class:'download-link'}).insertAfter(this);\r\n                $('<a>',{href:window.URL.createObjectURL(blob),download:filename,target:'_blank'}).appendTo(dl).text('Download file');\r\n            })\r\n        }\r\n        /**\r\n         * Exports the feature collections as an SVG file.\r\n         */        \r\n        function exportSVG(){\r\n            initDlg();\r\n            let fcs = atk.toGeoJSON();\r\n            let list = setupFeatureCollectionList(fcs);\r\n            let finishbutton = setupFinalize('Create file','Choose file name:',getFileName()+'-FeatureCollections.svg');\r\n            finishbutton.on('click',function(){\r\n                $(this).parent().find('.download-link').remove();\r\n                let toSave=list.find('input:checked').toArray().map(function(cb){return $(cb).data('fc')});\r\n                if(toSave.length>0){\r\n                    let p = new paper.PaperScope();\r\n                    p.setup();\r\n                    toSave.forEach(function(s){\r\n                        p.project.addLayer(s.layer.clone({insert:false,deep:true}));\r\n                    })\r\n                    let blob = new Blob([p.project.exportSVG({asString:true,bounds:'content'})],{type:'text/svg'});\r\n                    let filename=$(this).data('label');\r\n                    let dl = $('<div>',{class:'download-link'}).insertAfter(this);\r\n                    $('<a>',{href:window.URL.createObjectURL(blob),download:filename,target:'_blank'}).appendTo(dl).text('Download file');\r\n                }\r\n            })\r\n        }\r\n        /**\r\n         * Exports the feature collections as a PNG file.\r\n         */\r\n        function exportPNG(){\r\n            initDlg();\r\n            let fcs = atk.getFeatureCollectionLayers();\r\n            let list = setupFeatureCollectionList(fcs);\r\n            let finishbutton = setupFinalize('Create file','Choose file name:',getFileName()+'-raster.png');\r\n            finishbutton.on('click',function(){\r\n                $(this).parent().find('.download-link').remove();\r\n                let toSave=list.find('input:checked').toArray().map(function(cb){return $(cb).data('fc')});\r\n                if(toSave.length>0){\r\n                    let p = new paper.PaperScope();\r\n                    p.setup();\r\n                    toSave.forEach(function(s){\r\n                        p.project.activeLayer.addChildren(s.layer.clone({insert:false,deep:true}).children);\r\n                    })\r\n                    // let blob = new Blob([p.project.activeLayer.rasterize({insert:false}).toDataURL()],{type:'image/png'});\r\n                    let filename=$(this).data(label);\r\n                    let dl = $('<div>',{class:'download-link'}).insertAfter(this);\r\n                    $('<a>',{href:p.project.activeLayer.rasterize({insert:false}).toDataURL(),download:filename,target:'_blank'}).appendTo(dl).text('Download file');\r\n                }\r\n            })\r\n        }\r\n        /**\r\n         * Stores the feature collections in the local storage.\r\n         */        \r\n        function localstorageStore(){\r\n            initDlg();\r\n            let fcs = atk.toGeoJSON();\r\n            let list = setupFeatureCollectionList(fcs);\r\n            let finishbutton=setupFinalize('Save data','Local storage key:',getFileName(),true)\r\n            finishbutton.on('click',function(){\r\n                let toSave=list.find('input:checked').toArray().map(function(cb){return $(cb).data('fc')});\r\n                let txt = JSON.stringify(toSave);\r\n                let filename=$(this).data('label');\r\n                window.localStorage.setItem(filename,txt);\r\n            })\r\n        }\r\n        /**\r\n         * Sets up the finalize button.\r\n         *\r\n         * @param {string} buttonText - The text to display on the button.\r\n         * @param {string} editableLabel - The label for the editable content.\r\n         * @param {string} editableContent - The initial content for the editable content.\r\n         * @param {boolean} localstorage - Whether to test for local storage.\r\n         * @returns {jQuery} The finish button element.\r\n         */\r\n        function setupFinalize(buttonText,editableLabel,editableContent,localstorage){\r\n            function testLocalstorage(localstorage, text, div){\r\n                if(localstorage) Object.keys(localStorage).includes(text) ? div.addClass('key-exists') : div.removeClass('key-exists');\r\n            }\r\n            let finalize=_this.element.find('.finalize');\r\n            let finishbutton = $('<button>').text(buttonText);\r\n            let ec;\r\n            if(editableLabel){\r\n                let div = $('<div>').appendTo(finalize);\r\n                div.append($('<div>').text(editableLabel));\r\n                ec = new _utils_editablecontent_mjs__WEBPACK_IMPORTED_MODULE_0__.EditableContent({initialContent:editableContent});\r\n                div.append(ec.element);\r\n                if(localstorage) div.addClass('localstorage-key-test');\r\n                ec.onChanged= (text)=>{\r\n                    finishbutton.data('label',text);\r\n                    testLocalstorage(localstorage, text, div);\r\n                }\r\n                testLocalstorage(localstorage, editableContent, div);\r\n            }\r\n            finishbutton.appendTo(finalize).data({label:editableContent,ec:ec});\r\n            return finishbutton;\r\n        }\r\n        /**\r\n         * Returns the HTML for the file dialog.\r\n         *\r\n         * @returns {string} The HTML for the file dialog.\r\n         */\r\n        function fileDialogHtml(){\r\n            return `\r\n                <div class=\"annotation-ui-filedialog\" title=\"Save and Load Feature Collections\">\r\n                    <div class=\"file-actions\">\r\n                        <div class='header'>1. Available actions</div>\r\n                        <button class='btn' data-action='geojson-load'>Load GeoJSON</button>\r\n                        <button class='btn' data-action='ls-load'>Load from browser</button>\r\n                        <hr>\r\n                        <button class='btn' data-action='geojson-save'>Save GeoJSON</button>\r\n                        <button class='btn' data-action='svg-export'>Export as SVG</button>\r\n                        <button class='btn' data-action='png-export'>Rasterize to PNG</button>\r\n                        <button class='btn' data-action='ls-store'>Store in browser</button>\r\n                    </div>\r\n                    <div class='featurecollection-selection'>\r\n                        <div class='header'>2. Select Feature Collections</div>\r\n                        <div class='featurecollection-list'></div>\r\n                    </div>\r\n                    <div class=\"finalize-panel\">\r\n                        <div class='header'>3. Finalize</div>\r\n                        <div class='finalize'>\r\n                        \r\n                        </div>\r\n                    </div>\r\n                </div>`;\r\n        }\r\n    }\r\n    /**\r\n     * Shows the file dialog.\r\n     */\r\n    show(){\r\n        this.element.dialog('open');\r\n    }\r\n    /**\r\n     * Hides the file dialog.\r\n     */\r\n    hide(){\r\n        this.element.dialog('close');\r\n    }\r\n    /**\r\n     * Toggles the visibility of the file dialog.\r\n     */\r\n    toggle(){\r\n        this.element.dialog('isOpen') ? this.element.dialog('close') : this.element.dialog('open');\r\n    }\r\n    /**\r\n     * Calls a method on the dialog element.\r\n     *\r\n     * @param {...any} args - The arguments to pass to the method.\r\n     */\r\n    dialog(...args){\r\n        this.element.dialog(...args)\r\n    }\r\n}\n\n//# sourceURL=webpack://js/../src/js/filedialog.mjs?")},"../src/js/layerui.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LayerUI: () => (/* binding */ LayerUI)\n/* harmony export */ });\n/* harmony import */ var _featurecollectionui_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./featurecollectionui.mjs */ \"../src/js/featurecollectionui.mjs\");\n\r\n\r\n/**\r\n * A user interface for managing layers of feature collections.\r\n * @class\r\n * @extends OpenSeadragon.EventSource\r\n */\r\nclass LayerUI extends OpenSeadragon.EventSource{\r\n\r\n    /**\r\n     * Create a new LayerUI instance.\r\n     * @constructor\r\n     * @param {paper.PaperScope} paperScope - The paper scope object.\r\n     */\r\n    constructor(paperScope){\r\n        super();\r\n        let self=this;\r\n        \r\n        this.paperScope = paperScope;\r\n        this.paperScope.project.on('feature-collection-added',ev=>this._onFeatureCollectionAdded(ev));\r\n        \r\n        self.element = makeHTMLElement();\r\n        \r\n        //make this an event source\r\n        // OpenSeadragon.extend(LayerUI.prototype, OpenSeadragon.EventSource.prototype);\r\n        // OpenSeadragon.EventSource.call(this);\r\n        \r\n        self.element.find('.new-feature-collection').on('click',function(ev){\r\n            ev.stopPropagation();\r\n            ev.preventDefault();\r\n            // self.addFeatureCollection();\r\n            self.paperScope.createFeatureCollectionLayer();\r\n        });\r\n        self.element.find('.toggle-annotations').on('click',function(ev){\r\n            let hidden = self.element.find('.annotation-ui-feature-collections .feature-collection.annotation-hidden');\r\n            if(hidden.length > 0) hidden.find('[data-action=\"show\"]').trigger('click');\r\n            else self.element.find('.annotation-ui-feature-collections .feature-collection:not(.hidden) [data-action=\"hide\"]').trigger('click');\r\n        });\r\n\r\n\r\n        //setup sortable featurecollection interface\r\n        self.element.find('.annotation-ui-feature-collections').sortable({contain:'parent',update:function(){\r\n            self.element.find('.annotation-ui-feature-collections .feature-collection').each(function(idx,g){\r\n                let fg = $(g).data('featureCollection');\r\n                fg.layer.bringToFront();\r\n            })\r\n        }})\r\n\r\n        \r\n        //set up delegated events\r\n\r\n        self.element.on('selected','.feature',function(ev){\r\n            ev.stopPropagation();\r\n            $(this).addClass('selected');\r\n            this.scrollIntoViewIfNeeded();\r\n        });\r\n        self.element.on('deselected','.feature',function(ev){\r\n            ev.stopPropagation();\r\n            $(this).removeClass('selected');\r\n        });\r\n\r\n        \r\n        self.element.on('click','.toggle-list',function(ev){\r\n            $(this).closest('.features').toggleClass('collapsed');\r\n            ev.stopPropagation();\r\n        });\r\n        \r\n        self.element.on('value-changed',function(){\r\n            let el = $(this);\r\n            console.log('value-changed',el);\r\n            self.element.find('.feature.selected').trigger('selected');\r\n            self.element.find('.feature-collection.active').trigger('selected');\r\n        });\r\n\r\n        self.element.find('input.annotation-total-opacity').on('input',function(){\r\n            setOpacity(this.value);\r\n        }).trigger('input');\r\n\r\n        self.element.find('input.annotation-fill-opacity').on('input',function(){\r\n            self.paperScope.view.fillOpacity = this.value;\r\n        }).trigger('input');\r\n        /**\r\n         * Set the opacity of the feature collections.\r\n         * @param {number} o - The opacity value between 0 and 1.\r\n         */\r\n        function setOpacity(o){\r\n            let status = self.element.find('.feature-collection').toArray().reduce(function(ac,el){\r\n                el = $(el)\r\n                if( el.hasClass('selected') ){\r\n                    ac.selected.push(el);\r\n                }\r\n                else if( el.is(':hover,.svg-hovered')){\r\n                    ac.hover.push(el);\r\n                }\r\n                else{\r\n                    ac.other.push(el);\r\n                }\r\n                return ac;\r\n            },{selected:[],hover:[],other:[]});\r\n            if(status.selected.length>0){\r\n                status.selected.forEach(function(el){\r\n                    let opacity=1 * o;\r\n                    let fc=$(el).data('featureCollection');\r\n                    fc&&fc.ui.setOpacity(opacity)\r\n                })\r\n                status.hover.concat(status.other).forEach(function(el){\r\n                    let opacity=0.25 * o;\r\n                    let fc=$(el).data('featureCollection');\r\n                    fc&&fc.ui.setOpacity(opacity)\r\n                })\r\n            }\r\n            else if(status.hover.length>0){\r\n                status.hover.forEach(function(el){\r\n                    let opacity=1 * o;\r\n                    let fc=$(el).data('featureCollection');\r\n                    fc&&fc.ui.setOpacity(opacity)\r\n                })\r\n                status.other.forEach(function(el){\r\n                    let opacity=0.25 * o;\r\n                    let fc=$(el).data('featureCollection');\r\n                    fc&&fc.ui.setOpacity(opacity)\r\n                })\r\n            }\r\n            else{\r\n                status.other.forEach(function(el){\r\n                    let opacity=1 * o;\r\n                    let fc=$(el).data('featureCollection');\r\n                    fc&&fc.ui.setOpacity(opacity)\r\n                })\r\n            }\r\n        }\r\n        \r\n    }\r\n    /**\r\n     * Hide the layer UI element.\r\n     * @method\r\n     */\r\n    hide(){\r\n        this.element.hide();\r\n        this.raiseEvent('hide');\r\n    }\r\n    /**\r\n     * Show the layer UI element.\r\n     * @method\r\n     */\r\n    show(){\r\n        this.element.show();\r\n        this.raiseEvent('show');\r\n    }\r\n    /**\r\n     * Toggle the visibility of the layer UI element.\r\n     * @method\r\n     */\r\n    toggle(){\r\n        this.element.is(':visible') ? this.hide() : this.show();\r\n    }\r\n    /**\r\n     * Deactivate the layer UI element.\r\n     * @method\r\n     */\r\n    deactivate(){\r\n        this.element.addClass('deactivated');\r\n    }\r\n    /**\r\n     * Activate the layer UI element.\r\n     * @method\r\n     */\r\n    activate(){\r\n        this.element.removeClass('deactivated');\r\n    }\r\n    /**\r\n     * Destroy the layer UI element.\r\n     * @method\r\n     */\r\n    destroy(){\r\n        this.raiseEvent('destroy');\r\n        this.element.remove();\r\n    }\r\n    \r\n    //private\r\n\r\n    /**\r\n     * Handle the feature collection added event.\r\n     * @param {object} ev - The event object.\r\n     */\r\n    _onFeatureCollectionAdded(ev){\r\n        let layer = ev.layer;\r\n        \r\n        let fc=new _featurecollectionui_mjs__WEBPACK_IMPORTED_MODULE_0__.FeatureCollectionUI(layer, {guiSelector:`[data-ui-id=\"${this.element.data('ui-id')}\"]`});\r\n        this.element.find('.annotation-ui-feature-collections').append(fc.element).sortable('refresh');\r\n        fc.element.trigger('element-added');\r\n        setTimeout(function(){fc.element.addClass('inserted'); }, 30);//this allows opacity fade-in to be triggered\r\n\r\n    }\r\n    \r\n    \r\n\r\n}\r\n/**\r\n * Create an HTML element for the layer UI.\r\n * @returns {jQuery} The jQuery object of the HTML element.\r\n */\r\nfunction makeHTMLElement(){\r\n    let html = `\r\n        <div class=\"annotation-ui-mainwindow\" title=\"Annotations\">\r\n            <div class='annotation-ui-toolbar annotation-visibility-controls'>                \r\n                <div class=\"visibility-buttons btn-group btn-group-sm disable-when-deactivated\" role=\"group\">\r\n                    <button class=\"btn btn-default toggle-annotations\" type=\"button\" title=\"Toggle annotations\">\r\n                        <span class=\"glyphicon glyphicon-eye-open fa fa-eye\"></span><span class=\"glyphicon glyphicon-eye-close fa fa-eye-slash\"></span>\r\n                    </button>\r\n                </div>\r\n                <span class=\"annotation-opacity-container disable-when-annotations-hidden\" title=\"Change total opacity\">\r\n                    <input class=\"annotation-total-opacity\" type=\"range\" min=\"0\" max=\"1\" step=\"0.01\" value=\"1\">\r\n                </span>\r\n                <span class=\"annotation-opacity-container disable-when-annotations-hidden\" title=\"Change fill opacity\">\r\n                    <input class=\"annotation-fill-opacity\" type=\"range\" min=\"0\" max=\"1\" step=\"0.01\" value=\"0.25\">\r\n                </span>\r\n            </div>\r\n            <div class='annotation-ui-toolbar disable-when-deactivated disable-when-annotations-hidden'>\r\n                <label>Feature Collections:</label>\r\n            </div>\r\n            <div class='annotation-ui-feature-collections disable-when-annotations-hidden disable-when-deactivated'></div>\r\n            <div class='new-feature-collection disable-when-deactivated'><span class='glyphicon glyphicon-plus fa fa-plus'></span>Add Feature Collection</div>\r\n        </div>`;\r\n    let element = $(html);\r\n    let guid= 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g,function(c) {\r\n        let r = Math.random() * 16|0;\r\n        let v = c == 'x' ? r : (r&0x3|0x8);\r\n        return v.toString(16);\r\n    });\r\n    element.attr('data-ui-id',guid);\r\n    return element;\r\n}\n\n//# sourceURL=webpack://js/../src/js/layerui.mjs?")},"../src/js/paper-offset.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PaperOffset: () => (/* binding */ PaperOffset)\n/* harmony export */ });\n////// Offset.js\r\n/* Downloaded from https://github.com/glenzli/paperjs-offset/ on 10/9/2021 */\r\n/*\r\nMIT License\r\n\r\nCopyright (c) 2016-2019 luz-alphacode\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n*/\r\n\r\nif(typeof paper==='undefined'){\r\n    console.error('paper-offset.mjs requires paper.js to have been loaded')\r\n}\r\n\r\n/**\r\n * Offset the start/terminal segment of a bezier curve\r\n * @param segment segment to offset\r\n * @param curve curve to offset\r\n * @param handleNormal the normal of the the line formed of two handles\r\n * @param offset offset value\r\n */\r\nfunction offsetSegment(segment, curve, handleNormal, offset) {\r\n    var isFirst = segment.curve === curve;\r\n    // get offset vector\r\n    var offsetVector = (curve.getNormalAtTime(isFirst ? 0 : 1)).multiply(offset);\r\n    // get offset point\r\n    var point = segment.point.add(offsetVector);\r\n    var newSegment = new paper.Segment(point);\r\n    // handleOut for start segment & handleIn for terminal segment\r\n    var handle = (isFirst ? 'handleOut' : 'handleIn');\r\n    newSegment[handle] = segment[handle].add(handleNormal.subtract(offsetVector).divide(2));\r\n    return newSegment;\r\n}\r\n/**\r\n * Adaptive offset a curve by repeatly apply the approximation proposed by Tiller and Hanson.\r\n * @param curve curve to offset\r\n * @param offset offset value\r\n */\r\nfunction adaptiveOffsetCurve(curve, offset) {\r\n    var hNormal = (new paper.Curve(curve.segment1.handleOut.add(curve.segment1.point), new paper.Point(0, 0), new paper.Point(0, 0), curve.segment2.handleIn.add(curve.segment2.point))).getNormalAtTime(0.5).multiply(offset);\r\n    var segment1 = offsetSegment(curve.segment1, curve, hNormal, offset);\r\n    var segment2 = offsetSegment(curve.segment2, curve, hNormal, offset);\r\n    // divide && re-offset\r\n    var offsetCurve = new paper.Curve(segment1, segment2);\r\n    // if the offset curve is not self intersected, divide it\r\n    if (offsetCurve.getIntersections(offsetCurve).length === 0) {\r\n        var threshold = Math.min(Math.abs(offset) / 10, 1);\r\n        var midOffset = offsetCurve.getPointAtTime(0.5).getDistance(curve.getPointAtTime(0.5));\r\n        if (Math.abs(midOffset - Math.abs(offset)) > threshold) {\r\n            var subCurve = curve.divideAtTime(0.5);\r\n            if (subCurve != null) {\r\n                return adaptiveOffsetCurve(curve, offset).concat(adaptiveOffsetCurve(subCurve, offset));\r\n            }\r\n        }\r\n    }\r\n    return [segment1, segment2];\r\n}\r\n/**\r\n * Create a round join segment between two adjacent segments.\r\n */\r\nfunction makeRoundJoin(segment1, segment2, originPoint, radius) {\r\n    var through = segment1.point.subtract(originPoint).add(segment2.point.subtract(originPoint))\r\n        .normalize(Math.abs(radius)).add(originPoint);\r\n    var arc = new paper.Path.Arc({ from: segment1.point, to: segment2.point, through: through, insert: false });\r\n    segment1.handleOut = arc.firstSegment.handleOut;\r\n    segment2.handleIn = arc.lastSegment.handleIn;\r\n    return arc.segments.length === 3 ? arc.segments[1] : null;\r\n}\r\nfunction det(p1, p2) {\r\n    return p1.x * p2.y - p1.y * p2.x;\r\n}\r\n/**\r\n * Get the intersection point of point based lines\r\n */\r\nfunction getPointLineIntersections(p1, p2, p3, p4) {\r\n    var l1 = p1.subtract(p2);\r\n    var l2 = p3.subtract(p4);\r\n    var dl1 = det(p1, p2);\r\n    var dl2 = det(p3, p4);\r\n    return new paper.Point(dl1 * l2.x - l1.x * dl2, dl1 * l2.y - l1.y * dl2).divide(det(l1, l2));\r\n}\r\n/**\r\n * Connect two adjacent bezier curve, each curve is represented by two segments,\r\n * create different types of joins or simply removal redundant segment.\r\n */\r\nfunction connectAdjacentBezier(segments1, segments2, origin, joinType, offset, limit) {\r\n    var curve1 = new paper.Curve(segments1[0], segments1[1]);\r\n    var curve2 = new paper.Curve(segments2[0], segments2[1]);\r\n    var intersection = curve1.getIntersections(curve2);\r\n    var distance = segments1[1].point.getDistance(segments2[0].point);\r\n    if (origin.isSmooth()) {\r\n        segments2[0].handleOut = segments2[0].handleOut.project(origin.handleOut);\r\n        segments2[0].handleIn = segments1[1].handleIn.project(origin.handleIn);\r\n        segments2[0].point = segments1[1].point.add(segments2[0].point).divide(2);\r\n        segments1.pop();\r\n    }\r\n    else {\r\n        if (intersection.length === 0) {\r\n            if (distance > Math.abs(offset) * 0.1) {\r\n                // connect\r\n                switch (joinType) {\r\n                    case 'miter':\r\n                        var join = getPointLineIntersections(curve1.point2, curve1.point2.add(curve1.getTangentAtTime(1)), curve2.point1, curve2.point1.add(curve2.getTangentAtTime(0)));\r\n                        // prevent sharp angle\r\n                        var joinOffset = Math.max(join.getDistance(curve1.point2), join.getDistance(curve2.point1));\r\n                        if (joinOffset < Math.abs(offset) * limit) {\r\n                            segments1.push(new paper.Segment(join));\r\n                        }\r\n                        break;\r\n                    case 'round':\r\n                        var mid = makeRoundJoin(segments1[1], segments2[0], origin.point, offset);\r\n                        if (mid) {\r\n                            segments1.push(mid);\r\n                        }\r\n                        break;\r\n                }\r\n            }\r\n            else {\r\n                segments2[0].handleIn = segments1[1].handleIn;\r\n                segments1.pop();\r\n            }\r\n        }\r\n        else {\r\n            var second1 = curve1.divideAt(intersection[0]);\r\n            if (second1) {\r\n                var join = second1.segment1;\r\n                var second2 = curve2.divideAt(curve2.getIntersections(curve1)[0]);\r\n                join.handleOut = second2 ? second2.segment1.handleOut : segments2[0].handleOut;\r\n                segments1.pop();\r\n                segments2[0] = join;\r\n            }\r\n            else {\r\n                segments2[0].handleIn = segments1[1].handleIn;\r\n                segments1.pop();\r\n            }\r\n        }\r\n    }\r\n}\r\n/**\r\n * Connect all the segments together.\r\n */\r\nfunction connectBeziers(rawSegments, join, source, offset, limit) {\r\n    var originSegments = source.segments;\r\n    if(rawSegments.length==0) return source.segments;\r\n    var first = rawSegments[0].slice();\r\n    for (var i = 0; i < rawSegments.length - 1; ++i) {\r\n        connectAdjacentBezier(rawSegments[i], rawSegments[i + 1], originSegments[i + 1], join, offset, limit);\r\n    }\r\n    if (source.closed) {\r\n        connectAdjacentBezier(rawSegments[rawSegments.length - 1], first, originSegments[0], join, offset, limit);\r\n        rawSegments[0][0] = first[0];\r\n    }\r\n    return rawSegments;\r\n}\r\nfunction reduceSingleChildCompoundPath(path) {\r\n    if (path.children.length === 1) {\r\n        path = path.children[0];\r\n        path.remove(); // remove from parent, this is critical, or the style attributes will be ignored\r\n    }\r\n    return path;\r\n}\r\n/** Normalize a path, always clockwise, non-self-intersection, ignore really small components, and no one-component compound path. */\r\nfunction normalize(path, areaThreshold) {\r\n    if (areaThreshold === void 0) { areaThreshold = 0.01; }\r\n    if (path.closed) {\r\n        var ignoreArea_1 = Math.abs(path.area * areaThreshold);\r\n        if (!path.clockwise) {\r\n            path.reverse();\r\n        }\r\n        path = path.unite(path, { insert: false });\r\n        if (path instanceof paper.CompoundPath) {\r\n            path.children.filter(function (c) { return Math.abs(c.area) < ignoreArea_1; }).forEach(function (c) { return c.remove(); });\r\n            if (path.children.length === 1) {\r\n                return reduceSingleChildCompoundPath(path);\r\n            }\r\n        }\r\n    }\r\n    return path;\r\n}\r\nfunction isSameDirection(partialPath, fullPath) {\r\n    var offset1 = partialPath.segments[0].location.offset;\r\n    var offset2 = partialPath.segments[Math.max(1, Math.floor(partialPath.segments.length / 2))].location.offset;\r\n    var sampleOffset = (offset1 + offset2) / 3;\r\n    var originOffset1 = fullPath.getNearestLocation(partialPath.getPointAt(sampleOffset)).offset;\r\n    var originOffset2 = fullPath.getNearestLocation(partialPath.getPointAt(2 * sampleOffset)).offset;\r\n    return originOffset1 < originOffset2;\r\n}\r\n/** Remove self intersection when offset is negative by point direction dectection. */\r\nfunction removeIntersection(path) {\r\n    if (path.closed) {\r\n        var newPath = path.unite(path, { insert: false });\r\n        if (newPath instanceof paper.CompoundPath) {\r\n            newPath.children.filter(function (c) {\r\n                if (c.segments.length > 1) {\r\n                    return !isSameDirection(c, path);\r\n                }\r\n                else {\r\n                    return true;\r\n                }\r\n            }).forEach(function (c) { return c.remove(); });\r\n            return reduceSingleChildCompoundPath(newPath);\r\n        }\r\n    }\r\n    return path;\r\n}\r\nfunction getSegments(path) {\r\n    if (path instanceof paper.CompoundPath) {\r\n        return path.children.map(function (c) { return c.segments; }).flat();\r\n    }\r\n    else {\r\n        return path.segments;\r\n    }\r\n}\r\n/**\r\n * Remove impossible segments in negative offset condition.\r\n */\r\nfunction removeOutsiders(newPath, path) {\r\n    var segments = getSegments(newPath).slice();\r\n    segments.forEach(function (segment) {\r\n        if (!path.contains(segment.point)) {\r\n            segment.remove();\r\n        }\r\n    });\r\n}\r\nfunction preparePath(path, offset) {\r\n    var source = path.clone({ insert: false });\r\n    source.reduce({});\r\n    if (!path.clockwise) {\r\n        source.reverse();\r\n        offset = -offset;\r\n    }\r\n    return [source, offset];\r\n}\r\nfunction offsetSimpleShape(path, offset, join, limit) {\r\n    var _a;\r\n    var source;\r\n    _a = preparePath(path, offset), source = _a[0], offset = _a[1];\r\n    var curves = source.curves.slice();\r\n    var offsetCurves = curves.map(function (curve) { return adaptiveOffsetCurve(curve, offset); }).flat();\r\n    var raws = [];\r\n    for (var i = 0; i < offsetCurves.length; i += 2) {\r\n        raws.push(offsetCurves.slice(i, i + 2));\r\n    }\r\n    var segments = connectBeziers(raws, join, source, offset, limit).flat();\r\n    var newPath = removeIntersection(new paper.Path({ segments: segments, insert: false, closed: path.closed }));\r\n    newPath.reduce({});\r\n    if (source.closed && ((source.clockwise && offset < 0) || (!source.clockwise && offset > 0))) {\r\n        removeOutsiders(newPath, path);\r\n    }\r\n    // recovery path\r\n    if (source.clockwise !== path.clockwise) {\r\n        newPath.reverse();\r\n    }\r\n    return normalize(newPath);\r\n}\r\nfunction makeRoundCap(from, to, offset) {\r\n    var origin = from.point.add(to.point).divide(2);\r\n    var normal = to.point.subtract(from.point).rotate(-90, new paper.Point(0, 0)).normalize(offset);\r\n    var through = origin.add(normal);\r\n    var arc = new paper.Path.Arc({ from: from.point, to: to.point, through: through, insert: false });\r\n    return arc.segments;\r\n}\r\nfunction connectSide(outer, inner, offset, cap) {\r\n    if (outer instanceof paper.CompoundPath) {\r\n        var cs = outer.children.map(function (c) { return ({ c: c, a: Math.abs(c.area) }); });\r\n        cs = cs.sort(function (c1, c2) { return c2.a - c1.a; });\r\n        outer = cs[0].c;\r\n    }\r\n    var oSegments = outer.segments.slice();\r\n    var iSegments = inner.segments.slice();\r\n    switch (cap) {\r\n        case 'round':\r\n            var heads = makeRoundCap(iSegments[iSegments.length - 1], oSegments[0], offset);\r\n            var tails = makeRoundCap(oSegments[oSegments.length - 1], iSegments[0], offset);\r\n            var result = new paper.Path({ segments: heads.concat(oSegments, tails, iSegments), closed: true, insert: false });\r\n            result.reduce({});\r\n            return result;\r\n        default: return new paper.Path({ segments: oSegments.concat(iSegments), closed: true, insert: false });\r\n    }\r\n}\r\nfunction offsetSimpleStroke(path, offset, join, cap, limit) {\r\n    offset = path.clockwise ? offset : -offset;\r\n    var positiveOffset = offsetSimpleShape(path, offset, join, limit);\r\n    var negativeOffset = offsetSimpleShape(path, -offset, join, limit);\r\n    if (path.closed) {\r\n        return positiveOffset.subtract(negativeOffset, { insert: false });\r\n    }\r\n    else {\r\n        var inner = negativeOffset;\r\n        var holes = new Array();\r\n        if (negativeOffset instanceof paper.CompoundPath) {\r\n            holes = negativeOffset.children.filter(function (c) { return c.closed; });\r\n            holes.forEach(function (h) { return h.remove(); });\r\n            inner = negativeOffset.children[0];\r\n        }\r\n        inner.reverse();\r\n        var final = connectSide(positiveOffset, inner, offset, cap);\r\n        if (holes.length > 0) {\r\n            for (var _i = 0, holes_1 = holes; _i < holes_1.length; _i++) {\r\n                var hole = holes_1[_i];\r\n                final = final.subtract(hole, { insert: false });\r\n            }\r\n        }\r\n        return final;\r\n    }\r\n}\r\nfunction getNonSelfItersectionPath(path) {\r\n    if (path.closed) {\r\n        return path.unite(path, { insert: false });\r\n    }\r\n    return path;\r\n}\r\nfunction offsetPath(path, offset, join, limit) {\r\n    var nonSIPath = getNonSelfItersectionPath(path);\r\n    var result = nonSIPath;\r\n    if (nonSIPath instanceof paper.Path) {\r\n        result = offsetSimpleShape(nonSIPath, offset, join, limit);\r\n    }\r\n    else {\r\n        var offsetParts = nonSIPath.children.map(function (c) {\r\n            if (c.segments.length > 1) {\r\n                if (!isSameDirection(c, path)) {\r\n                    c.reverse();\r\n                }\r\n                var offseted = offsetSimpleShape(c, offset, join, limit);\r\n                offseted = normalize(offseted);\r\n                if (offseted.clockwise !== c.clockwise) {\r\n                    offseted.reverse();\r\n                }\r\n                if (offseted instanceof paper.CompoundPath) {\r\n                    offseted.applyMatrix = true;\r\n                    return offseted.children;\r\n                }\r\n                else {\r\n                    return offseted;\r\n                }\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        });\r\n        var children = offsetParts.flat().filter(function (c) { return !!c; });\r\n        result = new paper.CompoundPath({ children: children, insert: false });\r\n    }\r\n    result.copyAttributes(nonSIPath, false);\r\n    result.remove();\r\n    return result;\r\n}\r\nfunction offsetStroke(path, offset, join, cap, limit) {\r\n    var nonSIPath = getNonSelfItersectionPath(path);\r\n    var result = nonSIPath;\r\n    if (nonSIPath instanceof paper.Path) {\r\n        result = offsetSimpleStroke(nonSIPath, offset, join, cap, limit);\r\n    }\r\n    else {\r\n        var children = nonSIPath.children.flatMap(function (c) {\r\n            return offsetSimpleStroke(c, offset, join, cap, limit);\r\n        });\r\n        result = children.reduce(function (c1, c2) { return c1.unite(c2, { insert: false }); });\r\n    }\r\n    result.strokeWidth = 0;\r\n    result.fillColor = nonSIPath.strokeColor;\r\n    result.shadowBlur = nonSIPath.shadowBlur;\r\n    result.shadowColor = nonSIPath.shadowColor;\r\n    result.shadowOffset = nonSIPath.shadowOffset;\r\n    return result;\r\n}\r\n// TO DO: does this need to be modified to work with multiple paperScopes?\r\nvar PaperOffset = /** @class */ (function () {\r\n    function PaperOffset() {\r\n    }\r\n    PaperOffset.offset = function (path, offset, options) {\r\n        options = options || {};\r\n        var newPath = offsetPath(path, offset, options.join || 'miter', options.limit || 10);\r\n        if (options.insert === undefined) {\r\n            options.insert = true;\r\n        }\r\n        if (options.insert) {\r\n            (path.parent || paper.project.activeLayer).addChild(newPath);\r\n        }\r\n        return newPath;\r\n    };\r\n    PaperOffset.offsetStroke = function (path, offset, options) {\r\n        options = options || {};\r\n        var newPath = offsetStroke(path, offset, options.join || 'miter', options.cap || 'butt', options.limit || 10);\r\n        if (options.insert === undefined) {\r\n            options.insert = true;\r\n        }\r\n        if (options.insert) {\r\n            (path.parent || paper.project.activeLayer).addChild(newPath);\r\n        }\r\n        return newPath;\r\n    };\r\n    return PaperOffset;\r\n}());\r\n\r\n\r\n  \n\n//# sourceURL=webpack://js/../src/js/paper-offset.mjs?")},"../src/js/paper-overlay.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PaperOverlay: () => (/* binding */ PaperOverlay)\n/* harmony export */ });\n/**\r\n * OpenSeadragon canvas Overlay plugin based on paper.js\r\n * @version 0.1.2\r\n * \r\n * Includes additional open source libraries which are subject to copyright notices\r\n * as indicated accompanying those segments of code.\r\n * \r\n * Original code:\r\n * Copyright (c) 2022, Thomas Pearce\r\n * All rights reserved.\r\n * \r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n * \r\n * * Redistributions of source code must retain the above copyright notice, this\r\n *   list of conditions and the following disclaimer.\r\n * \r\n * * Redistributions in binary form must reproduce the above copyright notice,\r\n *   this list of conditions and the following disclaimer in the documentation\r\n *   and/or other materials provided with the distribution.\r\n * \r\n * * Neither the name of paper-overlay nor the names of its\r\n *   contributors may be used to endorse or promote products derived from\r\n *   this software without specific prior written permission.\r\n * \r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\r\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\r\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n * \r\n */\r\n\r\n(function (OpenSeadragon) {\r\n\r\n    if (typeof OpenSeadragon === 'undefined') {\r\n        console.error('[paper-overlay.mjs] requires OpenSeadragon and paper.js');\r\n        return;\r\n    }\r\n    if (typeof paper==='undefined') {\r\n        console.error('[paper-overlay.mjs] requires OpenSeadragon and paper.js');\r\n        return;\r\n    }\r\n\r\n    \r\n    Object.defineProperty(OpenSeadragon.Viewer.prototype, 'PaperOverlays',{\r\n        get: function PaperOverlays(){\r\n            return this._PaperOverlays || (this._PaperOverlays = []);\r\n        }\r\n    });\r\n    /**\r\n     * Gets the image data from the viewer.\r\n     *\r\n     * @param {number} x - The x coordinate of the top left corner of the image data.\r\n     * @param {number} y - The y coordinate of the top left corner of the image data.\r\n     * @param {number} w - The width of the image data.\r\n     * @param {number} h - The height of the image data.\r\n     * @returns {ImageData} The image data.\r\n     */\r\n    OpenSeadragon.Viewer.prototype.getImageData = function(x, y, w, h){\r\n        x = x || 0;\r\n        y = y || 0;\r\n        w = w == undefined ? this.drawer.canvas.width : w;\r\n        h = h == undefined ? this.drawer.canvas.height : h;\r\n        return this.drawer.canvas.getContext('2d',{willReadFrequently:true}).getImageData(x, y, w, h);\r\n    }\r\n\r\n    /**\r\n     * Gets a raster object representing the viewport.\r\n     *\r\n     * @param {any} view - The view object.\r\n     * @param {boolean} withImageData - Whether to include image data in the raster object.\r\n     * @returns {any} The raster object.\r\n     */\r\n    OpenSeadragon.Viewer.prototype.getViewportRaster = function(view, withImageData = true){\r\n        //TO DO: make this query subregions of the viewport directly instead of always returning the entire thing\r\n        // let view = this.paperjsOverlay && this.paperjsOverlay.paperScope.view;\r\n        // if(!view){\r\n        //     console.error('Cannot call getViewportRaster before an overlay has been created');\r\n        //     return;\r\n        // }\r\n        let center = view.viewToProject(new paper.Point(view.viewSize.width/2, view.viewSize.height/2 ));\r\n        let rotation = -1 * this.viewport.getRotation();\r\n        let rasterDef = {\r\n            insert:false,\r\n        }\r\n        if(withImageData) rasterDef.canvas = this.drawer.canvas;\r\n        else rasterDef.size = new paper.Size(this.drawer.canvas.width,this.drawer.canvas.height);\r\n        let raster = new paper.Raster(rasterDef);\r\n\r\n        raster.position = center;\r\n        raster.rotate(rotation);\r\n        let scaleFactor = view.viewSize.width / view.getZoom() / this.drawer.canvas.width;\r\n        raster.scale(scaleFactor);\r\n       \r\n        return raster;\r\n    }\r\n    /**\r\n     * Sets the rotation of the view.\r\n     *\r\n     * @param {number} degrees - The number of degrees to rotate.\r\n     * @param {any} center - The center point of the rotation.\r\n     */\r\n    paper.View.prototype.setRotation = function(degrees, center){\r\n        let degreesToRotate = degrees - (this._rotation || 0)\r\n        this.rotate(degreesToRotate, center);\r\n        this._rotation = OpenSeadragon.positiveModulo(degrees, 360);\r\n        this.emit('rotate',{rotatedBy:degreesToRotate, currentRotation:this._rotation, center:center});\r\n    }\r\n\r\n    //Add applyRescale as a method to paper objects\r\n    paper.Item.prototype.applyRescale = function(){\r\n        let item = this;\r\n        let z = 1;\r\n        let rescale = item.rescale;\r\n        rescale && (z = item.view.getZoom()) && Object.keys(rescale).forEach(function(prop){\r\n            item[prop] = (typeof rescale[prop] ==='function') ? rescale[prop](z) : \r\n                        Array.isArray(rescale[prop]) ? rescale[prop].map(function(i){return i/z}) : \r\n                        rescale[prop]/z;\r\n        })\r\n    }\r\n\r\n})(window.OpenSeadragon);\r\n\r\nclass PaperOverlay{\r\n    \r\n    \r\n    /**\r\n     * Creates an instance of the PaperOverlay.\r\n     * overlayType: 'image' to sync to the zoomable image, 'viewport' to stay fixed to the viewer\r\n     * @param {any} viewer - The viewer object.\r\n     * @param {Object} opts - The options for the overlay.\r\n     */\r\n    constructor(viewer,opts={overlayType:'image'}){\r\n        let defaultOpts = {\r\n            overlayType: 'image',\r\n        }\r\n        opts=OpenSeadragon.extend(true,defaultOpts,opts);\r\n\r\n        this._scale = opts.overlayType=='image' ? getViewerContentWidth(viewer) : 1;\r\n\r\n        this.osdViewer = viewer;\r\n        \r\n        viewer.PaperOverlays.push(this);\r\n        \r\n        let ctr = counter();\r\n        this._id = 'paper-overlay-canvas-' + ctr;\r\n\r\n        this._containerWidth = 0;\r\n        this._containerHeight = 0;\r\n\r\n        this._canvasdiv = document.createElement('div');\r\n        this._canvasdiv.setAttribute('id','paper-overlay-'+ctr);\r\n        this._canvasdiv.classList.add('paper-overlay');\r\n        this._canvasdiv.style.position = 'absolute';\r\n        this._canvasdiv.style.left = \"0px\";\r\n        this._canvasdiv.style.top = \"0px\";\r\n        this._canvasdiv.style.width = '100%';\r\n        this._canvasdiv.style.height = '100%';\r\n\r\n        this._canvas = document.createElement('canvas');\r\n        this._canvas.setAttribute('id', this._id);\r\n        this._canvasdiv.appendChild(this._canvas);\r\n        \r\n        viewer.canvas.appendChild(this._canvasdiv);\r\n        \r\n        \r\n        this.paperScope = new paper.PaperScope();\r\n        \r\n        \r\n        this.paperScope.overlay = this;\r\n        let ps = this.paperScope.setup(this._canvas);\r\n        this.paperScope.project.overlay = this;\r\n        this.ps = ps;\r\n        this._paperProject=ps.project;\r\n\r\n        this._resize();\r\n        \r\n        if(opts.overlayType=='image'){\r\n            this._updatePaperView();\r\n        } \r\n\r\n        \r\n        \r\n        this.onViewerDestroy=(self=>function(){\r\n            self.destroy(true);\r\n        })(this);\r\n        this.onViewportChange=(self=>function(){\r\n            self._updatePaperView();\r\n        })(this);\r\n        this.onViewerResetSize=(self=>function(ev){\r\n            self._scale = getViewerContentWidth(ev);\r\n            //need to setTimeout to wait for some value (viewport.getZoom()?) to actually be updated before doing our update\r\n            //need to check for destroyed because this will get called as part of the viewer destroy chain, and we've set the timeout\r\n            setTimeout(()=>{\r\n                if(self.destroyed){\r\n                    return;\r\n                }\r\n                self._resize();\r\n                if(opts.overlayType=='image'){\r\n                    self._updatePaperView(true);\r\n                }\r\n            });\r\n        })(this);\r\n        this.onViewerResize=(self=>function(){\r\n            self._resize();\r\n            self.paperScope.view.emit('resize',{size:new paper.Size(self._containerWidth, self._containerHeight)})\r\n            if(opts.overlayType=='image'){\r\n                self._updatePaperView();\r\n            } \r\n        })(this);\r\n        this.onViewerRotate=(self=>function(ev){\r\n            let pivot = ev.pivot || self.osdViewer.viewport.viewportToImageCoordinates(self.osdViewer.viewport.getCenter());\r\n            self.paperScope.view.setRotation(ev.degrees, pivot)\r\n        })(this);\r\n\r\n        viewer.addHandler('resize',this.onViewerResize);\r\n        viewer.addHandler('reset-size',this.onViewerResetSize)\r\n        if(opts.overlayType=='image'){\r\n            viewer.addHandler('viewport-change', this.onViewportChange)\r\n            viewer.addHandler('rotate',this.onViewerRotate)\r\n        }\r\n        viewer.addOnceHandler('destroy', this.onViewerDestroy)\r\n          \r\n    }\r\n    /**\r\n     * Adds a button to the viewer.\r\n     *\r\n     * @param {Object} params - The parameters for the button.\r\n     * @returns {any} The button object.\r\n     */    \r\n    addViewerButton(params={}){\r\n        const prefixUrl=this.osdViewer.prefixUrl;\r\n        let button = new OpenSeadragon.Button({\r\n            tooltip: params.tooltip,\r\n            srcRest: prefixUrl+`button_rest.png`,\r\n            srcGroup: prefixUrl+`button_grouphover.png`,\r\n            srcHover: prefixUrl+`button_hover.png`,\r\n            srcDown: prefixUrl+`button_pressed.png`,\r\n            onClick: params.onClick,\r\n        });\r\n        if(params.faIconClasses){\r\n            let i = document.createElement('i');\r\n            i.classList.add(...params.faIconClasses.split(/\\s/), 'button-icon-fa');\r\n            button.element.appendChild(i);\r\n            // $(button.element).append($('<i>', {class:params.faIconClasses + ' button-icon-fa'}));\r\n        }\r\n        this.osdViewer.buttonGroup.buttons.push(button);\r\n        this.osdViewer.buttonGroup.element.appendChild(button.element);\r\n        return button;\r\n    }\r\n    /**\r\n     * Brings the overlay to the front.\r\n     */\r\n    bringToFront(){\r\n        this.osdViewer.PaperOverlays.splice(this.osdViewer.PaperOverlays.indexOf(this),1);\r\n        this.osdViewer.PaperOverlays.push(this);\r\n        this.osdViewer.PaperOverlays.forEach(overlay=>this.osdViewer.canvas.appendChild(overlay._canvasdiv));\r\n        this.paperScope.activate();\r\n    }\r\n    /**\r\n     * Sends the overlay to the back.\r\n     */\r\n    sendToBack(){\r\n        this.osdViewer.PaperOverlays.splice(this.osdViewer.PaperOverlays.indexOf(this),1);\r\n        this.osdViewer.PaperOverlays.splice(0,0,this);\r\n        this.osdViewer.PaperOverlays.forEach(overlay=>this.osdViewer.canvas.appendChild(overlay._canvasdiv));\r\n        this.osdViewer.PaperOverlays[this.osdViewer.PaperOverlays.length-1].paperScope.activate();\r\n    }\r\n    /**\r\n     * Destroys the overlay.\r\n     *\r\n     * @param {boolean} viewerDestroyed - Whether the viewer has been destroyed.\r\n     */    \r\n    destroy(viewerDestroyed){\r\n        this.destroyed = true;\r\n        this._canvasdiv.remove();\r\n        this.paperScope.project.remove();\r\n        this._canvasdiv.remove();\r\n        this.ps.remove();  \r\n        if(!viewerDestroyed){\r\n            this.osdViewer.removeHandler('viewport-change',this.onViewportChange);\r\n            this.osdViewer.removeHandler('resize',this.onViewerResize);\r\n            this.osdViewer.removeHandler('close',this.onViewerDestroy);\r\n            this.osdViewer.removeHandler('reset-size',this.onViewerResetSize);\r\n            this.osdViewer.removeHandler('rotate',this.onViewerRotate);\r\n            this.setOSDMouseNavEnabled(true);\r\n\r\n            this.osdViewer.PaperOverlays.splice(this.osdViewer.PaperOverlays.indexOf(this),1);\r\n            if(this.osdViewer.PaperOverlays.length>0){\r\n                this.osdViewer.PaperOverlays[this.osdViewer.PaperOverlays.length-1].paperScope.activate();\r\n            }\r\n        }\r\n         \r\n    }\r\n    /**\r\n     * Clears the overlay.\r\n     */    \r\n    clear(){\r\n        this.paperScope.project.clear();\r\n    }\r\n    // ----------\r\n    /**\r\n     * Gets the canvas element of the overlay.\r\n     *\r\n     * @returns {HTMLCanvasElement} The canvas element.\r\n     */\r\n    canvas() {\r\n        return this._canvas;\r\n    }\r\n    // ----------\r\n    /**\r\n     * Adds a class to the canvas element.\r\n     *\r\n     * @param {string} c - The class to add.\r\n     * @returns {PaperOverlay} The PaperOverlay object.\r\n     */\r\n    addClass(c){\r\n        this._canvas.classList.add(...arguments);\r\n        return this;\r\n    }\r\n    /**\r\n     * Removes a class from the canvas element.\r\n     *\r\n     * @param {string} c - The class to remove.\r\n     * @returns {PaperOverlay} The PaperOverlay object.\r\n     */\r\n    removeClass(c){\r\n        this._canvas.classList.remove(...arguments);\r\n        return this;\r\n    }\r\n    /**\r\n     * Sets an attribute of the canvas element.\r\n     *\r\n     * @param {string} attr - The attribute to set.\r\n     * @param {string} value - The value to set the attribute to.\r\n     * @returns {PaperOverlay} The PaperOverlay object.\r\n     */\r\n    setAttribute(attr, value){\r\n        this._canvas.setAttribute(attr,value);\r\n        return this;\r\n    }\r\n    /**\r\n     * Adds an event listener to the canvas element.\r\n     *\r\n     * @param {string} event - The event to listen for.\r\n     * @param {function} listener - The function to call when the event is triggered.\r\n     * @returns {PaperOverlay} The PaperOverlay object.\r\n     */\r\n    addEventListener(event,listener){\r\n        this._canvas.addEventListener(event,listener);\r\n        return this;\r\n    }\r\n    /**\r\n     * Removes an event listener from the canvas element.\r\n     *\r\n     * @param {string} event - The event to stop listening for.\r\n     * @param {function} listener - The function that was called when the event was triggered.\r\n     * @returns {PaperOverlay} The PaperOverlay object.\r\n     */    \r\n    removeEventListener(event,listener){\r\n        this._canvas.removeEventListener(event,listener);\r\n        return this;\r\n    }\r\n    // returns: mouseNavEnabled status BEFORE the call (for reverting)\r\n    // raises 'mouse-nav-enabled' event\r\n    /**\r\n     * Sets whether mouse navigation is enabled in the viewer.\r\n     *\r\n     * @param {boolean} enabled - Whether to enable mouse navigation.\r\n     * @returns {boolean} Whether mouse navigation was enabled before the call.\r\n     */\r\n    setOSDMouseNavEnabled(enabled=true){\r\n        let wasMouseNavEnabled = this.osdViewer.isMouseNavEnabled();\r\n        this.osdViewer.setMouseNavEnabled(enabled);\r\n        if(enabled !== wasMouseNavEnabled){\r\n            this.osdViewer.raiseEvent('mouse-nav-changed',{enabled: enabled, overlay: this});\r\n        }\r\n        return wasMouseNavEnabled;\r\n    }\r\n    // ----------\r\n    /**\r\n     * Enables or disables automatic rescaling of items.\r\n     *\r\n     * @param {boolean} shouldHandle - Whether to enable automatic rescaling.\r\n     */\r\n    autoRescaleItems(shouldHandle=false){\r\n        let _this=this;\r\n        this.ps.view.off('zoom-changed',_rescale);\r\n        if(shouldHandle) this.ps.view.on('zoom-changed',_rescale );\r\n        \r\n        function _rescale(){\r\n            _this.rescaleItems();\r\n        }\r\n    }\r\n    //-----------\r\n    /**\r\n     * Rescales all items in the overlay.\r\n     */\r\n    rescaleItems(){\r\n        this._paperProject.getItems({match:function(o){return o.rescale}}).forEach(function(item){\r\n            item.applyRescale();\r\n        });\r\n    }\r\n    //------------\r\n    /**\r\n     * Resizes the overlay.\r\n     */\r\n    _resize()\r\n     {\r\n        let update=false;\r\n        if (this._containerWidth !== this.osdViewer.container.clientWidth) {\r\n            this._containerWidth = this.osdViewer.container.clientWidth;\r\n            this._canvasdiv.setAttribute('width', this._containerWidth);\r\n            this._canvas.setAttribute('width', this._containerWidth);\r\n            update=true;\r\n        }\r\n\r\n        if (this._containerHeight !== this.osdViewer.container.clientHeight) {\r\n            this._containerHeight = this.osdViewer.container.clientHeight;\r\n            this._canvasdiv.setAttribute('height', this._containerHeight);\r\n            this._canvas.setAttribute('height', this._containerHeight);\r\n            update=true;\r\n        }\r\n        if(update){\r\n            this.paperScope.view.viewSize = new paper.Size(this._containerWidth, this._containerHeight);\r\n            this.paperScope.view.update();\r\n        }\r\n    }\r\n    /**\r\n     * Updates the paper view.\r\n     */\r\n    _updatePaperView() {\r\n        let viewportZoom = this.osdViewer.viewport.getZoom(true);\r\n        let oldZoom = this.paperScope.view.zoom;\r\n        this.paperScope.view.zoom = this.osdViewer.viewport._containerInnerSize.x * viewportZoom / this._scale;\r\n        let center = this.osdViewer.viewport.viewportToImageCoordinates(this.osdViewer.viewport.getCenter(true));\r\n        this.osdViewer.drawer.canvas.pixelRatio = window.devicePixelRatio;\r\n        this.paperScope.view.center = new paper.Point(center.x, center.y);\r\n        \r\n        if(Math.abs(this.paperScope.view.zoom - oldZoom)>0.0000001){\r\n            this.paperScope.view.emit('zoom-changed',{zoom:this.paperScope.view.zoom});\r\n        }\r\n        this.paperScope.view.update();\r\n    }\r\n\r\n    \r\n};\r\n\r\nlet counter = (function () {\r\n    let i = 1;\r\n\r\n    return function () {\r\n        return i++;\r\n    }\r\n})();\r\n\r\n/**\r\n * Gets the content width of the viewer.\r\n *\r\n * @param {any} input - The viewer object or an event object.\r\n * @returns {number} The content width of the viewer.\r\n */\r\nfunction getViewerContentWidth(input){\r\n    if(input.contentSize){\r\n        return input.contentSize.x;\r\n    }\r\n    let viewer = input.eventSource || input;\r\n    let item = viewer.world.getItemAt(0);\r\n    return item && item.getContentSize().x || 1;\r\n    // let viewer = input.eventSource || input;\r\n    // let item = viewer.world.getItemAt(0);\r\n    // return (item && item.source && item.source.width) || 1;\r\n}\r\n  \n\n//# sourceURL=webpack://js/../src/js/paper-overlay.mjs?")},"../src/js/paperitems/annotationitem.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AnnotationItem: () => (/* binding */ AnnotationItem),\n/* harmony export */   AnnotationItemFactory: () => (/* binding */ AnnotationItemFactory)\n/* harmony export */ });\nclass AnnotationItem{\r\n    constructor(feature){\r\n        if(GeometryTypes.includes( (feature.geometry && feature.geometry.type) || feature.geometry ) === false){\r\n            throw('Bad GeoJSON Geometry type');\r\n        }\r\n        this._paperItem = null;\r\n        this._props = feature.properties;\r\n        this.userdata = Object.assign({}, this._props.userdata);//ensure userdata field exists\r\n    }\r\n    static get supportsType(){\r\n        return {\r\n            type: undefined,\r\n            subtype: undefined,\r\n        }\r\n    }\r\n    getCoordinates(){\r\n        return []\r\n    }\r\n    getProperties(){\r\n        return {}\r\n    }\r\n    getStyleProperties(){\r\n        return this.paperItem.style.toJSON();\r\n    }\r\n    // static getGeometry(){}\r\n    static onTransform(){}\r\n\r\n    get supportsType(){\r\n        return this.constructor.supportsType;\r\n    }\r\n    getLabel(){\r\n        return this.paperItem.displayName || this.constructor.supportsType.subtype || this.constructor.supportsType.type;\r\n    }\r\n\r\n    get type(){\r\n        return this.constructor.supportsType.type;\r\n    }\r\n    get subtype(){\r\n        return this.constructor.supportsType.subtype;\r\n    }\r\n\r\n    get paperItem(){\r\n        return this._paperItem;\r\n    }\r\n    set paperItem(paperItem){\r\n        this._paperItem = paperItem;\r\n        //apply special properties that make the paper.Item an AnnotationItem\r\n        convertPaperItemToAnnotation(this);\r\n    }\r\n\r\n    // default implmentation; can be overridden for custom behavior by subclasses\r\n    setStyle(properties){\r\n        this._paperItem && this._paperItem.style.set(properties);\r\n    }\r\n\r\n    // default implementation; can be overridden for custom behavior by subclasses\r\n    toGeoJSONFeature(){\r\n        let geoJSON = {\r\n            type:'Feature',\r\n            geometry:this.toGeoJSONGeometry(),\r\n            properties:{\r\n                label:this.paperItem.displayName,\r\n                selected:this.paperItem.selected,\r\n                ...this.getStyleProperties(),\r\n                userdata:this.userdata,\r\n            }\r\n        }\r\n\r\n        return geoJSON;\r\n    }\r\n\r\n    // default implementation; can be overridden for custom behavior by subclasses\r\n    toGeoJSONGeometry(){\r\n        let geom = {\r\n            type: this.type,\r\n            properties: this.getProperties(),\r\n            coordinates: this.getCoordinates(),\r\n        }\r\n        if(this.subtype){\r\n            geom.properties = Object.assign(geom.properties, {subtype: this.subtype});\r\n        }\r\n        return geom;\r\n    }\r\n\r\n}\r\n\r\nconst GeometryTypes = ['Point', 'LineString', 'Polygon', 'MultiPoint', 'MultiLineString', 'MultiPolygon', 'GeometryCollection', null];\r\n\r\nconst _constructors = [];\r\n\r\nclass AnnotationItemFactory{\r\n    constructor(){\r\n        // this._constructors=[];\r\n    }\r\n    static register(ctor){\r\n        //to do: add logic to test whether the object has implemented the necessary API\r\n        if(ctor.supportsType === AnnotationItem.supportsType){\r\n            console.error('Static accessor supportsType must be implemented');\r\n            throw('Static accessor supportsType must be implemented');\r\n        }\r\n        if(!_constructors.includes(ctor)){\r\n            _constructors.push(ctor);\r\n        }\r\n    }\r\n    \r\n    static getConstructor(geoJSON){\r\n        if(!('geometry' in geoJSON && 'properties' in geoJSON)){\r\n            console.error('Invalid GeoJSON Feature object. Returning undefined.');\r\n            return;\r\n        }\r\n\r\n        let geometry = geoJSON.geometry;\r\n        let gprops = geometry && geometry.properties || {};\r\n        // let properties = geoJSON.properties;\r\n\r\n        let geomType = geometry && geometry.type || undefined;\r\n        let geomSubtype = gprops.subtype;\r\n\r\n        let constructors = _constructors.filter(c=>c.supportsType.type==geomType && c.supportsType.subtype === geomSubtype);\r\n        \r\n        return constructors.slice(-1)[0]; //return the most recent constructor that supports this type\r\n    }\r\n\r\n    static itemFromGeoJSON(geoJSON){\r\n        if(GeometryTypes.includes(geoJSON.type)){\r\n            geoJSON = {\r\n                type: 'Feature',\r\n                geometry: geoJSON,\r\n                properties: {},\r\n            }\r\n        }\r\n        let ctor = AnnotationItemFactory.getConstructor(geoJSON);\r\n        if(ctor){\r\n            let annotationItem = new ctor(geoJSON);\r\n            return annotationItem.paperItem;\r\n        }\r\n    }\r\n\r\n    static itemFromAnnotationItem(item){\r\n        if(!item.annotationItem){\r\n            error('Only paper.Items constructed by AnnotationItem implementations are supported');\r\n            return;\r\n        }\r\n        let geoJSON = {\r\n            type:'Feature',\r\n            geometry: item.annotationItem.toGeoJSONGeometry(),\r\n            properties:item.annotationItem._props,\r\n        };\r\n        return AnnotationItemFactory.itemFromGeoJSON(geoJSON);\r\n    }\r\n\r\n}\r\n\r\nfunction convertPaperItemToAnnotation(annotationItem){\r\n    let item = annotationItem.paperItem;\r\n    let constructor = annotationItem.constructor;\r\n    let properties = annotationItem._props;\r\n\r\n    item.isGeoJSONFeature = true;\r\n    item.onTransform = constructor.onTransform;\r\n\r\n    //style\r\n    annotationItem.setStyle(properties);\r\n\r\n    //set fillOpacity property based on initial fillColor alpha value\r\n    item.fillOpacity = item.fillColor ? item.fillColor.alpha : 1;\r\n\r\n    //displayName\r\n    item.displayName = properties.label || annotationItem.getLabel();\r\n\r\n    item.annotationItem = annotationItem;\r\n    \r\n    //enhance replaceWith functionatily\r\n    item.replaceWith = enhancedReplaceWith;\r\n\r\n    //selected or not\r\n    if('selected' in properties){\r\n        item.selected = properties.selected;\r\n    }\r\n}\r\n\r\n\r\nfunction enhancedReplaceWith(newItem){\r\n    if(!newItem.isGeoJSONFeature){\r\n        console.warn('An item with isGeoJSONFeature==false was used to replace an item.');\r\n    }\r\n    newItem._callbacks = this._callbacks;\r\n    let rescale = OpenSeadragon.extend(true,this.rescale,newItem.rescale);\r\n    newItem.style = this.style; //to do: make this work with rescale properties, so that rescale.strokeWidth doesn't overwrite other props\r\n    newItem.rescale=rescale;\r\n    //replace in the paper hierarchy\r\n    this.emit('item-replaced',{item:newItem});\r\n    newItem.project.emit('item-replaced',{item:newItem});\r\n    paper.Item.prototype.replaceWith.call(this, newItem);\r\n    newItem.selected = this.selected;\r\n    newItem.updateFillOpacity();\r\n    newItem.applyRescale();\r\n    newItem.project.view.update();\r\n    return newItem;\r\n}\n\n//# sourceURL=webpack://js/../src/js/paperitems/annotationitem.mjs?")},"../src/js/paperitems/ellipse.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Ellipse: () => (/* binding */ Ellipse)\n/* harmony export */ });\n/* harmony import */ var _annotationitem_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./annotationitem.mjs */ \"../src/js/paperitems/annotationitem.mjs\");\n\r\n\r\nclass Ellipse extends _annotationitem_mjs__WEBPACK_IMPORTED_MODULE_0__.AnnotationItem{\r\n    constructor(geoJSON){\r\n        super(geoJSON);\r\n\r\n        if (geoJSON.geometry.type !== 'Point' || geoJSON.geometry.properties.subtype !== 'Ellipse') {\r\n            error('Bad geoJSON object: type !==\"Point\" or subtype !==\"Rectangle\"');\r\n        }\r\n        \r\n\r\n        let poly = new paper.CompoundPath({\r\n            children: [],\r\n            fillRule: 'evenodd',\r\n        });\r\n\r\n        if(geoJSON.geometry.coordinates.length > 1){\r\n            let center = geoJSON.geometry.coordinates.slice(0, 2);\r\n            let x = center[0] || 0;\r\n            let y = center[1] || 0;\r\n            let props = geoJSON.geometry.properties;\r\n            let a = props.majorRadius || 0;\r\n            let b = props.minorRadius || 0;\r\n            let degrees = props.angle || 0;\r\n            \r\n            let ellipse = new paper.Path.Ellipse({\r\n                center: new paper.Point(x, y),\r\n                radius: new paper.Size(a, b)\r\n            })\r\n            poly.addChild(ellipse);\r\n            poly.rotate(degrees);\r\n            \r\n        }\r\n        \r\n        \r\n        poly.canBeBoundingElement = true;\r\n\r\n        this.paperItem = poly;\r\n    }\r\n    static get supportsType(){\r\n        return {\r\n            type: 'Point',\r\n            subtype: 'Ellipse'\r\n        }\r\n    }\r\n    getCoordinates(){\r\n        let item = this.paperItem;\r\n        return [item.position.x, item.position.y];\r\n    }\r\n    getProperties(){\r\n        let item = this.paperItem;\r\n        let path = item.children[0];\r\n        let points = path.segments.map(s=>s.point);\r\n        let ax1 = points[2].subtract(points[0]);\r\n        let ax2 = points[3].subtract(points[1]);\r\n        let a, b;\r\n        if(ax1.length > ax2.length){\r\n            a = ax1;\r\n            b = ax2;\r\n        } else {\r\n            a = ax2;\r\n            b = ax1;\r\n        }\r\n\r\n        let angle = a.angle;\r\n        return {\r\n            majorRadius: a.length/2,\r\n            minorRadius: b.length/2,\r\n            angle: angle\r\n        };\r\n    }\r\n\r\n    static onTransform(){\r\n        let operation = arguments[0];\r\n        switch(operation){\r\n            case 'complete':{\r\n                let curves = this.children[0].curves;\r\n                let center = this.bounds.center;\r\n                //take two adjacent curves (of the four total) and find the point on each closest to the center\r\n                let nearpoints = curves.slice(0, 2).map(curve=>{\r\n                    return {\r\n                        curve: curve,\r\n                        location: curve.getNearestLocation(center),\r\n                    }\r\n                }).sort((a,b) => a.location.distance - b.location.distance);\r\n                \r\n                let closest = nearpoints[0].location.point;\r\n                if(closest.equals(nearpoints[0].curve.segment1.point) || closest.equals(nearpoints[0].curve.segment2.point)){\r\n                    //no recalculation of points/axes required, the nearest point is already one of our existing points, just return\r\n                    return;\r\n                }\r\n                \r\n                let t = nearpoints[0].location.curve == nearpoints[0].curve ? nearpoints[0].location.time : 1;//if owned by the other curve, time == 1 by definition\r\n                let b = closest.subtract(center);//minor axis\r\n                let a = nearpoints[1].curve.getLocationAtTime(t).point.subtract(center);//major axis\r\n                let ellipse = new paper.Path.Ellipse({center:center, radius: [a.length, b.length]}).rotate(a.angle);\r\n                this.children[0].set({segments: ellipse.segments});\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n\n\n//# sourceURL=webpack://js/../src/js/paperitems/ellipse.mjs?")},"../src/js/paperitems/linestring.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Linestring: () => (/* binding */ Linestring)\n/* harmony export */ });\n/* harmony import */ var _annotationitem_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./annotationitem.mjs */ \"../src/js/paperitems/annotationitem.mjs\");\n\r\n\r\nclass Linestring extends _annotationitem_mjs__WEBPACK_IMPORTED_MODULE_0__.AnnotationItem{\r\n    constructor(geoJSON){\r\n        super(geoJSON);\r\n\r\n        if (geoJSON.geometry.type !== 'LineString') {\r\n            error('Bad geoJSON object: type !==\"LineString\"');\r\n        }\r\n        let coords = geoJSON.geometry.coordinates; //array of points\r\n        let pts = coords.map(function (point) {\r\n            return new paper.Point(point[0], point[1]);\r\n        });\r\n    \r\n        let grp = new paper.Group({\r\n            children: [new paper.Path(pts)]\r\n        });\r\n        // grp.config = geoJSON;\r\n        // grp.config.properties.rescale && (delete grp.config.properties.rescale.strokeWidth);\r\n        \r\n        grp.fillColor = null;\r\n\r\n        this.paperItem = grp;\r\n    \r\n    }\r\n    static get supportsType(){\r\n        return {\r\n            type: 'LineString',\r\n        }\r\n    }\r\n    getCoordinates(){\r\n        let item = this.paperItem;\r\n        return item.children.map(function (c) { return c.segments.map(function (s) { return [s.point.x, s.point.y]; }); });\r\n    }\r\n    getProperties(){\r\n        let item = this.paperItem;\r\n        return {\r\n            strokeWidths: item.children.map(c => c.strokeWidth),\r\n        }\r\n    }\r\n    setStyle(properties){\r\n        Object.assign({},properties);\r\n        if(properties.rescale){\r\n            delete properties.rescale['strokeWidth'];\r\n        }\r\n        this._paperItem.style.set(properties);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://js/../src/js/paperitems/linestring.mjs?")},"../src/js/paperitems/multilinestring.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MultiLinestring: () => (/* binding */ MultiLinestring)\n/* harmony export */ });\n/* harmony import */ var _annotationitem_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./annotationitem.mjs */ \"../src/js/paperitems/annotationitem.mjs\");\n\r\n\r\nclass MultiLinestring extends _annotationitem_mjs__WEBPACK_IMPORTED_MODULE_0__.AnnotationItem{\r\n    constructor(geoJSON){\r\n        super(geoJSON);\r\n\r\n        if (geoJSON.geometry.type !== 'MultiLineString') {\r\n            error('Bad geoJSON object: type !==\"MultiLineString\"');\r\n        }\r\n        let coords = geoJSON.geometry.coordinates; //array of points\r\n        let paths = coords.map(function (points, index) {\r\n            let pts = points.map(function (point) {\r\n                return new paper.Point(point[0], point[1]);\r\n            });\r\n            let path = new paper.Path(pts);\r\n            path.strokeWidth = geoJSON.geometry.properties.strokeWidths[index];\r\n            return new paper.Path(pts);\r\n        });\r\n    \r\n        let grp = new paper.Group({\r\n            children: paths\r\n        });\r\n        \r\n        grp.fillColor = null;\r\n\r\n        this.paperItem = grp;\r\n    \r\n    }\r\n    static get supportsType(){\r\n        return {\r\n            type: 'MultiLineString',\r\n        }\r\n    }\r\n    getCoordinates(){\r\n        let item = this.paperItem;\r\n        return item.children.map(function (c) { return c.segments.map(function (s) { return [s.point.x, s.point.y]; }); });\r\n    }\r\n    getProperties(){\r\n        let item = this.paperItem;\r\n        return {\r\n            strokeColor: item.children.length>0 ? item.children[0].strokeColor : undefined,\r\n            strokeWidths: item.children.map(c => c.strokeWidth),\r\n        }\r\n    }\r\n    getStyleProperties(){\r\n        return this.paperItem.children[0].style.toJSON();\r\n    }\r\n    setStyle(properties){\r\n        Object.assign({},properties);\r\n        if(properties.rescale){\r\n            delete properties.rescale['strokeWidth'];\r\n        }\r\n        this._paperItem.style.set(properties);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://js/../src/js/paperitems/multilinestring.mjs?")},"../src/js/paperitems/multipolygon.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MultiPolygon: () => (/* binding */ MultiPolygon)\n/* harmony export */ });\n/* harmony import */ var _annotationitem_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./annotationitem.mjs */ \"../src/js/paperitems/annotationitem.mjs\");\n\r\n\r\n\r\nclass MultiPolygon extends _annotationitem_mjs__WEBPACK_IMPORTED_MODULE_0__.AnnotationItem{\r\n    constructor(geoJSON){\r\n        super(geoJSON);\r\n\r\n        if (geoJSON.geometry.type !== 'MultiPolygon') {\r\n            error('Bad geoJSON object: type !==\"MultiPolygon\"');\r\n        }\r\n        //GeoJSON MultiPolygons are arrays of array of arrays of points\r\n        //Flatten the first level so it's an array of array of points\r\n        let coords = geoJSON.geometry.coordinates.flat();\r\n        let paths = coords.map(function (points) {\r\n            let pts = points.map(function (point) {\r\n                return new paper.Point(point[0], point[1]);\r\n            });\r\n            return new paper.Path(pts);\r\n        });\r\n\r\n        let poly = new paper.CompoundPath({\r\n            children: paths,\r\n            fillRule: 'evenodd',\r\n            closed: true,\r\n        });\r\n\r\n        poly = poly.replaceWith(poly.unite(poly).toCompoundPath());\r\n        \r\n        poly.canBeBoundingElement = true;\r\n\r\n        this.paperItem = poly;\r\n    }\r\n    static get supportsType(){\r\n        return {\r\n            type: 'MultiPolygon'\r\n        }\r\n    }\r\n    getCoordinates(){\r\n        //filter out invalid children with less than 3 points\r\n        let polygons = this.paperItem.children.filter(c=>c.area > 0 && c.segments.length>2);\r\n        let holes = this.paperItem.children.filter(c=>c.area <= 0 && c.segments.length>2);\r\n        let out = polygons.map(p => \r\n            [p.segments.map(s => [s.point.x, s.point.y]), ].concat(\r\n                holes.filter(h=>p.contains(h.segments[0].point)).map(h=> h.segments.map(s=>[s.point.x, s.point.y])) )\r\n        );\r\n        //Close each polygon by making the first point equal to the last (if needed)\r\n        out.forEach(polylist=>{\r\n            polylist.forEach(array=>{\r\n                let first = array[0];\r\n                let last = array.slice(-1)[0];\r\n                if(first[0]!==last[0] || first[1] !== last[1]){\r\n                    array.push([first[0], first[1]]);\r\n                }\r\n            })\r\n        })\r\n        return out;\r\n    }\r\n    getProperties(){\r\n        return;\r\n    }\r\n    \r\n}\r\n\n\n//# sourceURL=webpack://js/../src/js/paperitems/multipolygon.mjs?")},"../src/js/paperitems/placeholder.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Placeholder: () => (/* binding */ Placeholder)\n/* harmony export */ });\n/* harmony import */ var _annotationitem_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./annotationitem.mjs */ "../src/js/paperitems/annotationitem.mjs");\n\r\n\r\nclass Placeholder extends _annotationitem_mjs__WEBPACK_IMPORTED_MODULE_0__.AnnotationItem{\r\n    constructor(geoJSON){\r\n        super(geoJSON);\r\n        \r\n        this.paperItem = new paper.Path();\r\n        // this.paperItem.style = this.paperItem.instructions = geoJSON;\r\n        this.paperItem.style = geoJSON.properties;\r\n\r\n        this.paperItem.initializeGeoJSONFeature = initialize;\r\n    }\r\n    static get supportsType(){\r\n        return {\r\n            type: null\r\n        }\r\n    }\r\n    getCoordinates(){\r\n        return [];\r\n    }\r\n    getProperties(){\r\n        let item = this.paperItem;\r\n        return item.style;\r\n    }\r\n    \r\n}\r\n\r\nfunction initialize(geoJSONGeometryType, geometrySubtype) {\r\n    let item = this;\r\n    // let geoJSON = item.instructions;\r\n    let geoJSON = {\r\n        geometry:{\r\n            type: geoJSONGeometryType,\r\n            coordinates: [],\r\n            properties: {\r\n                subtype:geometrySubtype,\r\n            },\r\n        },\r\n        properties: item.style,\r\n    };\r\n    \r\n    let newItem = paper.Item.fromGeoJSON(geoJSON);\r\n    // newItem.selected=item.selected;\r\n    item.replaceWith(newItem);\r\n        \r\n    return newItem;\r\n}\n\n//# sourceURL=webpack://js/../src/js/paperitems/placeholder.mjs?')},"../src/js/paperitems/point.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Point: () => (/* binding */ Point)\n/* harmony export */ });\n/* harmony import */ var _annotationitem_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./annotationitem.mjs */ \"../src/js/paperitems/annotationitem.mjs\");\n\r\n\r\nclass Point extends _annotationitem_mjs__WEBPACK_IMPORTED_MODULE_0__.AnnotationItem{\r\n    constructor(geoJSON){\r\n        super(geoJSON);\r\n\r\n        if (geoJSON.geometry.type !== 'Point') {\r\n            error('Bad geoJSON object: type !==\"Point\"');\r\n        }\r\n        let radius = 8.0;\r\n        let coords = geoJSON.geometry.coordinates.slice(0, 2);\r\n        \r\n        let point = new paper.Group();\r\n        point.pivot = new paper.Point(0,0);\r\n        point.applyMatrix = true;\r\n        \r\n        let circle = new paper.Path.Circle(new paper.Point(0, 0), radius);\r\n        circle.scale(new paper.Point(1, 0.5), new paper.Point(0, 0));\r\n    \r\n        point.addChild(circle);\r\n    \r\n    \r\n        let textitem = new paper.PointText({\r\n            point: new paper.Point(0, 0),\r\n            pivot: new paper.Point(0, 0),\r\n            content: this.iconText,\r\n            fontFamily: this.iconFontFamily,\r\n            fontWeight: this.iconFontWeight,\r\n            fontSize: 18,\r\n            strokeWidth: 1, //keep this constant\r\n        });\r\n        point.addChild(textitem);\r\n\r\n        //to-do: make this automatic somehow, instead of hard-coded...\r\n        //the problem is that the bounding box of the text for some reason is not tight to the visual object.\r\n        textitem.translate(new paper.Point(-6, -2)); \r\n    \r\n        point.position = new paper.Point(...coords);\r\n        point.scaleFactor = point.project._scope.scaleByCurrentZoom(1);\r\n        point.scale(point.scaleFactor, circle.bounds.center);\r\n        textitem.strokeWidth = point.strokeWidth / point.scaleFactor;\r\n    \r\n        point.rescale = point.rescale || {};\r\n    \r\n        point.rescale.size = function (z) {\r\n            point.scale(1 / (point.scaleFactor * z));\r\n            point.scaleFactor = 1 / z;\r\n            textitem.strokeWidth = 1; //keep constant; reset after strokewidth is set on overall item\r\n        };\r\n        \r\n        point.rotate(-point.view.getRotation());\r\n        point.view.on('rotate',function(ev){point.rotate(-ev.rotatedBy)});\r\n        point.applyRescale();\r\n        \r\n        this.paperItem = point;\r\n\r\n        // define style getter/setter so that style propagates to/from children\r\n        Object.defineProperty(point, 'style', {   \r\n            get: ()=>{ return point.children[0].style },\r\n            set: style=> { point.children.forEach(child=>child.style = style); }\r\n        });\r\n        // override fillOpacity property definition so that style getter/setter doesn't mess with fillOpacity\r\n        Object.defineProperty(point, 'fillOpacity', {   \r\n            get: function(){\r\n                return this._style.fillOpacity;\r\n            },\r\n            set: function(opacity){\r\n                this._style.fillOpacity = opacity;\r\n            }\r\n        });\r\n        \r\n    }\r\n    setStyle(props){\r\n        //override default implementation so it doesn't overwrite the rescale properties\r\n        // let rescale = props.rescale;\r\n        // delete props.rescale;\r\n        props.rescale = OpenSeadragon.extend(true, props.rescale, this.paperItem.rescale);\r\n        this.paperItem.style.set(props);\r\n        // this.paperItem.children[0].style.set(props);\r\n    }\r\n    \r\n    static get supportsType(){\r\n        return {\r\n            type: 'Point'\r\n        }\r\n    }\r\n    getCoordinates(){\r\n        let item = this.paperItem;\r\n        let circle = item.children[0];\r\n        return [circle.bounds.center.x, circle.bounds.center.y];\r\n    }\r\n    getStyleProperties(){\r\n        return this.paperItem.children[0].style.toJSON();\r\n    }\r\n    static onTransform(){\r\n        let operation = arguments[0];\r\n        switch(operation){\r\n            case 'rotate':{\r\n                let angle = arguments[1];\r\n                let center = arguments[2];\r\n                this.rotate(-angle, center); //undo the rotation: return to original position and orientation\r\n                let vector = this.position.subtract(center);\r\n                let newpos = center.add(vector.rotate(angle));\r\n                let delta = newpos.subtract(this.position);\r\n                this.translate(delta);\r\n                break;\r\n            }\r\n            case 'scale':{\r\n                let p = arguments[1]; //reference position\r\n                let r = arguments[2]; //rotation\r\n                let m = arguments[3]; //matrix\r\n\r\n                this.matrix.append(m.inverted()); //undo previous operation\r\n                let pos = this.pivot.transform(this.matrix);\r\n                // let pos = this.pivot;\r\n                let a = pos.subtract(p); // initial vector, unrotated\r\n                let ar = a.rotate(-r); // initial vector, rotated\r\n                let br = ar.multiply(m.scaling); //scaled rotated vector\r\n                let b = br.rotate(r); //scaled unrotated vector\r\n                let delta = b.subtract(a); //difference between scaled and unscaled position\r\n\r\n                this.translate(delta);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    get iconText(){\r\n        if(!this._iconText){\r\n            this._makeIcon();\r\n        }\r\n        return this._iconText;\r\n    }\r\n    get iconFontFamily(){\r\n        if(!this._iconFontFamily){\r\n            this._makeIcon();\r\n        }\r\n        return this._iconFontFamily;\r\n    }\r\n    get iconFontWeight(){\r\n        if(!this._iconFontWeight){\r\n            this._makeIcon();\r\n        }\r\n        return this._iconFontWeight;\r\n    }\r\n\r\n    //private\r\n    _makeIcon(){\r\n        //to-do: make the class(es) used to select a fontawesome icon a configurable option\r\n        let domText = $('<i>', { class: 'fa-solid fa-map-pin', style: 'visibility:hidden;' }).appendTo('body');\r\n        let computedStyle = window.getComputedStyle(domText[0], ':before');\r\n        this._iconText = computedStyle.content.substring(1, 2);\r\n        this._iconFontFamily = computedStyle.fontFamily;\r\n        this._iconFontWeight = computedStyle.fontWeight;\r\n        domText.remove();\r\n    }\r\n    \r\n}\r\n\n\n//# sourceURL=webpack://js/../src/js/paperitems/point.mjs?")},"../src/js/paperitems/pointtext.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PointText: () => (/* binding */ PointText)\n/* harmony export */ });\n/* harmony import */ var _annotationitem_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./annotationitem.mjs */ \"../src/js/paperitems/annotationitem.mjs\");\n\r\n\r\nclass PointText extends _annotationitem_mjs__WEBPACK_IMPORTED_MODULE_0__.AnnotationItem{\r\n    constructor(geoJSON){\r\n        super(geoJSON);\r\n\r\n        if (geoJSON.geometry.type !== 'Point') {\r\n            error('Bad geoJSON object: type !==\"Point\"');\r\n        }\r\n        let radius = 4.0;\r\n        let coords = geoJSON.geometry.coordinates.slice(0, 2);\r\n        \r\n        let point = new paper.Group();\r\n        point.pivot = new paper.Point(0,0);\r\n        point.applyMatrix = true;\r\n        \r\n        let circle = new paper.Path.Circle(new paper.Point(0, 0), radius);\r\n        // circle.scale(new paper.Point(1, 0.5), new paper.Point(0, 0));\r\n    \r\n        point.addChild(circle);\r\n    \r\n    \r\n        let textitem = new paper.PointText({\r\n            point: new paper.Point(0, 0),\r\n            pivot: new paper.Point(0, 0),\r\n            content: geoJSON.geometry.properties.content || 'PointText',\r\n            // fontFamily: this.iconFontFamily,\r\n            // fontWeight: this.iconFontWeight,\r\n            fontSize: 18,\r\n            strokeWidth: 1, //keep this constant\r\n        });\r\n        point.addChild(textitem);\r\n        // To do: option to hide the point unless the text is moused over?\r\n        // textitem.on({\r\n        //     mouseenter: function(event) {\r\n        //         circle.visible = true;\r\n        //     },\r\n        //     mouseleave: function(event) {\r\n        //         circle.visible = false;\r\n        //     }\r\n        // });\r\n\r\n        //to-do: make this automatic somehow, instead of hard-coded...\r\n        //the problem is that the bounding box of the text for some reason is not tight to the visual object.\r\n        textitem.translate(new paper.Point(-textitem.bounds.width/2, -(textitem.bounds.height/2))); \r\n        textitem.on('content-changed',function(){\r\n            let boundsNoRotate = textitem.getInternalBounds();\r\n            let offset = new paper.Point(-boundsNoRotate.width/2, -boundsNoRotate.height/2).divide(textitem.view.zoom).rotate(-textitem.view.getRotation());\r\n            textitem.position = circle.bounds.center.add(offset);\r\n        })\r\n    \r\n        point.position = new paper.Point(...coords);\r\n        point.scaleFactor = point.project._scope.scaleByCurrentZoom(1);\r\n        point.scale(point.scaleFactor, circle.bounds.center);\r\n        // textitem.strokeWidth = point.strokeWidth / point.scaleFactor;\r\n    \r\n        point.rescale = point.rescale || {};\r\n    \r\n        point.rescale.size = function (z) {\r\n            point.scale(1 / (point.scaleFactor * z));\r\n            point.scaleFactor = 1 / z;\r\n            textitem.strokeWidth = 0; //keep constant; reset after strokewidth is set on overall item\r\n        };\r\n        \r\n        point.rotate(-point.view.getRotation());\r\n        point.view.on('rotate',function(ev){point.rotate(-ev.rotatedBy)});\r\n        point.applyRescale();\r\n        \r\n        this.paperItem = point;\r\n\r\n        // define style getter/setter so that style propagates to/from children\r\n        Object.defineProperty(point, 'style', {   \r\n            get: ()=>{ return point.children[0].style },\r\n            set: style=> { point.children.forEach(child=>child.style = style); }\r\n        });\r\n        // override fillOpacity property definition so that style getter/setter doesn't mess with fillOpacity\r\n        Object.defineProperty(point, 'fillOpacity', {   \r\n            get: function(){\r\n                return this._style.fillOpacity;\r\n            },\r\n            set: function(opacity){\r\n                this._style.fillOpacity = opacity;\r\n            }\r\n        });\r\n\r\n    }\r\n    setStyle(props){\r\n        //override default implementation so it doesn't overwrite the rescale properties\r\n        // let rescale = props.rescale;\r\n        // delete props.rescale;\r\n        props.rescale = OpenSeadragon.extend(true, props.rescale, this.paperItem.rescale);\r\n        this.paperItem.style.set(props);\r\n        // this.paperItem.children[0].style.set(props);\r\n    }\r\n    get textitem(){\r\n        return this.paperItem.children[1];\r\n    }\r\n\r\n\r\n    static get supportsType(){\r\n        return {\r\n            type: 'Point',\r\n            subtype:'PointText',\r\n        }\r\n    }\r\n    getCoordinates(){\r\n        let item = this.paperItem;\r\n        let circle = item.children[0];\r\n        return [circle.bounds.center.x, circle.bounds.center.y];\r\n    }\r\n    getProperties(){\r\n        let item = this.paperItem;\r\n        return {\r\n            content: item.children[1].content,\r\n        };\r\n    }\r\n    getStyleProperties(){\r\n        return this.paperItem.children[0].style.toJSON();\r\n    }\r\n    static onTransform(){\r\n        let operation = arguments[0];\r\n        switch(operation){\r\n            case 'rotate':{\r\n                let angle = arguments[1];\r\n                let center = arguments[2];\r\n                this.rotate(-angle, center); //undo the rotation: return to original position and orientation\r\n                let vector = this.position.subtract(center);\r\n                let newpos = center.add(vector.rotate(angle));\r\n                let delta = newpos.subtract(this.position);\r\n                this.translate(delta);\r\n                break;\r\n            }\r\n            case 'scale':{\r\n                let p = arguments[1]; //reference position\r\n                let r = arguments[2]; //rotation\r\n                let m = arguments[3]; //matrix\r\n\r\n                this.matrix.append(m.inverted()); //undo previous operation\r\n                let pos = this.pivot.transform(this.matrix);\r\n                // let pos = this.pivot;\r\n                let a = pos.subtract(p); // initial vector, unrotated\r\n                let ar = a.rotate(-r); // initial vector, rotated\r\n                let br = ar.multiply(m.scaling); //scaled rotated vector\r\n                let b = br.rotate(r); //scaled unrotated vector\r\n                let delta = b.subtract(a); //difference between scaled and unscaled position\r\n\r\n                this.translate(delta);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    \r\n}\r\n\n\n//# sourceURL=webpack://js/../src/js/paperitems/pointtext.mjs?")},"../src/js/paperitems/raster.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Raster: () => (/* binding */ Raster)\n/* harmony export */ });\n/* harmony import */ var _annotationitem_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./annotationitem.mjs */ \"../src/js/paperitems/annotationitem.mjs\");\n\r\n\r\n/*\r\n * Raster - contains pixel data for a rectangular region, with an optional clip mask\r\n * pseudo-GeoJSON definition:\r\n * {\r\n *   type: Feature\r\n *   geometry:{\r\n *     type: GeometryCollection,\r\n *     properties:{\r\n *       subtype: Raster,\r\n *       raster: {\r\n *          data: [Raster data],\r\n *          width: width of raster image,\r\n *          height: height of raster image,\r\n *          center: center of raster object [x, y],\r\n *          scaling: scaling applied to raster object [x, y],\r\n *          rotation: rotation applied to raster object,\r\n *       },\r\n *       transform: matrix\r\n *     }\r\n *     geometries:[ Array of GeoJSON Geometry objects ],\r\n *   }\r\n * \r\n **/\r\n\r\nclass Raster extends _annotationitem_mjs__WEBPACK_IMPORTED_MODULE_0__.AnnotationItem{\r\n    constructor(geoJSON){\r\n        super(geoJSON);\r\n        if (geoJSON.geometry.type !== 'GeometryCollection' || geoJSON.geometry.properties.subtype !== 'Raster') {\r\n            error('Bad geoJSON object: type !==\"GeometryCollection\" or subtype !==\"Raster\"');\r\n        }\r\n\r\n        //handle composition by geoJSON definition or by pre-constructed paper items\r\n        let inputRaster = geoJSON.geometry.properties.raster;\r\n        let inputClip = geoJSON.geometry.geometries;\r\n\r\n        if(!inputRaster){\r\n            error('Bad input: geometry.properties.raster must hold raster data, or a paper.Raster object');\r\n        }\r\n\r\n        let raster;\r\n        if(inputRaster.data instanceof paper.Raster){\r\n            raster = inputRaster.data;\r\n        } else {\r\n            raster = new paper.Raster(inputRaster.data);\r\n            raster.translate(inputRaster.center[0], inputRaster.center[1]);\r\n            raster.scale(inputRaster.scaling[0], inputRaster.scaling[1]);\r\n            raster.rotate(inputRaster.rotation);\r\n        }\r\n        \r\n        raster.selectedColor = rasterColor;\r\n\r\n        \r\n\r\n        let grp = new paper.Group([raster]);\r\n        grp.updateFillOpacity = function(){\r\n            paper.Group.prototype.updateFillOpacity.call(this);\r\n            raster.opacity = this.opacity * this._computedFillOpacity;\r\n            if(grp.clipped){\r\n                grp.children[0].fillColor = null;\r\n            }\r\n        }\r\n        if(inputClip.length > 0){\r\n            let clipGroup = new paper.Group();\r\n            grp.insertChild(0, clipGroup);\r\n            grp.clipped = true; //do this after adding the items, so the stroke style is deleted\r\n            inputClip.forEach(i => {\r\n                let item = i instanceof paper.Item ? paper.Item.fromAnnotationItem(i) : paper.Item.fromGeoJSON(i);\r\n                delete item.isGeoJSONFeature; //so it doesn't trigger event handlers about new features being added/moved/removed\r\n                item._annotationItem = item.annotationItem; //rename to private property\r\n                delete item.annotationItem; //so it isn't found by descendants query\r\n                setTimeout(()=>item.strokeColor = (i.properties||i).strokeColor);\r\n                item.strokeWidth = (i.properties||i).strokeWidth;\r\n                item.rescale = (i.properties||i).rescale;\r\n                clipGroup.addChild(item);\r\n            });\r\n            \r\n        }\r\n\r\n        if(geoJSON.geometry.properties.transform){\r\n            grp.matrix = new paper.Matrix(geoJSON.geometry.properties.transform);\r\n        }\r\n\r\n        grp.on('selected',()=>{\r\n            grp.clipped && (grp.children[0].selected = false);\r\n        })\r\n        \r\n        this.paperItem = grp;\r\n    }\r\n    static get supportsType(){\r\n        return {\r\n            type: 'GeometryCollection',\r\n            subtype: 'Raster'\r\n        }\r\n    }\r\n    toGeoJSONGeometry(){\r\n        let item = this.paperItem;\r\n        let clipGroup = item.children[0];\r\n        let raster = item.children[1];\r\n        let geom = {\r\n            type: 'GeometryCollection',\r\n            properties: {\r\n                subtype: 'Raster',\r\n                raster: {\r\n                    data:raster.toDataURL(),\r\n                    center: [raster.bounds.center.x, raster.bounds.center.y],\r\n                    width: raster.width,\r\n                    height: raster.height,\r\n                    scaling: [raster.matrix.scaling.x, raster.matrix.scaling.y],\r\n                    rotation: raster.matrix.rotation,\r\n                },\r\n                transform: item.matrix.values,\r\n            },\r\n            geometries:clipGroup.children.map(item=>{\r\n                let feature = item._annotationItem.toGeoJSONFeature();\r\n                let geometry = feature.geometry;\r\n                geometry.properties.strokeColor = feature.properties.strokeColor;\r\n                geometry.properties.strokeWidth = feature.properties.strokeWidth;\r\n                geometry.properties.rescale = feature.properties.rescale;\r\n                return geometry;\r\n            })\r\n        }\r\n        return geom;\r\n    }\r\n}\r\n\r\nconst rasterColor = new paper.Color(0,0,0,0);\r\n\n\n//# sourceURL=webpack://js/../src/js/paperitems/raster.mjs?")},"../src/js/paperitems/rectangle.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Rectangle: () => (/* binding */ Rectangle)\n/* harmony export */ });\n/* harmony import */ var _annotationitem_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./annotationitem.mjs */ \"../src/js/paperitems/annotationitem.mjs\");\n\r\n\r\nclass Rectangle extends _annotationitem_mjs__WEBPACK_IMPORTED_MODULE_0__.AnnotationItem{\r\n    constructor(geoJSON){\r\n        super(geoJSON);\r\n\r\n        if (geoJSON.geometry.type !== 'Point' || geoJSON.geometry.properties.subtype !== 'Rectangle') {\r\n            error('Bad geoJSON object: type !==\"Point\" or subtype !==\"Rectangle\"');\r\n        }\r\n        \r\n\r\n        let poly = new paper.CompoundPath({\r\n            children: [],\r\n            fillRule: 'evenodd',\r\n        });\r\n\r\n        if(geoJSON.geometry.coordinates.length > 1){\r\n            let center = geoJSON.geometry.coordinates.slice(0, 2);\r\n            let x = center[0] || 0;\r\n            let y = center[1] || 0;\r\n            let props = geoJSON.geometry.properties;\r\n            let w = props.width || 0;\r\n            let h = props.height || 0;\r\n            let degrees = props.angle || 0;\r\n            \r\n            let corners = [ [x - w/2, y - h/2], [x + w/2, y - h/2], [x + w/2, y + h/2], [x - w/2, y + h/2] ]; //array of array of points\r\n            let pts = corners.map(function (point) {\r\n                return new paper.Point(point[0], point[1]);\r\n            });\r\n            let path = new paper.Path(pts);\r\n            poly.addChild(path);\r\n            poly.closed = true;\r\n\r\n            poly.rotate(degrees);\r\n        }\r\n        \r\n        \r\n        poly.canBeBoundingElement = true;\r\n\r\n        this.paperItem = poly;\r\n    }\r\n    static get supportsType(){\r\n        return {\r\n            type: 'Point',\r\n            subtype: 'Rectangle'\r\n        }\r\n    }\r\n    getCoordinates(){\r\n        let item = this.paperItem;\r\n        return [item.position.x, item.position.y];\r\n    }\r\n    getProperties(){\r\n        let item = this.paperItem;\r\n        let path = item.children[0];\r\n        let points = path.segments.map(s=>s.point);\r\n        let top = points[1].subtract(points[0]);\r\n        let left = points[0].subtract(points[3]);\r\n        let w = top.length;\r\n        let h = left.length;\r\n        let angle = top.angleInDegrees;\r\n        return {\r\n            width: w,\r\n            height: h,\r\n            angle: angle\r\n        };\r\n    }\r\n\r\n    static onTransform(){\r\n        let operation = arguments[0];\r\n        switch(operation){\r\n            case 'rotate':{\r\n                let segments = this.children[0].segments;\r\n                segments.map((s, i) => {\r\n                    let c = s.point.transform(this.matrix);\r\n                    let s2 = segments[(i+1) % 4];\r\n                    let c2 = s2.point.transform(this.matrix);\r\n                    let vec = c2.subtract(c).divide(2);\r\n                    let mp = c.add(vec);//.transform(this.matrix); \r\n                    \r\n                    mp.normal = vec.rotate(-90).normalize();\r\n                    mp.segments = [s, s2];\r\n                    return mp;\r\n                });\r\n                break;\r\n            }\r\n            case 'scale':{\r\n                let p = arguments[1]; //reference position\r\n                let r = arguments[2]; //rotation\r\n                let m = arguments[3]; //matrix\r\n\r\n                this.matrix.append(m.inverted()); //undo previous operation\r\n                \r\n                //scale the midpoints of each edge of the rectangle per the transform operation\r\n                //while projecting the operation onto the normal vector, to maintain rectanglar shape \r\n                let segments = this.children[0].segments;\r\n                segments.map((s, i) => {\r\n                    let c = s.point.transform(this.matrix);\r\n                    let s2 = segments[(i+1) % 4];\r\n                    let c2 = s2.point.transform(this.matrix);\r\n                    let vec = c2.subtract(c).divide(2);\r\n                    let mp = c.add(vec);\r\n                    \r\n                    mp.normal = vec.rotate(-90).normalize();\r\n                    mp.segments = [s, s2];\r\n                    return mp;\r\n                }).forEach((midpoint) => {\r\n                    let a = midpoint.subtract(p);\r\n                    let ar = a.rotate(-r); \r\n                    let br = ar.multiply(m.scaling);\r\n                    let b = br.rotate(r);\r\n                    let delta = b.subtract(a);\r\n                    let proj = delta.project(midpoint.normal);\r\n                    \r\n                    midpoint.segments.forEach(s=>{\r\n                        let pt = s.point.transform(this.matrix).add(proj);\r\n                        s.point = this.matrix.inverseTransform(pt);\r\n                    })\r\n                })\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n\n\n//# sourceURL=webpack://js/../src/js/paperitems/rectangle.mjs?")},"../src/js/papertools/annotationUITool.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AnnotationUITool: () => (/* binding */ AnnotationUITool),\n/* harmony export */   AnnotationUIToolbarBase: () => (/* binding */ AnnotationUIToolbarBase)\n/* harmony export */ });\n/* harmony import */ var _base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.mjs */ \"../src/js/papertools/base.mjs\");\n\r\n\r\nclass AnnotationUITool extends _base_mjs__WEBPACK_IMPORTED_MODULE_0__.ToolBase{\r\n    constructor(paperScope){\r\n        super(paperScope)\r\n        \r\n        this._active=false;\r\n        this._items=[];\r\n        this._item=null;\r\n\r\n    }\r\n    \r\n    activate(){\r\n        if(this._active) return;//breaks possible infinite loops of tools activating/deactivating each other\r\n        this._active=true;\r\n        this.getSelectedItems();\r\n        let previousTool=this.project.paperScope.getActiveTool();\r\n        this.tool.activate();\r\n        this.toolbarControl.activate();//console.log('toolbar control activated')\r\n        previousTool && previousTool != this && previousTool.deactivate(true);\r\n\r\n        this.onActivate();\r\n        this.broadcast('activated',{target:this});\r\n    }\r\n    deactivate(finishToolAction){\r\n        if(!this._active) return;//breaks possible infinite loops of tools activating/deactivating each other\r\n        this._active=false;\r\n        this.toolbarControl.deactivate();\r\n\r\n        this.onDeactivate(finishToolAction);\r\n        this.broadcast('deactivated',{target:this}); \r\n    }\r\n    getToolbarControl(){\r\n        return this.toolbarControl;\r\n    }\r\n    setToolbarControl(toolbarControl){\r\n        this.toolbarControl = toolbarControl;\r\n        return this.toolbarControl;\r\n    }\r\n    refreshItems(){\r\n        return this.getSelectedItems();\r\n    }\r\n    getSelectedItems(){\r\n        this._items = this.project.paperScope.findSelectedItems();\r\n        this._itemToCreate = this.project.paperScope.findSelectedNewItem();\r\n    }\r\n    selectionChanged(){\r\n        this.getSelectedItems();\r\n        this.onSelectionChanged();\r\n    }\r\n    onSelectionChanged(){}\r\n    get items(){\r\n        return this._items;\r\n    }\r\n    get item(){\r\n        return this._items.length==1 ? this._items[0] : null;\r\n    }\r\n    get itemToCreate(){\r\n        return this._itemToCreate;\r\n    }\r\n        \r\n}\r\n\r\nclass AnnotationUIToolbarBase{\r\n    constructor(tool){\r\n        // let self=this;\r\n        this._active=false;\r\n        let button=document.createElement('button');\r\n        button.classList.add('btn','invisible');\r\n        button.textContent = 'Generic Tool';\r\n\r\n        this.button=new OpenSeadragon.Button({\r\n            tooltip:'Generic Tool',\r\n            element:button,\r\n            onClick:function(ev){if(!ev.eventSource.element.disabled) tool._active?tool.deactivate(true):tool.activate()},\r\n        });\r\n        this.button.configure=function(node,tooltip){\r\n            this.element.title = tooltip;\r\n            this.element.replaceChildren(node);\r\n            this.element.classList.remove('invisible');\r\n            this.tooltip=tooltip;\r\n        }\r\n        this.dropdown=document.createElement('div');\r\n        this.dropdown.classList.add('dropdown'); \r\n        this.tool = tool;\r\n    }\r\n    isEnabledForMode(mode){\r\n        return false;\r\n    }\r\n    activate(){\r\n        if(this._active) return;\r\n        this._active=true;\r\n        //this.tool.activate();\r\n        this.button.element.classList.add('active');\r\n        this.dropdown.classList.add('active');\r\n    }\r\n    deactivate(shouldFinish){\r\n        if(!this._active) return;\r\n        this._active=false;\r\n        //this.tool.deactivate(shouldFinish);\r\n        this.button.element.classList.remove('active');\r\n        this.dropdown.classList.remove('active');\r\n    }\r\n}\n\n//# sourceURL=webpack://js/../src/js/papertools/annotationUITool.mjs?")},"../src/js/papertools/base.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ToolBase: () => (/* binding */ ToolBase)\n/* harmony export */ });\nclass ToolBase{\r\n    constructor(paperScope){\r\n        //If a layer in the current project exists that is named \"toolLayer\" it will be used by the tool for graphical display\r\n        //Otherwise, the current active layer will be used as the tool layer.\r\n        \r\n        let projectInterface = this.project ={\r\n            getZoom:()=>paperScope.view.getZoom(),\r\n            toolLayer:paperScope.project.layers.toolLayer || paperScope.project.activeLayer,\r\n            paperScope:paperScope,\r\n            overlay:paperScope.overlay,\r\n        }\r\n        \r\n        let shiftPressed;\r\n        let self=this;\r\n        this.extensions = {\r\n            onActivate:()=>{},\r\n            onDeactivate:()=>{}\r\n        }\r\n        this.tool = new paperScope.Tool();\r\n        // console.log('tool created at index',paperScope.tools.indexOf(this.tool),paperScope)\r\n        this.tool._toolObject=this;\r\n            \r\n        this.tool.extensions = {\r\n            onKeyUp:()=>{},\r\n            onKeyDown:()=>{},\r\n        }\r\n        this.tool.onKeyDown=function(ev){\r\n            if(!shiftPressed && ev.key==='shift'){\r\n                shiftPressed=true;\r\n                self.onDeactivate();//enable OpenSeadragon event handling for navigation\r\n            }\r\n            this.extensions.onKeyDown(ev);\r\n        }\r\n        this.tool.onKeyUp=function(ev){\r\n            if(ev.key=='shift'){\r\n                shiftPressed=false;\r\n                self.onActivate();//start capturing mouse/keyboard events again\r\n            }\r\n            this.extensions.onKeyUp(ev);\r\n        },\r\n        this.listeners = {}\r\n    }\r\n    isActive(){return this._active; }\r\n    activate(){\r\n        this.tool.activate();\r\n        this.onActivate();\r\n    }\r\n    deactivate(finishToolAction){\r\n        this.onDeactivate(finishToolAction);\r\n    }\r\n    onActivate(){\r\n        this.captureUserInput(true);\r\n        this.project.overlay.addEventListener('wheel',this.tool.onMouseWheel);\r\n        this.project.toolLayer.bringToFront();\r\n        this.extensions.onActivate();\r\n    }\r\n    onDeactivate(shouldFinish=false){\r\n        this.captureUserInput(false);\r\n        this.project.overlay.removeEventListener('wheel',this.tool.onMouseWheel);\r\n        this.project.toolLayer.sendToBack(); \r\n        this.extensions.onDeactivate(shouldFinish);\r\n    }\r\n    addEventListener(eventType,callback){\r\n        this.listeners[eventType] = this.listeners[eventType]||[];\r\n        this.listeners[eventType].push(callback);\r\n    }\r\n    broadcast(eventType,...data){\r\n        let listeners = this.listeners[eventType];\r\n        listeners && listeners.forEach(l=>l(...data));\r\n    }\r\n    \r\n    \r\n    captureUserInput(capture = true) { \r\n        this.project.overlay.setOSDMouseNavEnabled(!capture);\r\n    };\r\n        \r\n}\r\n\n\n//# sourceURL=webpack://js/../src/js/papertools/base.mjs?")},"../src/js/papertools/brush.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BrushTool: () => (/* binding */ BrushTool)\n/* harmony export */ });\n/* harmony import */ var _annotationUITool_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./annotationUITool.mjs */ \"../src/js/papertools/annotationUITool.mjs\");\n/* harmony import */ var _paper_offset_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../paper-offset.mjs */ \"../src/js/paper-offset.mjs\");\n\r\n\r\nclass BrushTool extends _annotationUITool_mjs__WEBPACK_IMPORTED_MODULE_0__.AnnotationUITool{\r\n    constructor(paperScope){\r\n        super(paperScope);\r\n        let self = this;\r\n        let tool = this.tool;\r\n        this.setToolbarControl(new BrushToolbar(this));\r\n\r\n        this.eraseMode = false;\r\n        let drawColor = new paper.Color('green');\r\n        let eraseColor= new paper.Color('red');\r\n        drawColor.alpha=0.5;\r\n        eraseColor.alpha=0.5;\r\n\r\n        let radius = 0;\r\n        let cursor=new paper.Shape.Circle(new paper.Point(0,0),radius);\r\n        cursor.set({\r\n            strokeWidth:1,\r\n            strokeColor:'black',\r\n            fillColor:drawColor,\r\n            opacity:1,\r\n            visible:false,\r\n        });\r\n        this.pathGroup = new paper.Group([new paper.Path(), new paper.Path()]);\r\n        self.project.toolLayer.addChild(this.pathGroup);\r\n        self.project.toolLayer.addChild(cursor);\r\n\r\n        this.extensions.onActivate = function(){\r\n            cursor.radius = radius/self.project.getZoom();\r\n            cursor.strokeWidth=1/self.project.getZoom();\r\n            cursor.visible=true;\r\n            tool.minDistance=3/self.project.getZoom();\r\n            tool.maxDistance=10/self.project.getZoom();\r\n        }\r\n        this.extensions.onDeactivate = function(finished){\r\n            cursor.visible=false;\r\n            if(finished){\r\n                self.finish();\r\n            } \r\n        }\r\n        this.finish = function(){\r\n            this.deactivate();\r\n        }\r\n        \r\n        this.setRadius=function(r){\r\n            radius = r;\r\n            cursor.radius=r/self.project.getZoom();\r\n        }\r\n        this.setEraseMode=function(erase){\r\n            this.eraseMode=erase;\r\n            cursor.fillColor= erase ? eraseColor : drawColor;\r\n            this.toolbarControl.setEraseMode(this.eraseMode);\r\n        }\r\n        \r\n              \r\n        tool.onMouseDown=function(ev){\r\n            ev.preventDefault();\r\n            ev.stopPropagation();\r\n            \r\n            if(self.itemToCreate){\r\n                self.itemToCreate.initializeGeoJSONFeature('MultiPolygon');\r\n                self.refreshItems();\r\n            }\r\n            \r\n            cursor.position=ev.point;\r\n\r\n            let path = new paper.Path([ev.point]);\r\n            path.mode = self.eraseMode ? 'erase' : 'draw';\r\n            path.radius = radius/self.project.getZoom();\r\n            \r\n            self.pathGroup.lastChild.replaceWith(path);\r\n            self.pathGroup.lastChild.set({strokeWidth:cursor.radius*2,fillColor:null,strokeCap:'round'});\r\n            if(path.mode=='erase'){\r\n                self.pathGroup.firstChild.fillColor=eraseColor;\r\n                self.pathGroup.lastChild.strokeColor=eraseColor;        \r\n            }\r\n            else{\r\n                self.pathGroup.firstChild.fillColor=drawColor;\r\n                self.pathGroup.lastChild.strokeColor=drawColor;\r\n            }\r\n        }\r\n        tool.onMouseMove=function(ev){\r\n            cursor.position=ev.point;\r\n        }\r\n        tool.onMouseDrag=function(ev){\r\n            cursor.position=ev.point;\r\n            if(self.item){\r\n                self.pathGroup.lastChild.add(ev.point);\r\n                self.pathGroup.lastChild.smooth({ type: 'continuous' })\r\n            }\r\n        }\r\n        tool.onMouseUp=function(ev){\r\n            self.modifyArea();\r\n        }\r\n        tool.onMouseWheel = function(ev){\r\n            // console.log('Wheel event',ev);\r\n            ev.preventDefault();\r\n            ev.stopPropagation();\r\n            if(ev.deltaY==0) return;//ignore lateral \"scrolls\"\r\n            self.toolbarControl.updateBrushRadius({larger:ev.deltaY < 0});\r\n        }\r\n\r\n        tool.extensions.onKeyDown=function(ev){\r\n            if(ev.key=='e'){\r\n                if(self.eraseMode===false){\r\n                    self.setEraseMode(true);\r\n                }\r\n                else {\r\n                    self.eraseMode='keyhold';\r\n                }\r\n            }\r\n        }\r\n        tool.extensions.onKeyUp=function(ev){\r\n            if(ev.key=='e' && self.eraseMode=='keyhold'){\r\n                self.setEraseMode(false);\r\n            }\r\n        }\r\n    } \r\n    modifyArea(){\r\n        let path = this.pathGroup.lastChild;\r\n        let shape;\r\n        if(path.segments.length>1){                \r\n            shape = _paper_offset_mjs__WEBPACK_IMPORTED_MODULE_1__.PaperOffset.offsetStroke(path,path.radius,{join:'round',cap:'round',insert:true})\r\n        }\r\n        else{\r\n            shape = new paper.Path.Circle({center: path.firstSegment.point, radius: path.radius });\r\n        }\r\n\r\n        shape.strokeWidth = 1/this.project.getZoom();\r\n        shape.strokeColor = 'black'\r\n        shape.fillColor='yellow'\r\n        shape.flatten();\r\n        shape.name='shapeobject';\r\n        if(!this.item.isBoundingElement){\r\n            let boundingItems = this.item.parent.children.filter(i=>i.isBoundingElement);\r\n            shape.applyBounds(boundingItems);\r\n        }\r\n\r\n        path.visible=false;\r\n        let result;\r\n        if(this.eraseMode){\r\n            result = this.item.subtract(shape,{insert:false});\r\n        }\r\n        else{\r\n            result = this.item.unite(shape,{insert:false});    \r\n        }\r\n        if(result){\r\n            result=result.toCompoundPath();\r\n            this.item.removeChildren();\r\n            this.item.addChildren(result.children);\r\n            result.remove();     \r\n        }\r\n        shape.remove();\r\n    }  \r\n}\r\n\r\nclass BrushToolbar extends _annotationUITool_mjs__WEBPACK_IMPORTED_MODULE_0__.AnnotationUIToolbarBase{\r\n    constructor(brushTool){\r\n        super(brushTool);\r\n        let html = $('<i>',{class:'fa fa-brush fa-rotate-by',style:'--fa-rotate-angle: 225deg;'})[0];\r\n        this.button.configure(html,'Brush Tool');\r\n        \r\n        let fdd = $('<div>',{'data-tool':'brush',class:'dropdown brush-toolbar'}).appendTo(this.dropdown);\r\n        let defaultRadius = 20;\r\n        $('<label>').text('Radius').appendTo(fdd)\r\n        this.rangeInput=$('<input>',{type:'range',min:1,max:100,value:defaultRadius}).appendTo(fdd).on('change',function(){\r\n                // console.log('Range input changed',$(this).val());\r\n                brushTool.setRadius($(this).val());\r\n            });\r\n        this.eraseButton=$('<button>',{class:'btn btn-secondary','data-action':'erase'}).appendTo(fdd).text('Erase').on('click',function(){\r\n            let erasing = $(this).toggleClass('active').hasClass('active');\r\n            brushTool.setEraseMode(erasing);\r\n        });\r\n        setTimeout(()=>brushTool.setRadius(defaultRadius), 0);\r\n    }\r\n    isEnabledForMode(mode){\r\n        return ['new','MultiPolygon'].includes(mode);\r\n    }\r\n    updateBrushRadius(update){\r\n        if(update.larger){\r\n            this.rangeInput.val(parseInt(this.rangeInput.val())+1).trigger('change');\r\n        }\r\n        else{\r\n            this.rangeInput.val(parseInt(this.rangeInput.val())-1).trigger('change');\r\n        }\r\n    }\r\n    setEraseMode(erasing){\r\n        erasing ? this.eraseButton.addClass('active') : this.eraseButton.removeClass('active');\r\n    }\r\n}\n\n//# sourceURL=webpack://js/../src/js/papertools/brush.mjs?")},"../src/js/papertools/default.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultTool: () => (/* binding */ DefaultTool)\n/* harmony export */ });\n/* harmony import */ var _annotationUITool_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./annotationUITool.mjs */ \"../src/js/papertools/annotationUITool.mjs\");\n\r\nclass DefaultTool extends _annotationUITool_mjs__WEBPACK_IMPORTED_MODULE_0__.AnnotationUITool{\r\n    constructor(paperScope){\r\n        super(paperScope);\r\n        this.setToolbarControl(new DefaultToolbar(this));\r\n    }\r\n    // getToolbarControl(){}//override this so no button gets added\r\n    onDeactivate(){}\r\n    onActivate(){} \r\n}\r\nclass DefaultToolbar extends _annotationUITool_mjs__WEBPACK_IMPORTED_MODULE_0__.AnnotationUIToolbarBase{\r\n    constructor(tool){\r\n        super(tool);\r\n        let html = $('<i>',{class:'fa-solid fa-hand'})[0];\r\n        this.button.configure(html,'Image Navigation Tool');\r\n        \r\n    }\r\n    isEnabledForMode(mode){\r\n        return true;//enabled for all modes\r\n    }\r\n    \r\n}\n\n//# sourceURL=webpack://js/../src/js/papertools/default.mjs?")},"../src/js/papertools/ellipse.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EllipseTool: () => (/* binding */ EllipseTool)\n/* harmony export */ });\n/* harmony import */ var _annotationUITool_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./annotationUITool.mjs */ \"../src/js/papertools/annotationUITool.mjs\");\n\r\nclass EllipseTool extends _annotationUITool_mjs__WEBPACK_IMPORTED_MODULE_0__.AnnotationUITool{\r\n    constructor(paperScope){\r\n        super(paperScope);\r\n        let self=this;\r\n\r\n        let crosshairTool = new paper.Group({visible:false});\r\n        let h1 = new paper.Path({segments:[new paper.Point(0,0),new paper.Point(0,0)],strokeScaling:false,strokeWidth:1,strokeColor:'black'});\r\n        let h2 = new paper.Path({segments:[new paper.Point(0,0),new paper.Point(0,0)],strokeScaling:false,strokeWidth:1,strokeColor:'white',dashArray:[6,6]});\r\n        let v1 = new paper.Path({segments:[new paper.Point(0,0),new paper.Point(0,0)],strokeScaling:false,strokeWidth:1,strokeColor:'black'});\r\n        let v2 = new paper.Path({segments:[new paper.Point(0,0),new paper.Point(0,0)],strokeScaling:false,strokeWidth:1,strokeColor:'white',dashArray:[6,6]});\r\n        crosshairTool.addChildren([h1,h2,v1,v2]);\r\n        this.project.toolLayer.addChild(crosshairTool);\r\n        \r\n        this.mode = null;\r\n        this.creating = null;\r\n        \r\n        this.setToolbarControl(new EllipseToolbar(this));\r\n\r\n        this.tool.onMouseDown=function(ev){\r\n            if(self.itemToCreate){\r\n                self.itemToCreate.initializeGeoJSONFeature('Point', 'Ellipse');\r\n                self.refreshItems();\r\n                \r\n                let r=new paper.Path.Ellipse(ev.point,ev.point);\r\n                self.creating = r;\r\n                self.item.removeChildren();\r\n                self.item.addChild(r);\r\n                self.mode='creating';\r\n            }\r\n            else if(self.item && self.item.hitTest(ev.point,{fill:false,stroke:false,segments:true,tolerance:5/self.project.getZoom()})){\r\n                let result = self.item.hitTest(ev.point,{fill:false,stroke:false,segments:true,tolerance:5/self.project.getZoom()})\r\n                if(result){\r\n                    // crosshairTool.visible=true;\r\n                    self.mode='segment-drag';\r\n                    let idx=result.segment.path.segments.indexOf(result.segment);\r\n                    let oppositeIdx=(idx+2) % result.segment.path.segments.length;\r\n                    //save reference to the original points of the ellipse before the drag started\r\n                    self.points = {\r\n                        opposite: result.segment.path.segments[oppositeIdx].point.clone(),\r\n                        drag: result.segment.point.clone(),\r\n                        p1: result.segment.next.point.clone(),\r\n                        p2: result.segment.previous.point.clone(),\r\n                    }\r\n                }\r\n            }\r\n            // else{\r\n            //     self.mode='modifying';\r\n            // }\r\n        }\r\n        this.tool.onMouseDrag=function(ev){\r\n            let currPt;\r\n            let center = self.item.bounds.center;\r\n            if(self.mode=='creating'){\r\n                let angle = -self.item.view.getRotation();\r\n                \r\n                if(ev.modifiers.command || ev.modifiers.control){\r\n                    let delta = ev.point.subtract(ev.downPoint);\r\n                    let axes = [[1,1],[1,-1],[-1,-1],[-1,1]].map(p=>new paper.Point(p[0],p[1]).rotate(angle));\r\n                    let closestAxis = axes.sort( (a, b) => a.dot(delta) - b.dot(delta))[0];\r\n                    let proj = delta.project(closestAxis);\r\n                    currPt = ev.downPoint.add(proj);\r\n                } else {\r\n                    currPt = ev.point;\r\n                }\r\n                let r=new paper.Rectangle(ev.downPoint.rotate(-angle,center),currPt.rotate(-angle, center));\r\n                let ellipse = new paper.Path.Ellipse(r).rotate(angle);\r\n                self.item.children[0].set({segments: ellipse.segments});\r\n                ellipse.remove();\r\n            }\r\n            else if(self.mode=='segment-drag'){\r\n                let dragdelta = ev.point.subtract(self.points.opposite);\r\n                let axis = self.points.drag.subtract(self.points.opposite);\r\n                let proj = dragdelta.project(axis);\r\n                let angle = axis.angle;\r\n                \r\n                if(ev.modifiers.command || ev.modifiers.control){\r\n                    //scale proportionally\r\n                    let scalefactor = proj.length / axis.length;\r\n                    let halfproj = proj.divide(2);\r\n                    let center = self.points.opposite.add(halfproj);\r\n                    let r1 = halfproj.length;\r\n                    let r2 = Math.abs(self.points.p1.subtract(self.points.opposite).multiply(scalefactor).cross(proj.normalize()));\r\n                    let ellipse = new paper.Path.Ellipse({center:center, radius: [r1, r2]}).rotate(angle);\r\n                    self.item.children[0].set({segments: ellipse.segments});\r\n                    ellipse.remove();\r\n                } else {\r\n                    //scale in one direction only\r\n                    let halfproj = proj.divide(2);\r\n                    let center = self.points.opposite.add(halfproj);\r\n                    let r1 = halfproj.length;\r\n                    let r2 = Math.abs(self.points.p1.subtract(self.points.opposite).cross(proj.normalize()));\r\n                    let ellipse = new paper.Path.Ellipse({center:center, radius: [r1, r2]}).rotate(angle);\r\n                    self.item.children[0].set({segments: ellipse.segments});\r\n                    ellipse.remove();\r\n                }\r\n\r\n            }\r\n            else{\r\n                setCursorPosition(this,ev.point);\r\n                return;\r\n            }\r\n            setCursorPosition(this,currPt);\r\n            \r\n        }\r\n        this.tool.onMouseMove=function(ev){\r\n            setCursorPosition(this,ev.point);\r\n            if(self.mode == 'modifying'){\r\n                let hitResult = self.item.hitTest(ev.point,{fill:false,stroke:false,segments:true,tolerance:5/self.project.getZoom()});\r\n                if(hitResult){\r\n                    self.project.overlay.addClass('rectangle-tool-resize');\r\n                }\r\n                else{\r\n                    self.project.overlay.removeClass('rectangle-tool-resize');\r\n                }\r\n            }\r\n        }\r\n        this.tool.onMouseUp = function(){\r\n            self.mode='modifying';\r\n            crosshairTool.visible=false;\r\n            self.creating=null;\r\n            self.toolbarControl.updateInstructions('Point:Ellipse');\r\n        }\r\n        this.extensions.onActivate = this.onSelectionChanged = function(){\r\n            if(self.itemToCreate){\r\n                self.mode='creating';\r\n                crosshairTool.visible = true;\r\n                self.creating = null;//reset reference to actively creating item\r\n                self.toolbarControl.updateInstructions('new');\r\n            }\r\n            else if(self.creating && self.creating.parent==self.item){\r\n                self.mode='creating';\r\n                crosshairTool.visible = true;\r\n                self.toolbarControl.updateInstructions('new');\r\n            }\r\n            else if (self.item){\r\n                self.creating=null;//reset reference to actively creating item\r\n                self.mode='modifying';\r\n                crosshairTool.visible = false;\r\n                self.toolbarControl.updateInstructions('Point:Ellipse');\r\n            }\r\n            else {\r\n                self.creating=null;//reset reference to actively creating item\r\n                self.mode=null;\r\n                crosshairTool.visible = false;\r\n                self.toolbarControl.updateInstructions('Point:Ellipse');\r\n            }\r\n        }\r\n        this.extensions.onDeactivate = function(finished){\r\n            if(finished) self.creating = null;\r\n            crosshairTool.visible=false;\r\n            self.mode=null;\r\n            self.project.overlay.removeClass('rectangle-tool-resize');\r\n        }\r\n\r\n        function setCursorPosition(tool,point){\r\n            //to do: account for view rotation\r\n            // let viewBounds=tool.view.bounds;\r\n            let pt = tool.view.projectToView(point);\r\n            let left=tool.view.viewToProject(new paper.Point(0, pt.y))\r\n            let right=tool.view.viewToProject(new paper.Point(tool.view.viewSize.width, pt.y))\r\n            let top=tool.view.viewToProject(new paper.Point(pt.x, 0))\r\n            let bottom=tool.view.viewToProject(new paper.Point(pt.x,tool.view.viewSize.height))\r\n            // console.log(viewBounds)\r\n            h1.segments[0].point = left;\r\n            h2.segments[0].point = left;\r\n            h1.segments[1].point = right;\r\n            h2.segments[1].point = right;\r\n            v1.segments[0].point = top;\r\n            v2.segments[0].point = top;\r\n            v1.segments[1].point = bottom;\r\n            v2.segments[1].point = bottom;\r\n        }\r\n    }\r\n    \r\n}\r\nclass EllipseToolbar extends _annotationUITool_mjs__WEBPACK_IMPORTED_MODULE_0__.AnnotationUIToolbarBase{\r\n    constructor(tool){\r\n        super(tool);\r\n        let html = $('<i>',{class:'fa-regular fa-circle'})[0];\r\n        this.button.configure(html,'Ellipse Tool');\r\n        this.instructions = $('<span>').text('Click and drag to create an ellipse').appendTo(this.dropdown);\r\n    }\r\n    isEnabledForMode(mode){\r\n        return ['new','Point:Ellipse'].includes(mode);\r\n    }\r\n    updateInstructions(mode){\r\n        this.instructions.text(mode=='new'?'Click and drag to create an ellipse' : mode=='Point:Ellipse' ? 'Drag a point to resize' : '???' )\r\n    }\r\n}\n\n//# sourceURL=webpack://js/../src/js/papertools/ellipse.mjs?")},"../src/js/papertools/linestring.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LinestringTool: () => (/* binding */ LinestringTool)\n/* harmony export */ });\n/* harmony import */ var _annotationUITool_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./annotationUITool.mjs */ \"../src/js/papertools/annotationUITool.mjs\");\n/* harmony import */ var _polygon_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./polygon.mjs */ \"../src/js/papertools/polygon.mjs\");\n\r\n\r\nclass LinestringTool extends _polygon_mjs__WEBPACK_IMPORTED_MODULE_1__.PolygonTool{\r\n    constructor(paperScope){\r\n        super(paperScope);\r\n        let self = this;\r\n        let tool = this.tool;   \r\n        \r\n        this.setToolbarControl(new LinestringToolbar(this));\r\n        let lastClickTime=0;\r\n        let drawColor = new paper.Color('green');\r\n        let eraseColor= new paper.Color('red');\r\n        this.radius = 0;\r\n        this.cursor=new paper.Shape.Circle(new paper.Point(0,0),this.radius);\r\n        this.cursor.set({\r\n            strokeWidth:1,\r\n            strokeColor:'black',\r\n            fillColor:drawColor,\r\n            opacity:1,\r\n            visible:false,\r\n        });\r\n        self.project.toolLayer.addChild(this.cursor);\r\n\r\n        this.extensions.onActivate= function(){\r\n            self.cursor.radius = self.radius/self.project.getZoom();\r\n            self.cursor.strokeWidth=1/self.project.getZoom();\r\n            self.cursor.visible=true;\r\n            tool.minDistance=4/self.project.getZoom();\r\n            tool.maxDistance=10/self.project.getZoom();\r\n        }\r\n        this.extensions.onDeactivate = function(finished){\r\n            self.cursor.visible=false;\r\n            if(finished){\r\n                self.finish();\r\n            } \r\n        }\r\n        \r\n        this.setRadius=function(r){\r\n            this.radius = r;\r\n            this.cursor.radius=r/this.project.getZoom();\r\n        }\r\n\r\n        // let superOnMouseDown = tool.onMouseDown;\r\n        tool.onMouseDown=function(ev){\r\n            self.draggingSegment=null;\r\n\r\n            if(self.itemToCreate){\r\n                self.itemToCreate.initializeGeoJSONFeature('MultiLineString');\r\n                self.refreshItems();\r\n                \r\n                self.startNewPath(ev)\r\n                // console.log('initialized item')\r\n                return;\r\n            }\r\n            \r\n            // self.simplifying && self.cancelSimplify();  \r\n            let dr = self.drawing();\r\n            let hitResult = (dr&&dr.path ||self.item).hitTest(ev.point,{fill:false,stroke:true,segments:true,tolerance:(5/self.project.getZoom())})\r\n            if(hitResult){\r\n                //if erasing and hitResult is a segment, hitResult.segment.remove()\r\n                if(hitResult.type=='segment' && self.eraseMode){\r\n                    hitResult.segment.remove();\r\n                }\r\n                //if hitResult is the last segment and NOT erasing, finish the current path\r\n                else if(hitResult.type=='segment' && dr && hitResult.segment==dr.path.lastSegment){\r\n                    self.finishCurrentPath();\r\n                }\r\n                //if hitResult is a segment and NOT erasing, save reference to hitResult.segment for dragging it\r\n                else if(hitResult.type=='segment'){\r\n                    self.draggingSegment = hitResult.segment;\r\n                }\r\n                //if hitResult is a stroke, add a point (unless in erase mode):\r\n                else if(hitResult.type=='stroke' && !self.eraseMode){\r\n                    let insertIndex = hitResult.location.index +1;\r\n                    let ns = hitResult.item.insert(insertIndex, ev.point);\r\n                }\r\n            }\r\n            else{ //not drawing yet, but start now!\r\n                if(!self.eraseMode) self.startNewPath(ev);\r\n            }\r\n            \r\n        }\r\n\r\n        let superOnMouseMove = tool.onMouseMove;\r\n        tool.onMouseMove=function(ev){\r\n            self.cursor.position=ev.point;\r\n            superOnMouseMove(ev);\r\n        }\r\n        let superOnMouseDrag = tool.onMouseDrag;\r\n        tool.onMouseDrag=function(ev){\r\n            self.cursor.position=ev.point;\r\n            superOnMouseDrag(ev);\r\n            let dr = self.drawing();\r\n            dr && (dr.path.segments = self.simplifier.simplify(dr.path.segments.map(s=>s.point)));\r\n        }\r\n        tool.onMouseUp=function(ev){\r\n            self.finishCurrentPath();\r\n        }\r\n\r\n        tool.onMouseWheel = function(ev){\r\n            // console.log('Wheel event',ev);\r\n            ev.preventDefault();\r\n            ev.stopPropagation();\r\n            if(ev.deltaY==0) return;//ignore lateral \"scrolls\"\r\n            // self.project.broadcast('brush-radius',{larger:ev.deltaY > 0});\r\n            self.toolbarControl.updateBrushRadius({larger:ev.deltaY < 0});\r\n        }\r\n    }\r\n    startNewPath(ev){\r\n        this.finishCurrentPath();\r\n        this.drawingGroup.removeChildren();\r\n        this.drawingGroup.addChild(new paper.Path([ev.point]));\r\n        // this.drawing = {path:this.drawingGroup.lastChild, index: 1};\r\n        this.drawingGroup.visible=true;\r\n        this.drawingGroup.selected=true;\r\n        this.drawingGroup.selectedColor= this.eraseMode ? 'red' : null;\r\n        this.drawing().path.set({strokeWidth:this.cursor.radius*2, strokeColor:this.item.strokeColor})\r\n        console.log('started new path')\r\n    }\r\n    //override finishCurrentPath so it doesn't close the path\r\n    finishCurrentPath(){\r\n        if(!this.drawing() || !this.item) return;\r\n        \r\n        let newPath = this.drawing().path;\r\n        if(newPath.segments.length>1){\r\n            this.item.addChild(this.drawing().path);\r\n        }\r\n        this.drawingGroup.removeChildren();\r\n    }\r\n}\r\n\r\nclass LinestringToolbar extends _annotationUITool_mjs__WEBPACK_IMPORTED_MODULE_0__.AnnotationUIToolbarBase{\r\n    constructor(linestringTool){\r\n        super(linestringTool);\r\n        let html = $('<i>',{class:'fa-solid fa-pen-nib'})[0];\r\n        this.button.configure(html,'Linestring Tool');\r\n        \r\n        let fdd = $('<div>',{'data-tool':'linestring',class:'dropdown linestring-toolbar'}).prependTo(this.dropdown);\r\n        let defaultRadius=4;\r\n        $('<label>').text('Set pen width:').appendTo(fdd);\r\n        this.rangeInput=$('<input>',{type:'range',min:.2,max:12,step:0.1,value:defaultRadius}).appendTo(fdd).on('change',function(){\r\n            linestringTool.setRadius($(this).val());\r\n        });\r\n        this.eraseButton=$('<button>',{'data-action':'erase'}).text('Eraser').appendTo(fdd).on('click',function(){\r\n            let erasing = $(this).toggleClass('active').hasClass('active');\r\n            linestringTool.setEraseMode(erasing);\r\n        });\r\n        setTimeout(()=>linestringTool.setRadius(defaultRadius));\r\n    }\r\n    updateBrushRadius(update){\r\n        if(update.larger){\r\n            this.rangeInput.val(parseFloat(this.rangeInput.val())+parseFloat(this.rangeInput.attr('step'))).trigger('change');\r\n        }\r\n        else{\r\n            this.rangeInput.val(parseFloat(this.rangeInput.val())-parseFloat(this.rangeInput.attr('step'))).trigger('change');\r\n        }\r\n    }\r\n    isEnabledForMode(mode){\r\n        return ['new','LineString','MultiLineString'].includes(mode);\r\n    }\r\n    setEraseMode(erasing){\r\n        erasing ? this.eraseButton.addClass('active') : this.eraseButton.removeClass('active');\r\n    }\r\n}\n\n//# sourceURL=webpack://js/../src/js/papertools/linestring.mjs?")},"../src/js/papertools/point.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PointTool: () => (/* binding */ PointTool)\n/* harmony export */ });\n/* harmony import */ var _annotationUITool_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./annotationUITool.mjs */ \"../src/js/papertools/annotationUITool.mjs\");\n/* harmony import */ var _paperitems_point_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../paperitems/point.mjs */ \"../src/js/paperitems/point.mjs\");\n\r\n\r\nclass PointTool extends _annotationUITool_mjs__WEBPACK_IMPORTED_MODULE_0__.AnnotationUITool{\r\n    constructor(paperScope){\r\n        super(paperScope);\r\n        let tool = this.tool;\r\n        let self=this;\r\n        let dragging=false;\r\n        \r\n        let cursor = new _paperitems_point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point({geometry:{type:'Point',coordinates:[0,0]},properties:{label:'Point Tool'}}).paperItem;\r\n        cursor.fillColor=null;\r\n        cursor.strokeColor='grey';\r\n        cursor.visible=false;\r\n        delete cursor.isGeoJSONFeature; // remove this field since this isn't really part of the GeoJSON structure\r\n        \r\n        this.project.toolLayer.addChild(cursor);\r\n        \r\n        this.setToolbarControl(new PointToolbar(this));\r\n        this.extensions.onActivate=function(){\r\n            // self.project.paperScope.project.activeLayer.addChild(cursor);\r\n            self.project.toolLayer.bringToFront();\r\n            if(self.itemToCreate) cursor.visible = true;\r\n        }\r\n        this.extensions.onDeactivate=function(){\r\n            self.project.toolLayer.sendToBack();\r\n            // self.project.toolLayer.addChild(cursor);\r\n            cursor.visible=false;\r\n            self.project.overlay.removeClass('point-tool-grab', 'point-tool-grabbing');\r\n        }\r\n        this.onSelectionChanged = function(){\r\n            cursor.visible = !!this.itemToCreate;\r\n        }\r\n        tool.onMouseMove=function(ev){\r\n            cursor.position = ev.point;\r\n            if(ev.item && self.item.hitTest(ev.point)){\r\n                self.project.overlay.addClass('point-tool-grab');\r\n            }\r\n            else{\r\n                self.project.overlay.removeClass('point-tool-grab');\r\n            }   \r\n        }\r\n        tool.onMouseDown=function(ev){\r\n            if(self.itemToCreate){\r\n                self.itemToCreate.initializeGeoJSONFeature('Point');\r\n                self.refreshItems();\r\n                self.item.position=ev.point;\r\n                cursor.visible=false;\r\n                self.toolbarControl.updateInstructions('Point');\r\n            }\r\n            else{\r\n                if(self.item&&self.item.hitTest(ev.point)){\r\n                    dragging=true;\r\n                    self.project.overlay.addClass('point-tool-grabbing')\r\n                }\r\n            }\r\n        }\r\n        tool.onMouseDrag=function(ev){\r\n            if(dragging){\r\n                self.item && (self.item.position = self.item.position.add(ev.delta))\r\n            }\r\n        }\r\n        tool.onMouseUp=function(ev){\r\n            dragging=false;\r\n            self.project.overlay.removeClass('point-tool-grabbing');\r\n        }\r\n    } \r\n}\r\n\r\nclass PointToolbar extends _annotationUITool_mjs__WEBPACK_IMPORTED_MODULE_0__.AnnotationUIToolbarBase{\r\n    constructor(tool){\r\n        super(tool);\r\n        let html = $('<i>',{class:'fa-solid fa-map-pin'})[0];\r\n        this.button.configure(html,'Point Tool');\r\n        this.instructions=$('<span>').text('').appendTo(this.dropdown);\r\n    }\r\n    isEnabledForMode(mode){\r\n        this.updateInstructions(mode);\r\n        return ['new','Point'].includes(mode);\r\n    }\r\n    updateInstructions(mode){\r\n        this.instructions.text(mode=='new'?'Click to drop a pin' : mode=='Point' ? 'Drag to reposition' : '???' )\r\n    }\r\n}\n\n//# sourceURL=webpack://js/../src/js/papertools/point.mjs?")},"../src/js/papertools/pointtext.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PointTextTool: () => (/* binding */ PointTextTool)\n/* harmony export */ });\n/* harmony import */ var _annotationUITool_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./annotationUITool.mjs */ \"../src/js/papertools/annotationUITool.mjs\");\n/* harmony import */ var _paperitems_pointtext_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../paperitems/pointtext.mjs */ \"../src/js/paperitems/pointtext.mjs\");\n\r\n\r\nclass PointTextTool extends _annotationUITool_mjs__WEBPACK_IMPORTED_MODULE_0__.AnnotationUITool{\r\n    constructor(paperScope){\r\n        super(paperScope);\r\n        let tool = this.tool;\r\n        let self=this;\r\n        let dragging=false;\r\n        \r\n        let cursor = this.cursor = new _paperitems_pointtext_mjs__WEBPACK_IMPORTED_MODULE_1__.PointText({\r\n            geometry:{\r\n                type:'Point',\r\n                coordinates:[0,0],\r\n                properties:{\r\n                    subtype:'PointText',\r\n                    content:'Click to place',\r\n                    strokeWidth: 0,\r\n                }\r\n            },\r\n            properties:{\r\n                label:'Text Tool',\r\n            }\r\n        }).paperItem;\r\n        cursor.isGeoJSONFeature = false;\r\n        cursor.fillColor='grey';\r\n        cursor.strokeColor='black';\r\n        cursor.visible=false;\r\n        this.project.toolLayer.addChild(cursor);\r\n        \r\n        this.setToolbarControl(new PointTextToolbar(this));\r\n        this.extensions.onActivate=function(){\r\n            self.project.paperScope.project.activeLayer.addChild(cursor);\r\n            if(self.itemToCreate){\r\n                // new item to be created - show the cursor\r\n                cursor.visible = true;\r\n            } else if(self.item){\r\n                // modifying an existing item\r\n                self._updateTextInput();\r\n            }\r\n        }\r\n        this.extensions.onDeactivate=function(){\r\n            self.project.toolLayer.addChild(cursor);\r\n            cursor.visible=false;\r\n            self.project.overlay.removeClass('point-tool-grab', 'point-tool-grabbing');\r\n        }\r\n        this.onSelectionChanged = function(){\r\n            cursor.visible = !!this.itemToCreate;\r\n            self._updateTextInput();\r\n        }\r\n        tool.onMouseMove=function(ev){\r\n            cursor.position = ev.point;\r\n            if(ev.item && self.item.hitTest(ev.point)){\r\n                self.project.overlay.addClass('point-tool-grab');\r\n            }\r\n            else{\r\n                self.project.overlay.removeClass('point-tool-grab');\r\n            }   \r\n        }\r\n        tool.onMouseDown=function(ev){\r\n            if(self.itemToCreate){\r\n                self.itemToCreate.initializeGeoJSONFeature('Point','PointText');\r\n                self.refreshItems();\r\n                self.item.children[1].content = self.toolbarControl.getValue();\r\n                self.item.position=ev.point;\r\n                cursor.visible=false;\r\n                self.toolbarControl.updateInstructions('Point:PointText');\r\n            }\r\n            else{\r\n                if(self.item&&self.item.hitTest(ev.point)){\r\n                    dragging=true;\r\n                    self.project.overlay.addClass('point-tool-grabbing')\r\n                }\r\n            }\r\n        }\r\n        tool.onMouseDrag=function(ev){\r\n            if(dragging){\r\n                self.item && (self.item.position = self.item.position.add(ev.delta))\r\n            }\r\n        }\r\n        tool.onMouseUp=function(ev){\r\n            dragging=false;\r\n            self.project.overlay.removeClass('point-tool-grabbing');\r\n        }\r\n    } \r\n    _updateTextInput(){\r\n        this.toolbarControl.setItemText(this.item ? this.item.children[1].content : '');\r\n    }\r\n}\r\n\r\nclass PointTextToolbar extends _annotationUITool_mjs__WEBPACK_IMPORTED_MODULE_0__.AnnotationUIToolbarBase{\r\n    constructor(tool){\r\n        super(tool);\r\n        let self = this;\r\n        let html = $('<i>',{class:'fa-solid fa-font'})[0];\r\n        this.button.configure(html,'Text Tool');\r\n        this.instructions=$('<span>',{class:'instructions'}).text('').appendTo(this.dropdown);\r\n        this.input = $('<input>',{type:'text',placeholder:'Enter text'}).appendTo(this.dropdown).on('input',function(){\r\n            let value = self.getValue();\r\n            if(self.tool.item && self.tool.item.annotationItem.subtype=='PointText'){\r\n                self.tool.item.children[1].content = value;\r\n            }\r\n            self.tool.cursor.children[1].content = value;\r\n        });\r\n        this.input.trigger('input');\r\n    }\r\n    setItemText(text){\r\n        this.input.val(text);\r\n    }\r\n    getValue(){\r\n        let input = this.input[0];\r\n        return input.value.trim() || input.getAttribute('placeholder');\r\n    }\r\n    isEnabledForMode(mode){\r\n        this.updateInstructions(mode);\r\n        return ['new','Point:PointText'].includes(mode);\r\n    }\r\n    updateInstructions(mode){\r\n        this.instructions.text(mode=='new'?'Click to drop wisdom' : mode=='Point:PointText' ? 'Drag to reposition' : '???' )\r\n    }\r\n}\n\n//# sourceURL=webpack://js/../src/js/papertools/pointtext.mjs?")},"../src/js/papertools/polygon.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PolygonTool: () => (/* binding */ PolygonTool),\n/* harmony export */   PolygonToolbar: () => (/* binding */ PolygonToolbar)\n/* harmony export */ });\n/* harmony import */ var _annotationUITool_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./annotationUITool.mjs */ \"../src/js/papertools/annotationUITool.mjs\");\n\r\nclass PolygonTool extends _annotationUITool_mjs__WEBPACK_IMPORTED_MODULE_0__.AnnotationUITool{\r\n    constructor(paperScope){\r\n        super(paperScope);\r\n        let self = this;\r\n        let tool = this.tool;\r\n        let lastClickTime = 0;\r\n        this.drawingGroup = new paper.Group();\r\n        self.project.toolLayer.addChild(self.drawingGroup);\r\n        self.drawingGroup.visible=false;  \r\n        this.draggingSegment = null;\r\n        this.eraseMode=false;\r\n        this.simplifying=null;\r\n        this.simplifier = new SimplifyJS();\r\n        this.setToolbarControl(new PolygonToolbar(this));  \r\n        \r\n        this.extensions.onActivate = function(){\r\n            tool.minDistance=4/self.project.getZoom();\r\n            tool.maxDistance=20/self.project.getZoom();\r\n            self.drawingGroup.visible=true;\r\n            self.drawingGroup.selected=true;\r\n        }\r\n        this.extensions.onDeactivate= function(finished){\r\n            if(finished){\r\n                self.finish();\r\n            }\r\n        }\r\n              \r\n        tool.onMouseDown=function(ev){\r\n            self.draggingSegment=null;\r\n            let now = Date.now();\r\n            let interval=now-lastClickTime;\r\n            let dblClick = interval < 300;\r\n            lastClickTime=now;\r\n\r\n            self.simplifying && self.cancelSimplify();  \r\n            \r\n            if(self.itemToCreate){\r\n                self.itemToCreate.initializeGeoJSONFeature('MultiPolygon');\r\n                self.refreshItems();\r\n                \r\n                self.saveHistory();        \r\n            }\r\n\r\n            let dr = self.drawing();\r\n            if(dr && dblClick){\r\n                self.finishCurrentPath();\r\n                self.draggingSegment=null;\r\n                return;\r\n            }\r\n            \r\n            let hitResult = (dr&&dr.path ||self.item).hitTest(ev.point,{fill:false,stroke:true,segments:true,tolerance:(5/self.project.getZoom())})\r\n            if(hitResult){\r\n                //if erasing and hitResult is a segment, hitResult.segment.remove()\r\n                if(hitResult.type=='segment' && self.eraseMode){\r\n                    hitResult.segment.remove();\r\n                }\r\n                //if hitResult is a segment and NOT erasing, save reference to hitResult.segment for dragging it\r\n                else if(hitResult.type=='segment'){\r\n                    self.draggingSegment = hitResult.segment;\r\n                }\r\n                //if hitResult is a stroke, add a point:\r\n                else if(hitResult.type=='stroke'){\r\n                    let insertIndex = hitResult.location.index +1;\r\n                    let ns = hitResult.item.insert(insertIndex, ev.point);\r\n                }\r\n            }\r\n            else if(dr){ //already drawing, add point to the current path object\r\n                if(ev.point.subtract(dr.path.lastSegment).length<(5/self.project.getZoom())) return;\r\n                dr.path.add(ev.point);\r\n            }\r\n            else{ //not drawing yet, but start now!\r\n                self.drawingGroup.removeChildren();\r\n                self.drawingGroup.addChild(new paper.Path([ev.point]));\r\n                self.drawingGroup.visible=true;\r\n                self.drawingGroup.selected=true;\r\n                self.drawingGroup.selectedColor= self.eraseMode ? 'red' : null;\r\n            }\r\n            \r\n            \r\n        }\r\n        tool.onMouseDrag=function(ev){\r\n            let dr = self.drawing();\r\n            if(dr){\r\n                dr.path.add(ev.point)\r\n            }\r\n            else if (self.draggingSegment){\r\n                self.draggingSegment.point = self.draggingSegment.point.add(ev.delta);\r\n            }\r\n        }\r\n        tool.onMouseMove=function(ev){\r\n            let dr = self.drawing();\r\n            let hitResult = self.item && (dr&&dr.path ||self.item).hitTest(ev.point,{fill:false,stroke:true,segments:true,tolerance:(5/self.project.getZoom())})\r\n            if(hitResult){\r\n                let action = hitResult.type + (self.eraseMode ? '-erase' : '');\r\n                self.project.overlay.addClass('tool-action').setAttribute('data-tool-action',action);\r\n            }\r\n            else{\r\n                self.project.overlay.removeClass('tool-action').setAttribute('data-tool-action','');\r\n            }  \r\n        }\r\n        tool.onMouseUp=function(ev){\r\n            let dr = self.drawing();\r\n            if(dr && dr.path.segments.length>1){\r\n                let hitResult = dr.path.hitTest(ev.point,{fill:false,stroke:false,segments:true,tolerance:(5/self.project.getZoom())})\r\n                if(hitResult && hitResult.segment == dr.path.firstSegment){\r\n                    self.finishCurrentPath();\r\n                }\r\n            }\r\n            else if(self.draggingSegment){\r\n                self.draggingSegment=null;\r\n                if(!self.item.isBoundingElement){\r\n                    let boundingItems = self.item.parent.children.filter(i=>i.isBoundingElement);\r\n                    self.item.applyBounds(boundingItems);\r\n                }\r\n            }\r\n            self.saveHistory()\r\n        }\r\n        tool.extensions.onKeyDown=function(ev){\r\n            if(ev.key=='e'){\r\n                if(self.eraseMode===false){\r\n                    self.setEraseMode(true);\r\n                }\r\n                else if(self.eraseMode===true) {\r\n                    self.eraseMode='keyhold';\r\n                }\r\n            }\r\n            if ((ev.event.metaKey||ev.event.ctrlKey) && !ev.event.shiftKey && ev.event.key === 'z') {\r\n                console.log('Undo!');\r\n                self.undo();\r\n            }\r\n            if ((ev.event.metaKey||ev.event.ctrlKey) && ev.event.shiftKey && ev.event.key === 'z') {\r\n                console.log('Redo!');\r\n                self.redo();\r\n            }\r\n        }\r\n        tool.extensions.onKeyUp=function(ev){\r\n            if(ev.key=='e' && self.eraseMode=='keyhold'){\r\n                self.setEraseMode(false);\r\n            }\r\n            \r\n        }\r\n    \r\n    }\r\n    drawing(){\r\n        return this.drawingGroup.lastChild && {\r\n            path: this.drawingGroup.lastChild,\r\n        }\r\n    }\r\n    finish(){\r\n        this.finishCurrentPath();\r\n        this.setEraseMode(false);\r\n        this.draggingSegment=null;\r\n        this.project.overlay.removeClass('tool-action').setAttribute('data-tool-action','');\r\n        this.deactivate();\r\n        this.drawingGroup.selected=false;      \r\n        this.drawingGroup.visible=false;  \r\n    }\r\n    doSimplify(){\r\n        if(!this.item) return;\r\n        \r\n        let lengthThreshold = 10/this.project.getZoom();\r\n        let tol = 2.5/this.project.getZoom();\r\n        this.simplifying = this.simplifying || this.item.clone();\r\n        this.simplifying.item = this.item;\r\n        this.drawingGroup.insertChild(this.simplifying,0);\r\n        let pathsToRemove=[];\r\n        this.simplifying.children.forEach(path=>{\r\n            let pts = path.segments.map(s=>{\r\n                if(s.point.subtract(s.previous.point).length < lengthThreshold && s.point.subtract(s.next.point).length < lengthThreshold){\r\n                    s.point.x = (s.point.x+s.previous.point.x+s.next.point.x)/3;\r\n                    s.point.y = (s.point.y+s.previous.point.y+s.next.point.y)/3;\r\n                }\r\n                return s.point;\r\n            })\r\n            pts.push(pts[0]);//\r\n            let newpts = this.simplifier.simplify(pts,tol,true);\r\n            path.segments=newpts;\r\n            if(path.segments.length < 3 || Math.abs(path.area) < tol*tol) pathsToRemove.push(path);\r\n            \r\n        })\r\n        pathsToRemove.forEach(p=>p.remove());\r\n        let united = this.simplifying.unite(this.simplifying,{insert:false}).reduce().toCompoundPath();\r\n        this.simplifying.removeChildren();\r\n        this.simplifying.addChildren(united.children);\r\n        if(!this.item.isBoundingElement){\r\n            let boundingItems = this.item.parent.children.filter(i=>i.isBoundingElement);\r\n            this.simplifying.applyBounds(boundingItems);\r\n        }\r\n        united.remove();\r\n        this.simplifying.item.removeChildren();\r\n        this.simplifying.item.addChildren(this.simplifying.children);\r\n        this.simplifying.remove();\r\n        this.simplifying = null;\r\n        this.saveHistory()\r\n        \r\n    }\r\n    \r\n    \r\n    setEraseMode(erase){\r\n        this.eraseMode=erase;\r\n        this.item && (this.item.selectedColor = erase ? 'red' : null);\r\n        this.drawingGroup.selectedColor= erase ? 'red' : null;\r\n        this.toolbarControl.setEraseMode(erase);\r\n    }\r\n    finishCurrentPath(){\r\n        let dr = this.drawing()\r\n        if(!dr || !this.item) return;\r\n        dr.path.closed=true;\r\n        // if(dr.path.parent==this.drawingGroup){\r\n            let result = this.eraseMode ? this.item.subtract(dr.path,{insert:false}) : this.item.unite(dr.path,{insert:false});\r\n            if(result){\r\n                result=result.toCompoundPath();\r\n                if(!this.item.isBoundingElement){\r\n                    let boundingItems = this.item.parent.children.filter(i=>i.isBoundingElement);\r\n                    result.applyBounds(boundingItems);\r\n                }\r\n                this.item.removeChildren();\r\n                this.item.addChildren(result.children);\r\n                this.item.children.forEach(child=>child.selected=false);//only have the parent set selected status\r\n                result.remove();\r\n            }\r\n            this.drawingGroup.removeChildren();\r\n        // }\r\n    }\r\n    saveHistory(){\r\n        //push current state onto history stack\r\n        const historyLength = 10;\r\n        let idx = (this.item.history||[]).position || 0;\r\n        this.item.history=[{\r\n            children:this.item.children.map(x=>x.clone({insert:false,deep:true})),\r\n            drawingGroup:this.drawingGroup.children.map(x=>x.clone({insert:false,deep:true})),\r\n        }].concat((this.item.history||[]).slice(idx,historyLength));\r\n    }\r\n    undo(){\r\n        console.log('undoing');\r\n        let history=(this.item.history||[]);\r\n        let idx = (history.position || 0) +1;\r\n        if(idx<history.length){\r\n            this.drawingGroup.removeChildren();\r\n            this.item.removeChildren();\r\n            this.item.children = history[idx].children.map(x=>x.clone({insert:true,deep:true}));\r\n            this.drawingGroup.children = history[idx].drawingGroup.map(x=>x.clone({insert:true,deep:true}));\r\n            history.position=idx;\r\n        }\r\n    }\r\n    redo(){\r\n        console.log('redoing');\r\n        let history=(this.item.history||[]);\r\n        let idx = (history.position || 0) -1;\r\n        if(idx>=0){\r\n            this.drawingGroup.removeChildren();\r\n            this.item.removeChildren();\r\n            this.item.children = history[idx].children.map(x=>x.clone({insert:true,deep:true}));\r\n            this.drawingGroup.children = history[idx].drawingGroup.map(x=>x.clone({insert:true,deep:true}));\r\n            history.position=idx;\r\n        }\r\n    }\r\n}\r\n\r\nclass PolygonToolbar extends _annotationUITool_mjs__WEBPACK_IMPORTED_MODULE_0__.AnnotationUIToolbarBase{\r\n    constructor(polyTool){\r\n        super(polyTool);\r\n        let self=this;\r\n        let html = $('<i>',{class:'fa-solid fa-draw-polygon'})[0];\r\n        this.button.configure(html,'Polygon Tool');\r\n        \r\n        let fdd=$('<div>',{'data-tool':'polygon',class:'dropdown polygon-toolbar'}).appendTo(this.dropdown);\r\n        $('<span>').appendTo(fdd).text('Click or Drag');\r\n    \r\n        let simplifyDiv=$('<div>').appendTo(fdd);\r\n        this.simplifyButton=$('<button>',{'data-action':'simplify'}).text('Simplify').appendTo(simplifyDiv).on('click',function(){\r\n            polyTool.doSimplify();\r\n        });\r\n        this.eraseButton=$('<button>',{'data-action':'erase'}).text('Eraser').appendTo(fdd).on('click',function(){\r\n            let erasing = $(this).toggleClass('active').hasClass('active');\r\n            polyTool.setEraseMode(erasing);\r\n        });\r\n        let span = $('<span>').appendTo(fdd);\r\n        this.undoButton=$('<button>',{title:'Undo (ctrl-Z)', 'data-action':'undo'}).text('<').appendTo(span).on('click',function(){\r\n            polyTool.undo();\r\n        });\r\n        this.redoButton=$('<button>',{title:'Redo (ctrl-shift-Z)', 'data-action':'redo'}).text('>').appendTo(span).on('click',function(){\r\n            polyTool.redo();\r\n        });\r\n    }\r\n    isEnabledForMode(mode){\r\n        return ['new','MultiPolygon'].includes(mode);\r\n    }\r\n    setEraseMode(erasing){\r\n        erasing ? this.eraseButton.addClass('active') : this.eraseButton.removeClass('active');\r\n    }\r\n}\r\n\r\n\r\n\r\nclass SimplifyJS{\r\n    /*\r\n    Based on:\r\n        Simplify.js, a high-performance JS polyline simplification library\r\n        mourner.github.io/simplify-js\r\n        License: BSD\r\n        Copyright (c) 2017, Vladimir Agafonkin\r\n        All rights reserved.\r\n\r\n        Redistribution and use in source and binary forms, with or without modification, are\r\n        permitted provided that the following conditions are met:\r\n\r\n        1. Redistributions of source code must retain the above copyright notice, this list of\r\n            conditions and the following disclaimer.\r\n\r\n        2. Redistributions in binary form must reproduce the above copyright notice, this list\r\n            of conditions and the following disclaimer in the documentation and/or other materials\r\n            provided with the distribution.\r\n\r\n        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY\r\n        EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n        MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\r\n        COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\r\n        EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n        SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\r\n        HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\r\n        TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n        SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n    */\r\n    constructor(){\r\n\r\n    }\r\n    getSqDist(p1, p2) {\r\n        // square distance between 2 points\r\n        var dx = p1.x - p2.x,\r\n            dy = p1.y - p2.y;\r\n    \r\n        return dx * dx + dy * dy;\r\n    }\r\n    \r\n    getSqSegDist(p, p1, p2) {\r\n        // square distance from a point to a segment\r\n        var x = p1.x,\r\n            y = p1.y,\r\n            dx = p2.x - x,\r\n            dy = p2.y - y;\r\n\r\n        if (dx !== 0 || dy !== 0) {\r\n\r\n            var t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);\r\n\r\n            if (t > 1) {\r\n                x = p2.x;\r\n                y = p2.y;\r\n\r\n            } else if (t > 0) {\r\n                x += dx * t;\r\n                y += dy * t;\r\n            }\r\n        }\r\n\r\n        dx = p.x - x;\r\n        dy = p.y - y;\r\n\r\n        return dx * dx + dy * dy;\r\n    }\r\n\r\n    \r\n    simplifyRadialDist(points, sqTolerance) {\r\n        // basic distance-based simplification\r\n        var prevPoint = points[0],\r\n            newPoints = [prevPoint],\r\n            point;\r\n\r\n        for (var i = 1, len = points.length; i < len; i++) {\r\n            point = points[i];\r\n\r\n            if (this.getSqDist(point, prevPoint) > sqTolerance) {\r\n                newPoints.push(point);\r\n                prevPoint = point;\r\n            }\r\n        }\r\n\r\n        if (prevPoint !== point) newPoints.push(point);\r\n\r\n        return newPoints;\r\n    }\r\n\r\n    simplifyDPStep(points, first, last, sqTolerance, simplified) {\r\n        var maxSqDist = sqTolerance,\r\n            index;\r\n    \r\n        for (var i = first + 1; i < last; i++) {\r\n            var sqDist = this.getSqSegDist(points[i], points[first], points[last]);\r\n    \r\n            if (sqDist > maxSqDist) {\r\n                index = i;\r\n                maxSqDist = sqDist;\r\n            }\r\n        }\r\n    \r\n        if (maxSqDist > sqTolerance) {\r\n            if (index - first > 1) this.simplifyDPStep(points, first, index, sqTolerance, simplified);\r\n            simplified.push(points[index]);\r\n            if (last - index > 1) this.simplifyDPStep(points, index, last, sqTolerance, simplified);\r\n        }\r\n    }\r\n    \r\n    // simplification using Ramer-Douglas-Peucker algorithm\r\n    simplifyDouglasPeucker(points, sqTolerance) {\r\n        var last = points.length - 1;\r\n    \r\n        var simplified = [points[0]];\r\n        this.simplifyDPStep(points, 0, last, sqTolerance, simplified);\r\n        simplified.push(points[last]);\r\n    \r\n        return simplified;\r\n    }\r\n    \r\n    // both algorithms combined for awesome performance\r\n    simplify(points, tolerance, highestQuality) {\r\n    \r\n        if (points.length <= 2) return points;\r\n    \r\n        var sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;\r\n    \r\n        points = highestQuality ? points : this.simplifyRadialDist(points, sqTolerance);\r\n        points = this.simplifyDouglasPeucker(points, sqTolerance);\r\n    \r\n        return points;\r\n    }\r\n}\r\n\r\n\n\n//# sourceURL=webpack://js/../src/js/papertools/polygon.mjs?")},"../src/js/papertools/raster.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RasterTool: () => (/* binding */ RasterTool)\n/* harmony export */ });\n/* harmony import */ var _annotationUITool_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./annotationUITool.mjs */ \"../src/js/papertools/annotationUITool.mjs\");\n\r\nclass RasterTool extends _annotationUITool_mjs__WEBPACK_IMPORTED_MODULE_0__.AnnotationUITool{\r\n    constructor(paperScope){\r\n        super(paperScope);\r\n\r\n        this.setToolbarControl(new RasterToolbar(this));\r\n    }\r\n    rasterize(){\r\n        let self = this;\r\n        let item = this.item;\r\n        if(item){\r\n            let raster = this.project.overlay.osdViewer.getViewportRaster(item.view);\r\n            item.layer.addChild(raster);\r\n            \r\n            raster.onLoad = function(){\r\n                //get the subregion in pixel coordinates of the large raster by inverse transforming the bounding rect of the item\r\n                let offset = new paper.Point(this.width/2,this.height/2);\r\n                let newBounds = new paper.Rectangle(\r\n                    offset.add(this.matrix.inverseTransform(item.bounds.topLeft)).floor(), \r\n                    offset.add(this.matrix.inverseTransform(item.bounds.bottomRight)).ceil()\r\n                );\r\n                \r\n                let subraster = this.getSubRaster(newBounds);\r\n                subraster.selectedColor = null;\r\n                \r\n                let geoJSON = {\r\n                    type:'Feature',\r\n                    geometry:{\r\n                        type:'GeometryCollection',\r\n                        properties:{\r\n                            subtype:'Raster',\r\n                            raster: {\r\n                                data:subraster,\r\n                            },\r\n                        },\r\n                        geometries:[\r\n                            item,\r\n                        ]\r\n                    },\r\n                    properties:{}\r\n                }\r\n\r\n                item.replaceWith(paper.Item.fromGeoJSON(geoJSON));\r\n                self.refreshItems();\r\n\r\n                this.remove();\r\n            }\r\n        }\r\n\r\n    }\r\n    \r\n}\r\nclass RasterToolbar extends _annotationUITool_mjs__WEBPACK_IMPORTED_MODULE_0__.AnnotationUIToolbarBase{\r\n    constructor(tool){\r\n        super(tool);\r\n        let html=$('<i>',{class:'fa fa-image'})[0];\r\n        this.button.configure(html,'Raster Tool');\r\n        let d = $('<div>').appendTo(this.dropdown);\r\n        let button = $('<button>').text('Convert to raster').appendTo(d);\r\n        let span = $('<span>').text('Warning: this cannot be undone!').appendTo(d);\r\n\r\n        button.on('click',()=>tool.rasterize())\r\n    }\r\n    isEnabledForMode(mode){\r\n        return ['MultiPolygon','Point:Rectangle','Point:Ellipse'].includes(mode);\r\n    }\r\n}\n\n//# sourceURL=webpack://js/../src/js/papertools/raster.mjs?")},"../src/js/papertools/rectangle.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RectangleTool: () => (/* binding */ RectangleTool)\n/* harmony export */ });\n/* harmony import */ var _annotationUITool_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./annotationUITool.mjs */ \"../src/js/papertools/annotationUITool.mjs\");\n\r\nclass RectangleTool extends _annotationUITool_mjs__WEBPACK_IMPORTED_MODULE_0__.AnnotationUITool{\r\n    constructor(paperScope){\r\n        super(paperScope);\r\n        let self=this;\r\n\r\n        let crosshairTool = new paper.Group({visible:false});\r\n        let h1 = new paper.Path({segments:[new paper.Point(0,0),new paper.Point(0,0)],strokeScaling:false,strokeWidth:1,strokeColor:'black'});\r\n        let h2 = new paper.Path({segments:[new paper.Point(0,0),new paper.Point(0,0)],strokeScaling:false,strokeWidth:1,strokeColor:'white',dashArray:[6,6]});\r\n        let v1 = new paper.Path({segments:[new paper.Point(0,0),new paper.Point(0,0)],strokeScaling:false,strokeWidth:1,strokeColor:'black'});\r\n        let v2 = new paper.Path({segments:[new paper.Point(0,0),new paper.Point(0,0)],strokeScaling:false,strokeWidth:1,strokeColor:'white',dashArray:[6,6]});\r\n        crosshairTool.addChildren([h1,h2,v1,v2]);\r\n        this.project.toolLayer.addChild(crosshairTool);\r\n        \r\n        this.mode = null;\r\n        this.creating = null;\r\n        \r\n        this.setToolbarControl(new RectToolbar(this));\r\n\r\n        this.tool.onMouseDown=function(ev){\r\n            if(self.itemToCreate){\r\n                self.itemToCreate.initializeGeoJSONFeature('Point', 'Rectangle');\r\n                self.refreshItems();\r\n                \r\n                let r=new paper.Path.Rectangle(ev.point,ev.point);\r\n                self.creating = r;\r\n                self.item.removeChildren();\r\n                self.item.addChild(r);\r\n                self.mode='creating';\r\n            }\r\n            else if(self.item){\r\n                // try hit test on corners first\r\n                let result = self.item.hitTest(ev.point,{fill:false,stroke:false,segments:true,tolerance:5/self.project.getZoom()});\r\n                if(result){\r\n                    // crosshairTool.visible=true;\r\n                    self.mode='corner-drag';\r\n                    let idx=result.segment.path.segments.indexOf(result.segment);\r\n                    let oppositeIdx=(idx+2) % result.segment.path.segments.length;\r\n                    self.refPoint = result.segment.path.segments[oppositeIdx].point;\r\n                    self.ctrlPoint = result.segment.point.clone();\r\n                    return;\r\n                }\r\n                \r\n                // next hit test on \"fill\"\r\n                if(self.item.contains(ev.point)){\r\n                    // crosshairTool.visible=true;\r\n                    self.mode='fill-drag';\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        this.tool.onMouseDrag=function(ev){\r\n            let refPt, currPt, angle;\r\n            let center = self.item.center;\r\n            if(self.mode=='creating'){\r\n                angle = -self.item.view.getRotation();\r\n                refPt = ev.downPoint;\r\n                \r\n                if(ev.modifiers.command || ev.modifiers.control){\r\n                    let delta = ev.point.subtract(ev.downPoint);\r\n                    let axes = [[1,1],[1,-1],[-1,-1],[-1,1]].map(p=>new paper.Point(p[0],p[1]).rotate(angle));\r\n                    let closestAxis = axes.sort( (a, b) => a.dot(delta) - b.dot(delta))[0];\r\n                    let proj = delta.project(closestAxis);\r\n                    currPt = ev.downPoint.add(proj);\r\n                } else {\r\n                    currPt = ev.point;\r\n                }\r\n            } else if(self.mode=='corner-drag'){\r\n                angle = self.item.children[0].segments[1].point.subtract(self.item.children[0].segments[0].point).angle;\r\n                refPt = self.refPoint;\r\n\r\n                if(ev.modifiers.command || ev.modifiers.control){\r\n                    let delta = ev.point.subtract(self.refPoint);\r\n                    let axis = self.ctrlPoint.subtract(self.refPoint);\r\n                    let proj = delta.project(axis);\r\n                    currPt = self.refPoint.add(proj);\r\n                } else {\r\n                    currPt = ev.point;\r\n                }\r\n            } else if(self.mode == 'fill-drag') {\r\n                self.item.translate(ev.delta);\r\n                return;\r\n            } else{\r\n                setCursorPosition(this,ev.point);\r\n                return;\r\n            }\r\n            setCursorPosition(this,currPt);\r\n            let r=new paper.Rectangle(refPt.rotate(-angle,center),currPt.rotate(-angle, center));\r\n            let corners = [r.topLeft, r.topRight, r.bottomRight, r.bottomLeft].map(p=>p.rotate(angle,center));\r\n            self.item.children[0].set({segments:corners})\r\n        }\r\n        this.tool.onMouseMove=function(ev){\r\n            setCursorPosition(this,ev.point);\r\n            if(self.mode == 'modifying'){\r\n                let hitResult = self.item.hitTest(ev.point,{fill:false,stroke:false,segments:true,tolerance:5/self.project.getZoom()});\r\n                if(hitResult){\r\n                    self.project.overlay.addClass('rectangle-tool-resize');\r\n                } else{\r\n                    self.project.overlay.removeClass('rectangle-tool-resize');\r\n                }\r\n\r\n                if(self.item.contains(ev.point)){\r\n                    self.project.overlay.addClass('rectangle-tool-move');\r\n                } else {\r\n                    self.project.overlay.removeClass('rectangle-tool-move');\r\n                }\r\n            }\r\n        }\r\n        this.tool.onMouseUp = function(){\r\n            self.mode='modifying';\r\n            crosshairTool.visible=false;\r\n            self.creating=null;\r\n            self.toolbarControl.updateInstructions('Point:Rectangle');\r\n        }\r\n        this.extensions.onActivate = this.onSelectionChanged = function(){\r\n            if(self.itemToCreate){\r\n                self.mode='creating';\r\n                crosshairTool.visible = true;\r\n                self.creating = null;//reset reference to actively creating item\r\n                self.toolbarControl.updateInstructions('new');\r\n            }\r\n            else if(self.creating && self.creating.parent==self.item){\r\n                self.mode='creating';\r\n                crosshairTool.visible = true;\r\n                self.toolbarControl.updateInstructions('new');\r\n            }\r\n            else if (self.item){\r\n                self.creating=null;//reset reference to actively creating item\r\n                self.mode='modifying';\r\n                crosshairTool.visible = false;\r\n                self.toolbarControl.updateInstructions('Point:Rectangle');\r\n            }\r\n            else {\r\n                // self.creating=null;//reset reference to actively creating item\r\n                // self.mode=null;\r\n                // crosshairTool.visible = false;\r\n                // self.toolbarControl.updateInstructions('Point:Rectangle');\r\n                self.deactivate();\r\n            }\r\n        }\r\n        this.extensions.onDeactivate = function(finished){\r\n            if(finished) self.creating = null;\r\n            crosshairTool.visible=false;\r\n            self.mode=null;\r\n            self.project.overlay.removeClass('rectangle-tool-resize');\r\n        }\r\n\r\n        function setCursorPosition(tool,point){\r\n            //to do: account for view rotation\r\n            // let viewBounds=tool.view.bounds;\r\n            let pt = tool.view.projectToView(point);\r\n            let left=tool.view.viewToProject(new paper.Point(0, pt.y))\r\n            let right=tool.view.viewToProject(new paper.Point(tool.view.viewSize.width, pt.y))\r\n            let top=tool.view.viewToProject(new paper.Point(pt.x, 0))\r\n            let bottom=tool.view.viewToProject(new paper.Point(pt.x,tool.view.viewSize.height))\r\n            // console.log(viewBounds)\r\n            h1.segments[0].point = left;\r\n            h2.segments[0].point = left;\r\n            h1.segments[1].point = right;\r\n            h2.segments[1].point = right;\r\n            v1.segments[0].point = top;\r\n            v2.segments[0].point = top;\r\n            v1.segments[1].point = bottom;\r\n            v2.segments[1].point = bottom;\r\n        }\r\n    }\r\n    \r\n}\r\nclass RectToolbar extends _annotationUITool_mjs__WEBPACK_IMPORTED_MODULE_0__.AnnotationUIToolbarBase{\r\n    constructor(tool){\r\n        super(tool);\r\n        let html = $('<i>',{class:'fa-solid fa-vector-square'})[0];\r\n        this.button.configure(html,'Rectangle Tool');\r\n        this.instructions = $('<span>').text('Click and drag to create a rectangle').appendTo(this.dropdown);\r\n    }\r\n    isEnabledForMode(mode){\r\n        return ['new','Point:Rectangle'].includes(mode);\r\n    }\r\n    updateInstructions(mode){\r\n        this.instructions.text(mode=='new'?'Click and drag to create a rectangle' : mode=='Point:Rectangle' ? 'Drag a corner to resize' : '???' )\r\n    }\r\n}\n\n//# sourceURL=webpack://js/../src/js/papertools/rectangle.mjs?")},"../src/js/papertools/select.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SelectTool: () => (/* binding */ SelectTool)\n/* harmony export */ });\n/* harmony import */ var _annotationUITool_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./annotationUITool.mjs */ \"../src/js/papertools/annotationUITool.mjs\");\n\r\nclass SelectTool extends _annotationUITool_mjs__WEBPACK_IMPORTED_MODULE_0__.AnnotationUITool{\r\n    constructor(paperScope){\r\n        super(paperScope);\r\n        let self=this;\r\n        this.ps = this.project.paperScope;\r\n        this.setToolbarControl(new SelectToolbar(this));\r\n\r\n        let selectionRectangle = new paper.Path.Rectangle({strokeWidth:1,rescale:{strokeWidth:1},strokeColor:'black'});\r\n        let sr2 = new paper.Path.Rectangle({strokeWidth:1,dashArray:[10,10],rescale:{strokeWidth:1,dashArray:[10,10]},strokeColor:'white'});\r\n        this.project.toolLayer.addChild(selectionRectangle);\r\n        this.project.toolLayer.addChild(sr2);\r\n        selectionRectangle.applyRescale();\r\n        sr2.applyRescale();\r\n        selectionRectangle.visible=false;\r\n        sr2.visible=false;\r\n        \r\n        this.extensions.onActivate=function(){ \r\n            self.tool.onMouseMove = (ev)=>self.onMouseMove(ev);\r\n        }    \r\n        this.extensions.onDeactivate=function(shouldFinish){\r\n            self.project.overlay.removeClass('selectable-layer');\r\n            self.tool.onMouseMove = null;\r\n        }\r\n        this.tool.extensions.onKeyUp=function(ev){\r\n            if(ev.key=='escape'){\r\n                self.project.paperScope.findSelectedItems().forEach(item=>item.deselect());\r\n            }\r\n        }\r\n       \r\n        this.tool.onMouseUp=function(ev){\r\n            selectionRectangle.visible=false;\r\n            sr2.visible=false;\r\n            if(ev.downPoint.subtract(ev.point).length==0){\r\n                //not a click-and-drag, do element selection\r\n                let hitResult = self.hitTestPoint(ev);\r\n                hitResult && hitResult.item.toggle((ev.modifiers.control || ev.modifiers.meta));\r\n                \r\n            }\r\n            else{\r\n                //click and drag, do area-based selection\r\n                let hitResults = self.hitTestArea(ev);\r\n                let keepExistingSelection = (ev.modifiers.control || ev.modifiers.meta);\r\n                if(!keepExistingSelection){\r\n                    self.project.paperScope.findSelectedItems().forEach(item=>item.deselect());\r\n                }\r\n                hitResults.forEach(item=>item.select(true))\r\n            }\r\n        }\r\n        this.tool.onMouseDrag = function(ev){\r\n            selectionRectangle.visible=true;\r\n            sr2.visible=true;\r\n            let r=new paper.Rectangle(ev.downPoint,ev.point);\r\n            selectionRectangle.set({segments:[r.topLeft, r.topRight, r.bottomRight, r.bottomLeft]});\r\n            sr2.set({segments:[r.topLeft, r.topRight, r.bottomRight, r.bottomLeft]});\r\n            // console.log(selectionRectangle.visible, selectionRectangle.segments)\r\n        }\r\n    }\r\n    getSelectedItems(){\r\n        return this.ps.project.selectedItems.filter(i=>i.isGeoJSONFeature);\r\n    }\r\n    doAnnotationItemsExist(){\r\n        return this.ps.project.getItems({match:i=>i.isGeoJSONFeature}).length>0; \r\n    }\r\n    \r\n    onMouseMove(ev){\r\n        if(ev.item){\r\n            if(this.currentItem != ev.item) (ev.item.emit('selection:mouseenter')||true) \r\n            if(this.currentLayer != ev.item.layer) ev.item.layer.emit('selection:mouseenter');\r\n            this.currentItem = ev.item;\r\n            this.currentLayer = this.currentItem.layer;\r\n            this.project.overlay.addClass('selectable-layer')\r\n        }\r\n        else{\r\n            this.currenItem && (this.currentItem.emit('selection:mouseleave',ev)||true) \r\n            this.currentLayer && this.currentLayer.emit('selection:mouseleave',ev);\r\n            this.project.overlay.removeClass('selectable-layer')\r\n            this.currentItem = null;\r\n            this.currentLayer = null;\r\n        }   \r\n    }\r\n    hitTestPoint(ev){\r\n        let hitResult = this.ps.project.hitTest(ev.point,{\r\n            fill:true,\r\n            stroke:true,\r\n            segments:true,\r\n            tolerance:(5/this.project.getZoom()),\r\n            match:i=>i.item.isGeoJSONFeature || i.item.parent.isGeoJSONFeature,\r\n        })\r\n        if(hitResult && !hitResult.item.isGeoJSONFeature){\r\n            hitResult.item = hitResult.item.parent;\r\n        }\r\n        return hitResult;\r\n    }\r\n    hitTestArea(ev,onlyFullyContained){\r\n        let options = {\r\n            match:item=>item.isGeoJSONFeature,\r\n        }\r\n        let testRectangle=new paper.Rectangle(ev.point,ev.downPoint);\r\n        if(onlyFullyContained){\r\n            options.inside=testRectangle;\r\n        }\r\n        else{\r\n            options.overlapping=testRectangle;\r\n        }\r\n        let hitResult = this.ps.project.getItems(options);\r\n        return hitResult;\r\n    }\r\n}\r\n\r\nclass SelectToolbar extends _annotationUITool_mjs__WEBPACK_IMPORTED_MODULE_0__.AnnotationUIToolbarBase{\r\n    constructor(tool){\r\n        super(tool);\r\n        $(this.dropdown).addClass('select-dropdown');\r\n        let html = $('<i>',{class:'fa-solid fa-arrow-pointer'})[0];\r\n        this.button.configure(html,'Selection Tool');\r\n        \r\n        let s = $('<div>',{'data-active':'select'}).appendTo(this.modeRow)\r\n        $('<span>').text('(Ctrl)click to select items.').appendTo(s);\r\n        \r\n    }\r\n    isEnabledForMode(mode){\r\n        let itemsExist = this.tool.doAnnotationItemsExist();\r\n        return itemsExist && [\r\n            'default',\r\n            'select',\r\n            'multiselection',\r\n            'MultiPolygon',\r\n            'Point:Rectangle',\r\n            'Point','LineString',\r\n            'GeometryColletion:Raster',\r\n        ].includes(mode);\r\n    }\r\n    \r\n}\n\n//# sourceURL=webpack://js/../src/js/papertools/select.mjs?")},"../src/js/papertools/style.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ColorpickerCursor: () => (/* binding */ ColorpickerCursor),\n/* harmony export */   StyleTool: () => (/* binding */ StyleTool),\n/* harmony export */   StyleToolbar: () => (/* binding */ StyleToolbar),\n/* harmony export */   getAverageColor: () => (/* binding */ getAverageColor)\n/* harmony export */ });\n/* harmony import */ var _annotationUITool_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./annotationUITool.mjs */ \"../src/js/papertools/annotationUITool.mjs\");\n\r\nclass StyleTool extends _annotationUITool_mjs__WEBPACK_IMPORTED_MODULE_0__.AnnotationUITool{\r\n    constructor(paperScope){\r\n        super(paperScope);\r\n        let self =  this;\r\n        let tool = this.tool;\r\n        this._ignoreNextSelectionChange=false;\r\n        this._targetItems = [];\r\n        \r\n        this.setToolbarControl(new StyleToolbar(this));\r\n\r\n        let cursorGridSize=9;//this must be an odd number so the grid is symmetric around a center cell\r\n        let cursorCellSize=12;\r\n        this.colorpicker = new ColorpickerCursor(cursorCellSize,cursorGridSize,this.project.toolLayer);\r\n        this.cursor = this.colorpicker.element;\r\n        this.cursor.applyRescale();\r\n\r\n        this.extensions.onActivate = function(){ console.log('style tool onActivate')\r\n            if(self.pickingColor){\r\n                self.project.overlay.addClass('tool-action').setAttribute('data-tool-action','colorpicker');\r\n                self.cursor.visible=true;\r\n            }\r\n            self.selectionChanged();//set initial list of selected items\r\n            // self.tool.captureUserInput(!!self.pickingColor);\r\n            self.captureUserInput(!!self.pickingColor);\r\n        };\r\n        this.extensions.onDeactivate = function(finished){  console.log('style tool onDeactivate')\r\n            self.project.overlay.removeClass('tool-action').setAttribute('data-tool-action','');\r\n            self.cursor.visible=false;\r\n            if(finished){\r\n                self.cancelColorpicker();\r\n            }\r\n        };\r\n\r\n        tool.extensions.onKeyUp=function(ev){\r\n            if(ev.key=='escape'){\r\n                self.cancelColorpicker();\r\n            }\r\n        }\r\n        tool.onMouseMove=function(ev){            \r\n            if(self.pickingColor){\r\n                self.colorpicker.updatePosition(ev.point);\r\n                              \r\n            }\r\n        }\r\n        tool.onMouseUp=function(ev){\r\n            if(self.pickingColor && self.cursor.visible){\r\n                self._colorpickerPromise && self._colorpickerPromise.resolve(self.colorpicker.selectedColor);\r\n                self._colorpickerPromise = null;\r\n                self.cancelColorpicker();\r\n            }\r\n        }\r\n\r\n        this.project.paperScope.project.on('edit-style',ev=>{\r\n            this.activateForItem(ev.item);\r\n        })\r\n    }\r\n    activateForItem(item){\r\n        this.targetItems = item;\r\n        this._ignoreNextSelectionChange=true;\r\n        this.activate();\r\n        this.toolbarControl.updateDisplay();\r\n        this._ignoreNextSelectionChange=false;\r\n        // console.log('finished activateForItem')\r\n    }\r\n    onSelectionChanged(){\r\n        if(!this._ignoreNextSelectionChange){\r\n            // console.log('onSelctionChanged handled')\r\n            this.targetItems = this.items;\r\n            this.toolbarControl.updateDisplay();\r\n        }\r\n        else{\r\n            // console.log('onSelctionChanged ignored')\r\n        }\r\n        this._ignoreNextSelectionChange=false;\r\n    }\r\n    get defaultTarget(){\r\n        return this.project.paperScope.project;\r\n    }\r\n    get targetItems(){\r\n        // return this._targetItems.map(item=>item.defaultStyle || item)\r\n        return this._targetItems;\r\n    }\r\n    set targetItems(target){\r\n        this._targetItems= target ? [target].flat().filter(t=>t.defaultStyle||t.style) : [];\r\n        if(this._targetItems.length==0) this._targetItems=[this.defaultTarget];\r\n    }\r\n    get targetItemStyles(){\r\n        return this._targetItems.map(item=>item.defaultStyle || item.style);\r\n    }\r\n    get targetDescription(){\r\n        if(this._targetItems.length==0){\r\n            return \"No target\";\r\n        }\r\n        else if(this._targetItems.length>1){\r\n            return `${this._targetItems.length} items`;\r\n        }\r\n        else{\r\n            let t = this._targetItems[0];\r\n            return t==this.defaultTarget ? 'Default style' : t.displayName;\r\n        }\r\n    }\r\n    \r\n    pickColor(){\r\n        let self=this;\r\n        self.captureUserInput(true);\r\n        return new Promise(function(resolve,reject){\r\n            self._colorpickerPromise && self._colorpickerPromise.reject('Canceled');\r\n            self._colorpickerPromise = {resolve:resolve, reject:reject};\r\n            self.activate();\r\n            self.pickingColor=true;\r\n            self.cursor.visible=true;\r\n            // self.cursor.addTo(self.project.paperScope.project.activeLayer);\r\n            self.project.paperScope.project.layers.toolLayer.bringToFront();\r\n            self.tool.onMouseMove({point:self.cursor.view.center});\r\n            self.project.overlay.addClass('tool-action').setAttribute('data-tool-action','colorpicker');\r\n        }).finally(()=>{\r\n            self.captureUserInput(false);\r\n        })\r\n\r\n    }\r\n    \r\n    cancelColorpicker(){\r\n        // console.log('canceling colorpicker')\r\n        this.cursor.addTo(this.project.toolLayer);\r\n        this.pickingColor=false;\r\n        this.cursor.visible = false;            \r\n        this.project.overlay.removeClass('tool-action').setAttribute('data-tool-action','');\r\n        \r\n        this._colorpickerPromise && this._colorpickerPromise.reject('Canceled');\r\n    }\r\n    createMaskedImage(item){\r\n        let mask = item.clone();\r\n        let grp = new paper.Group([mask]);\r\n        // console.log('itemToAverage',itemToAverage);\r\n        let imgrect=this.project.overlay.osdViewer.viewport.viewportToViewerElementRectangle(this.project.overlay.osdViewer.world.getItemAt(0).getBounds());\r\n        let viewrect=this.project.overlay.osdViewer.viewport.viewportToViewerElementRectangle(this.project.overlay.osdViewer.viewport.getBounds());\r\n        let x = Math.floor(Math.max(imgrect.x, viewrect.x))-1;\r\n        let y = Math.floor(Math.max(imgrect.y, viewrect.y))-1;\r\n        let w = Math.ceil(Math.min(viewrect.x+viewrect.width, imgrect.x+imgrect.width))-x+2;\r\n        let h = Math.ceil(Math.min(viewrect.y+viewrect.height, imgrect.y+imgrect.height))-y+2;\r\n\r\n        let mb = this.project.paperScope.view.projectToView(mask.bounds)\r\n        let mx = mb.x;\r\n        let my = mb.y;\r\n        let mw = mask.bounds.width * this.project.getZoom();\r\n        let mh = mask.bounds.height * this.project.getZoom();\r\n        \r\n        //Deal with pixel ratio other than one\r\n        let r = this.project.paperScope.view.pixelRatio;\r\n        let newcanvas = $('<canvas>').attr({width:mw*r,height:mh*r})[0];\r\n        newcanvas.getContext('2d').drawImage(this.project.overlay.osdViewer.drawer.canvas,mx*r,my*r,mw*r,mh*r,0,0,mw*r,mh*r);\r\n        let dataurl = newcanvas.toDataURL();\r\n        let raster = new paper.Raster({source:dataurl,position:mask.bounds.center});\r\n        raster.scale(1/(r*this.project.getZoom()));\r\n        grp.addChild(raster);\r\n        grp.clipped=true;\r\n        grp.position.x = grp.position.x+500;\r\n        return grp;   \r\n    }\r\n    applyStrokeWidth(value){\r\n        // console.log('applyStrokeWidth',this.targetItems,value);\r\n        this.targetItems.forEach(item=>{\r\n            if(item.defaultStyle) item=item.defaultStyle;\r\n\r\n            item.strokeWidth = value;\r\n            item.rescale && (item.rescale.strokeWidth = value);\r\n\r\n            //for annotation items, update the config object and apply rescale\r\n            if(item.isGeoJSONFeature){\r\n                item.applyRescale();\r\n            }\r\n            \r\n        })\r\n    }\r\n    applyOpacity(opacity,property){\r\n        this.targetItems.forEach(item=>{\r\n            let style = item.defaultStyle || item.style;\r\n            style[property]=opacity;\r\n            if(item.isGeoJSONFeature){\r\n                item.updateFillOpacity();\r\n            }\r\n        });\r\n    }\r\n    applyColor(value,type,item){\r\n        if(type=='fill') this.applyFillColor(value,item);\r\n        else if(type=='stroke') this.applyStrokeColor(value,item);\r\n        else console.warn(`Cannot apply color change - type \"${type}\" not recognized`)\r\n    }\r\n    applyFillColor(value,item){\r\n        (item?[item]:this.targetItems).forEach(item=>{\r\n            let color = new paper.Color(value);\r\n            let style = item.defaultStyle || item.style;\r\n            style.fillColor = color;\r\n            \r\n            if(item.isGeoJSONFeature){\r\n                item.updateFillOpacity();\r\n            }\r\n        })\r\n        \r\n    }\r\n    applyStrokeColor(value,item){\r\n        (item?[item]:this.targetItems).forEach(item=>{\r\n            let color = new paper.Color(value);\r\n            let style = item.defaultStyle || item.style;\r\n            // style.strokeColor && (color.alpha = style.strokeColor.alpha);\r\n            style.strokeColor = color;\r\n            if(item.isGeoJSONFeature){\r\n                // item.config.properties.strokeColor = item.strokeColor;\r\n                item.updateStrokeOpacity();\r\n            }\r\n        })\r\n        \r\n    }\r\n\r\n}\r\n\r\nclass StyleToolbar extends _annotationUITool_mjs__WEBPACK_IMPORTED_MODULE_0__.AnnotationUIToolbarBase{\r\n    constructor(tool){\r\n        super(tool);\r\n        let self=this;\r\n        let html = $('<i>',{class:'fa-solid fa-palette'})[0];\r\n        this.button.configure(html,'Style Tool');\r\n        $(this.dropdown).append(this.uiHTML());\r\n        this._hierarchy = [];\r\n\r\n        $(this.dropdown).find('[data-action=\"pick-color\"]').on('click',function(){\r\n            let type = $(this).data('type');\r\n            let colorinput = $(self.dropdown).find(`input[type=\"color\"][data-type=\"${type}\"]`);\r\n            $(self.dropdown).find('[data-action=\"pick-color\"]').removeClass('active');\r\n            if(colorinput.is(':visible')){\r\n                $(self.dropdown).find('.colorpicker-row').addClass('hidden');\r\n            }\r\n            else{\r\n                $(self.dropdown).find('.colorpicker-row').addClass('hidden');\r\n                colorinput.closest('.colorpicker-row').removeClass('hidden');\r\n                $(this).addClass('active');\r\n            }\r\n        })\r\n\r\n        $(this.dropdown).find('input[type=\"color\"]').on('input',function(){\r\n            let type = $(this).data('type');\r\n            self.tool.applyColor(this.value,type);\r\n            type=='fill' && self.setFillButtonColor(new paper.Color(this.value))\r\n            type=='stroke' && self.setStrokeButtonColor(new paper.Color(this.value))\r\n        });\r\n        $(this.dropdown).find('input[type=\"number\"]').on('input',function(){\r\n            console.log('number input',this.value)\r\n            self.tool.applyStrokeWidth(this.value);\r\n        })\r\n        $(this.dropdown).find('input[data-action=\"opacity\"]').on('input',function(){\r\n            let type = $(this).data('type');\r\n            let prop = $(this).data('property');\r\n            self.tool.applyOpacity(this.value,prop);\r\n            type=='fill' && self.setFillButtonOpacity(this.value);\r\n            type=='stroke' && self.setStrokeButtonOpacity(this.value);\r\n        })\r\n        $(this.dropdown).find('[data-action=\"from-image\"]').on('click',function(){\r\n            self.tool.pickColor().then((color)=>{\r\n                $(this).siblings('input[type=\"color\"]').val(color.toCSS(true)).trigger('input');\r\n            }).catch(error=>{});\r\n        });\r\n        $(this.dropdown).find('[data-action=\"from-average\"]').on('click',function(){\r\n            let type = $(this).data('type');\r\n            self.fromAverage(type);\r\n        });\r\n        $(this.dropdown).find('.style-item').on('click',function(){\r\n            let items = self.tool.targetItems;\r\n            console.log('Style item clicked',items)\r\n            let allSelected = items.every(item=>item.selected);\r\n            // let selectableItems = items.filter(item=>item.select);\r\n            let selectableItems = items.filter(item=>item.isGeoJSONFeature);\r\n            if(selectableItems.length > 0){\r\n                self.tool._ignoreNextSelectionChange = true;\r\n                selectableItems.forEach(item=>allSelected ? item.deselect() : item.select());//select all if not all selected, else unselect all\r\n            }\r\n            self.updateTargetDescription();\r\n        })\r\n        $(this.dropdown).find('.hierarchy-up').on('click',function(){\r\n            if(self._hierarchy && self._hierarchy.length>0){\r\n                self._hierarchy.index = (self._hierarchy.index+1) % self._hierarchy.length;\r\n            }\r\n            else{\r\n                let items = self.tool.targetItems;\r\n                let layers = new Set(items.map(item=>item.hierarchy.filter(i=>i.isGeoJSONFeatureCollection && i!==item)).flat());\r\n                if(layers.size==0){\r\n                    //this happens if a layer was directly selected, or if the default target was directly selected\r\n                    if(items.indexOf(self.tool.defaultTarget)>-1){\r\n                        self._hierarchy=[self.tool.defaultTarget];\r\n                        self._hierarchy.index=0;\r\n                    }\r\n                    else{\r\n                        self._hierarchy=[items, self.tool.defaultTarget];\r\n                        self._hierarchy.index=1;\r\n                    }\r\n                }\r\n                else if(layers.size==1){\r\n                    //this happens if children of exactly one annotation layer are the target\r\n                    self._hierarchy = [self.tool.targetItems, layers.values().next().value, self.tool.defaultTarget];\r\n                    self._hierarchy.index = 1;\r\n                }\r\n                else{\r\n                    //this happens if children of more than one layer are selected\r\n                    self._hierarchy = [self.tool.targetItems, self.tool.defaultTarget];\r\n                    self._hierarchy.index = 1;\r\n                }\r\n\r\n            }\r\n            let hierarchyRef = self._hierarchy;\r\n            self.tool.activateForItem(self._hierarchy[self._hierarchy.index]);\r\n            self._hierarchy = hierarchyRef;//on activation this variable is cleared; reset here\r\n            // console.log('Hierarchy up',items)\r\n        })\r\n    }\r\n    \r\n    fromAverage(type){\r\n        console.log('fromAverage called')\r\n        let self=this;\r\n        let promises = this.tool.targetItems.map(item=>{\r\n            return getAverageColor(item).then( (color)=> {\r\n                // console.log('color calculated',color,item)\r\n                self.tool.applyColor(color,type,item);\r\n            }) \r\n        });\r\n        Promise.all(promises).then(()=>self.updateDisplay());\r\n    }\r\n    isEnabledForMode(mode){\r\n        return true;\r\n    }\r\n    uiHTML(){\r\n        let html=`\r\n            <div class=\"style-toolbar\">\r\n                <div class=\"flex-row style-row annotation-ui-buttonbar\" >\r\n                    <span><span class=\"hierarchy-up fa-solid fa-sitemap\" title='Cycle through hierarchy'></span><span class='style-item' title='Toggle selection'></span></span>\r\n                    <span class='btn' data-action=\"pick-color\" data-type=\"fill\"><span class=\"preview\"><span class=\"color bg\"></span><span class=\"color text\">Fill</span></span></span>\r\n                    <span class='btn' data-action=\"pick-color\" data-type=\"stroke\"><span class=\"preview\"><span class=\"color bg\"></span><span class=\"color text\">Stroke</span></span></span>\r\n                    <input type=\"number\" min=0 value=1>\r\n                </div>\r\n                <div class=\"colorpicker-row hidden\">\r\n                    <input type=\"color\" data-action=\"color\" data-type=\"fill\">\r\n                    <input type=\"range\" data-action=\"opacity\" data-type=\"fill\" data-property=\"fillOpacity\" min=0 max=1 step=0.01 value=1>\r\n                    <span class='btn' data-action=\"from-image\">From image</span>\r\n                    <span class='btn' data-action=\"from-average\" data-type=\"fill\">Area average</span>\r\n                </div>\r\n                <div class=\"colorpicker-row hidden\">\r\n                    <input type=\"color\" data-action=\"color\" data-type=\"stroke\">\r\n                    <input type=\"range\" data-action=\"opacity\" data-type=\"stroke\" data-property=\"strokeOpacity\" min=0 max=1 step=0.01 value=1>\r\n                    <span class='btn' data-action=\"from-image\">From image</span>\r\n                    <span class='btn' data-action=\"from-average\" data-type=\"stroke\">Area average</span>\r\n                </div>\r\n            </div>\r\n        `;\r\n        return html;\r\n    }\r\n    updateTargetDescription(){\r\n        let targetDescription = this.tool.targetDescription;\r\n        let allSelected = this.tool.targetItems.every(item=>item.selected && item.isGeoJSONFeature);\r\n        let element = $(this.dropdown).find('.style-item').text(targetDescription);\r\n        allSelected ? element.addClass('selected') : element.removeClass('selected');\r\n    }\r\n    updateDisplay(){\r\n        this._hierarchy = [];\r\n        let targets = this.tool.targetItemStyles;\r\n        // console.log('Style toolbar update display',targets)\r\n        this.updateTargetDescription();\r\n\r\n        let fillColor = targets.map(item=>item.fillColor);\r\n        if(fillColor.length==1 || new Set(fillColor.map(c=>c.toCSS())).size == 1){\r\n            this.setFillButtonColor(fillColor[0])\r\n        }\r\n        else{\r\n            // console.warn('Multiple colors not implemented')\r\n            this.setFillButtonColor();\r\n        }\r\n        \r\n        let strokeColor = targets.map(item=>item.strokeColor);\r\n        if(strokeColor.length==1 || new Set(strokeColor.map(c=>c.toCSS())).size == 1){\r\n            this.setStrokeButtonColor(strokeColor[0])\r\n        }\r\n        else{\r\n            // console.warn('Multiple colors not implemented')\r\n            this.setStrokeButtonColor();\r\n        }\r\n\r\n        let fillOpacity = targets.map(item=>item.fillOpacity);\r\n        if(fillOpacity.length==1 || new Set(fillOpacity).size==1){\r\n            this.setFillButtonOpacity(fillOpacity[0])\r\n        }\r\n        else{\r\n            // console.warn('Multiple opacities not implemented; setting to 1');\r\n            this.setFillButtonOpacity(1);\r\n        }\r\n        let strokeOpacity = targets.map(item=>item.strokeOpacity);\r\n        if(strokeOpacity.length==1 || new Set(strokeOpacity).size==1){\r\n            this.setStrokeButtonOpacity(strokeOpacity[0])\r\n        }\r\n        else{\r\n            // console.warn('Multiple opacities not implemented; setting to 1');\r\n            this.setStrokeButtonOpacity(1);\r\n        }\r\n        let strokeWidth = targets.map(item=>item.rescale ? item.rescale.strokeWidth : item.strokeWidth);\r\n        if(strokeWidth.length==1 || new Set(strokeWidth).size==1){\r\n            $(this.dropdown).find('input[type=\"number\"]').val(strokeWidth[0]);\r\n        }\r\n        else{\r\n            // console.warn('Multiple stroke widths not implemented; clearing input')\r\n            $(this.dropdown).find('input[type=\"number\"]').val('');\r\n        }\r\n    }\r\n    setFillButtonColor(color = new paper.Color('white')){\r\n        // let val = color ? color.toCSS(true) : 'none';\r\n        // let textcolor = color ? getContrastYIQ(color.toCSS(true)) : 'black';\r\n        if(!color) color = new paper.Color('white');\r\n        let val = color.toCSS(true);\r\n        let textcolor = getContrastYIQ(color.toCSS(true));\r\n        $(this.dropdown).find('[data-type=\"fill\"] .preview .text').css({color:textcolor});\r\n        $(this.dropdown).find('[data-type=\"fill\"] .preview .color').css({'background-color':val,'outline-color':textcolor});\r\n        $(this.dropdown).find('input[type=\"color\"][data-type=\"fill\"]').val(val);\r\n    }\r\n    setStrokeButtonColor(color = new paper.Color('black')){\r\n        // let val = color ? color.toCSS(true) : 'none';\r\n        // let textcolor = color ? getContrastYIQ(color.toCSS(true)) : 'black';\r\n        if(!color) color = new paper.Color('black');\r\n        let val = color.toCSS(true);\r\n        let textcolor = getContrastYIQ(color.toCSS(true));\r\n        $(this.dropdown).find('[data-type=\"stroke\"] .preview .text').css({color:textcolor});\r\n        $(this.dropdown).find('[data-type=\"stroke\"] .preview .color').css({'background-color':val,'outline-color':textcolor});\r\n        $(this.dropdown).find('input[type=\"color\"][data-type=\"stroke\"]').val(val);\r\n    }\r\n    setFillButtonOpacity(val){\r\n        $(this.dropdown).find('[data-type=\"fill\"] .preview .bg').css({'opacity':val});\r\n        $(this.dropdown).find('[data-type=\"fill\"][data-action=\"opacity\"]').val(val);\r\n    }\r\n    setStrokeButtonOpacity(val){\r\n        $(this.dropdown).find('[data-type=\"stroke\"] .preview .bg').css({'opacity':val});\r\n        $(this.dropdown).find('[data-type=\"stroke\"][data-action=\"opacity\"]').val(val);\r\n    }\r\n}\r\n\r\nfunction ColorpickerCursor(cursorCellSize,cursorGridSize,parent){\r\n    let cursor = new paper.Group({visible:false, applyMatrix:false});\r\n    this.element = cursor;\r\n    parent.addChild(cursor);\r\n    //desired rotation is negative of view rotation value\r\n    cursor.view.on('rotate',ev=>cursor.rotate(-ev.rotatedBy));\r\n    cursor.numRows=cursorGridSize;\r\n    cursor.numColumns=cursorGridSize;\r\n\r\n    let canvas = document.createElement('canvas');\r\n    canvas.height = cursor.numRows;\r\n    canvas.width = cursor.numColumns;\r\n    let ctx = canvas.getContext(\"2d\",{willReadFrequently: true});\r\n    \r\n    let s = cursorCellSize;\r\n    let min=-((cursorGridSize-1)/2);\r\n    let max=min+cursorGridSize;\r\n    for(var y=min;y<max;y++){\r\n        for(var x=min;x<max;x++){\r\n            let r = new paper.Shape.Rectangle({point:[x*s,y*s],size:[s,s],strokeWidth:0.5,strokeColor:'white',fillColor:'white',\r\n            rescale:{position:[x*s,y*s],size:[s,s],strokeWidth:0.5}});\r\n            cursor.addChild(r);\r\n            if(x==0 && y==0) cursor.centerCell = r;\r\n        }\r\n    }\r\n    //add darker thicker border for central \"selected\" spot\r\n    var x = 0, y = 0;\r\n    let c = new paper.Shape.Rectangle({point:[x*s,y*s],size:[s,s],strokeWidth:1,strokeColor:'black',fillColor:null,\r\n    rescale:{position:[x*s,y*s],size:[s,s],strokeWidth:1}});\r\n    cursor.addChild(c);\r\n\r\n    //add a background rectangle surrounding the whole cursor to show the selected color\r\n    var x = 0, y = 0;\r\n    let sz=cursorCellSize*(cursorGridSize+2);//border= 1 cell thick\r\n    let b = new paper.Shape.Rectangle({point:[x*s,y*s],size:[sz,sz],strokeWidth:1,strokeColor:'black',fillColor:null,\r\n    rescale:{position:[x*s,y*s],size:[sz,sz],strokeWidth:1}});\r\n    cursor.addChild(b);\r\n    cursor.borderElement=b;\r\n    b.sendToBack();//this sets b as the first child, requiring 1-based indexing of grid in mousemove handler\r\n    cursor.applyRescale = function(){cursor.children.forEach(child=>child.applyRescale());}\r\n\r\n    this.updatePosition = function(point){\r\n        cursor.position=point;\r\n\r\n        let o = cursor.project.overlay.osdViewer.viewport.imageToViewerElementCoordinates(new OpenSeadragon.Point(point.x, point.y));\r\n        let x = Math.round(o.x)-Math.floor(cursor.numColumns/2);\r\n        let y = Math.round(o.y)-Math.floor(cursor.numRows/2);\r\n        let w = cursor.numColumns;\r\n        let h = cursor.numRows;\r\n        let r = cursor.view.pixelRatio            \r\n        let imdata = cursor.project.overlay.osdViewer.getImageData(x*r,y*r,w*r,h*r);\r\n        ctx.clearRect(0, 0, w, h);\r\n        window.createImageBitmap(imdata).then(bitmap=>{\r\n            ctx.drawImage(bitmap, 0,0, cursor.numColumns, cursor.numRows);\r\n            let data = ctx.getImageData(0, 0, w, h);\r\n            // console.log(data);\r\n            let i, p;\r\n            for(i=0, p=1; i<data.data.length; i+=4, p+=1){\r\n                cursor.children[p].fillColor.red = data.data[i]/255;\r\n                cursor.children[p].fillColor.green = data.data[i+1]/255;\r\n                cursor.children[p].fillColor.blue = data.data[i+2]/255;\r\n            }\r\n            cursor.borderElement.fillColor = cursor.centerCell.fillColor;\r\n            this.selectedColor = cursor.centerCell.fillColor;  \r\n        })\r\n\r\n        //downsample if needed\r\n        // function getval(i){\r\n        //     if(r==1) return imdata.data[i]/255;\r\n        //     let values=Array.from({length:r}).map((_,col)=>{\r\n        //         return Array.from({length:r}).map((_,row)=>{\r\n        //             return imdata.data[i + (col*4) + (row*w*r*4)];\r\n        //         })\r\n        //     }).flat().filter(v=>typeof v !== 'undefined');\r\n        //     return (values.reduce((a,v)=>a+=v,0)/values.length)/255;\r\n        // }\r\n        \r\n        // let p=1;\r\n        // for(var row=0; row<h*r; row += r){\r\n        //     for(var col=0;col<w*r; col += r, p += 1){\r\n        //         let i = 4*(col + (row*w*r));\r\n        //         self.cursor.children[p].fillColor.red = getval(i);\r\n        //         self.cursor.children[p].fillColor.green = getval(i+1);\r\n        //         self.cursor.children[p].fillColor.blue = getval(i+2);\r\n        //     }\r\n        // }\r\n        \r\n    }\r\n    return this;\r\n}\r\n\r\nasync function getAverageColor(itemToAverage){\r\n    \r\n    let raster = ((itemToAverage.project && itemToAverage.project.overlay) || itemToAverage.overlay).osdViewer.getViewportRaster(itemToAverage.view);\r\n    return new Promise(function(resolve,reject){\r\n        raster.onLoad = function(){\r\n            let color = raster.getAverageColor(itemToAverage);\r\n            raster.remove();\r\n            if(!color){\r\n                reject('Error: The item must be visible on the screen to pick the average color of visible pixels. Please navigate and retry.')\r\n            } \r\n            console.log('in getViewportRaster().onLoad; color=',color);\r\n            resolve(color);\r\n        }\r\n    });\r\n    \r\n};\r\n\r\n//local functions\r\n\r\n// Calculate best text color for contrast from background - https://stackoverflow.com/a/11868398\r\nfunction getContrastYIQ(hexcolor){\r\n    hexcolor = hexcolor.replace(\"#\", \"\");\r\n    var r = parseInt(hexcolor.substr(0,2),16);\r\n    var g = parseInt(hexcolor.substr(2,2),16);\r\n    var b = parseInt(hexcolor.substr(4,2),16);\r\n    var yiq = ((r*299)+(g*587)+(b*114))/1000;\r\n    return (yiq >= 140) ? 'black' : 'white';\r\n}\n\n//# sourceURL=webpack://js/../src/js/papertools/style.mjs?")},"../src/js/papertools/transform.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TransformTool: () => (/* binding */ TransformTool)\n/* harmony export */ });\n/* harmony import */ var _annotationUITool_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./annotationUITool.mjs */ \"../src/js/papertools/annotationUITool.mjs\");\n\r\nclass TransformTool extends _annotationUITool_mjs__WEBPACK_IMPORTED_MODULE_0__.AnnotationUITool{\r\n    constructor(paperScope){\r\n        super(paperScope);\r\n        let self=this;\r\n        this.ps = this.project.paperScope;\r\n        this._mode = 'transform';\r\n        this._moving = [];\r\n        this.setToolbarControl(new TransformToolbar(this));\r\n        this.makeTransformToolObject(self.project.getZoom());\r\n        \r\n        this.extensions.onActivate=function(){ \r\n            // self.project.viewer.addHandler('canvas-click',self.clickHandler) \r\n            self.enableTransformToolObject();\r\n        }    \r\n        this.extensions.onDeactivate=function(shouldFinish){\r\n            // self.project.viewer.removeHandler('canvas-click',self.clickHandler);\r\n            self.tool.onMouseMove = null;\r\n            if(shouldFinish){\r\n                self.disableTransformToolObject();\r\n            }\r\n        }\r\n    }\r\n    // getSelectedItems(){\r\n    //     return this.ps.project.selectedItems.filter(i=>i.isGeoJSONFeature);\r\n    // }\r\n    \r\n    makeTransformToolObject(currentZoom){\r\n        let self=this;\r\n        let cSize=12;//control size\r\n             \r\n        if(this._transformTool) this._transformTool.remove();\r\n        this._transformTool = new paper.Group();\r\n        \r\n        this.project.toolLayer.addChild(this._transformTool);\r\n        this._transformTool.applyMatrix=false;\r\n        this._transformTool.transforming=[];\r\n        this._transformTool.boundingRect = new paper.Shape.Rectangle(new paper.Point(0,0), new paper.Size(0,0));\r\n        this._transformTool.boundingDisplay = new paper.Shape.Rectangle(new paper.Point(0,0), new paper.Size(0,0));\r\n        this._transformTool.boundingRect.set({strokeWidth:0,fillColor:new paper.Color(0,0,0,0.001)});\r\n        this._transformTool.boundingDisplay.set({strokeWidth:5,strokeColor:'lightblue',rescale:{strokeWidth:5}});\r\n        this._transformTool.addChild(this._transformTool.boundingRect);\r\n        this._transformTool.addChild(this._transformTool.boundingDisplay);\r\n        \r\n        //Resize operations\r\n        this._transformTool.corners=[\r\n         ['topLeft','bottomRight'],\r\n         ['topRight','bottomLeft'],\r\n         ['bottomRight','topLeft'],\r\n         ['bottomLeft','topRight']].reduce((acc,c)=>{\r\n             let ctrl = new paper.Shape.Rectangle(new paper.Point(0,0),new paper.Size(cSize/currentZoom,cSize/currentZoom));\r\n            //  let refPt = new paper.Shape.Circle(new paper.Point(0,0),1);\r\n            //  refPt.visible=false;\r\n            //  ctrl.refPt = refPt;\r\n             ctrl.set({rescale:{size:z=>new paper.Size(cSize/z, cSize/z)},fillColor:'red',strokeColor:'black'});\r\n             self._transformTool.addChild(ctrl);\r\n            //  self._transformTool.addChild(refPt);\r\n             ctrl.anchor=c[0];\r\n             ctrl.opposite=c[1];\r\n             ctrl.onMouseDown = function(ev){ev.stopPropagation();}\r\n             ctrl.onMouseDrag = function(ev){\r\n                let rotation=this.parent.rotation;\r\n                let delta=ev.delta.rotate(-rotation);\r\n                \r\n                let refPos = this.parent.corners[this.opposite].position;\r\n\r\n                if(ev.modifiers.command || ev.modifiers.control){\r\n                    delta = delta.project(this.position.subtract(refPos));\r\n                }\r\n                \r\n                let oldPos = this.position;\r\n                let newPos = this.position.add(delta);\r\n                let oldSize=new paper.Rectangle(refPos,oldPos).size;\r\n                let newSize=new paper.Rectangle(refPos,newPos).size;\r\n                let sf = newSize.divide(oldSize);\r\n                \r\n                let refPosX = refPos.transform(this.parent.matrix);\r\n                let refPosZ = this.parent.matrix.inverseTransform(this.parent.corners[this.opposite].refPos);\r\n\r\n                this.parent.transforming.forEach( item=>{\r\n                    let matrix = new paper.Matrix().scale(sf.width,sf.height,refPosZ); \r\n                    item.matrix.append(matrix);\r\n                    item.onTransform && item.onTransform('scale', refPosX, rotation, matrix);\r\n                });\r\n                \r\n                this.parent.boundingRect.scale(sf.width,sf.height,refPos);\r\n                this.parent.setBounds(true);\r\n             }\r\n             acc[c[0]]=ctrl;\r\n             return acc;\r\n         },{});\r\n\r\n        //Rotation operations\r\n        this._transformTool.rotationHandle=new paper.Shape.Circle(new paper.Point(0,0),cSize/currentZoom);\r\n        this._transformTool.rotationHandle.set({fillColor:'red',strokeColor:'black',rescale:{radius:cSize}});\r\n        this._transformTool.addChild(this._transformTool.rotationHandle);\r\n        this._transformTool.rotationHandle.onMouseDown = function(ev){ev.stopPropagation();}\r\n        this._transformTool.rotationHandle.onMouseDrag = function(ev){\r\n            let parentMatrix=this.parent.matrix;\r\n            let center=parentMatrix.transform(this.parent.boundingRect.position);\r\n            \r\n            let oldVec = ev.point.subtract(ev.delta).subtract(center);\r\n            let newVec = ev.point.subtract(center);\r\n            let angle = newVec.angle - oldVec.angle;\r\n            this.parent.rotate(angle,center);\r\n            this.parent.transforming.forEach(item=>{\r\n                item.rotate(angle,center);\r\n                item.onTransform && item.onTransform('rotate', angle, center);\r\n            })\r\n            Object.values(this.parent.corners).forEach(corner=>{\r\n                corner.refPos = corner.refPos.rotate(angle,center);\r\n            })\r\n        }\r\n\r\n        //Translation operations\r\n        this._transformTool.onMouseDown = function(ev){\r\n            // console.log('mousedown',ev);\r\n            // let hitresult=self.hitTest(ev.point) || this.boundingDisplay.hitTest(this.matrix.inverseTransform(ev.point));\r\n            // hitresult = hitresult && (hitresult.item==this.boundingDisplay || (hitresult.item.isGeoJSONFeature&&hitresult.item.selected) );\r\n            // console.log('hit',hitresult);\r\n            if(this.boundingDisplay.contains(ev.point)){\r\n                this._dragging = true;\r\n            }\r\n            // if(hitresult) this._dragging=true;\r\n        }\r\n        this._transformTool.onMouseUp = function(ev){\r\n            this._dragging=false;\r\n        }\r\n        this._transformTool.onMouseDrag = function(ev){\r\n            if(!this._dragging) return;\r\n            this.translate(ev.delta);\r\n            Object.values(this.corners).forEach(corner=>{\r\n                corner.refPos = corner.refPos.add(ev.delta);\r\n            })\r\n            this.transforming.forEach(item=>{\r\n                item.translate(ev.delta);\r\n                item.onTransform && item.onTransform('translate', ev.delta);\r\n            });\r\n        }\r\n        this.tool.onMouseMove=function(ev){\r\n            \r\n                let hitResult = self.project.paperScope.project.hitTest(ev.point);\r\n                if(hitResult){\r\n                    if(Object.values(self._transformTool.corners).indexOf(hitResult)){\r\n                        self.project.overlay.addClass('transform-tool-resize');\r\n                    } else {\r\n                        self.project.overlay.removeClass('transform-tool-resize');\r\n                    }\r\n                        \r\n                    if (self._transformTool.rotationHandle == hitResult){\r\n                        self.project.overlay.addClass('transform-tool-rotate');\r\n                    } else {\r\n                        self.project.overlay.removeClass('transform-tool-rotate');\r\n                    }\r\n                    \r\n                } else{\r\n                    self.project.overlay.removeClass(['transform-tool-resize', 'transform-tool-rotate']);\r\n                }\r\n\r\n                if(self.item.contains(ev.point)){\r\n                    self.project.overlay.addClass('transform-tool-move');\r\n                } else {\r\n                    self.project.overlay.removeClass('transform-tool-move');\r\n                }\r\n            \r\n        }\r\n\r\n        //(re)positioning the tool handles (corners, rotation control)\r\n        this._transformTool.setBounds=function(useExistingBoundingRect=false){\r\n            if(!useExistingBoundingRect){\r\n                let bounds=this.transforming.reduce((acc,item)=>{\r\n                    acc.minX = acc.minX===null?item.bounds.topLeft.x : Math.min(acc.minX,item.bounds.topLeft.x);\r\n                    acc.minY = acc.minY===null?item.bounds.topLeft.y : Math.min(acc.minY,item.bounds.topLeft.y);\r\n                    acc.maxX = acc.maxX===null?item.bounds.bottomRight.x : Math.max(acc.maxX,item.bounds.bottomRight.x);\r\n                    acc.maxY = acc.maxY===null?item.bounds.bottomRight.y : Math.max(acc.maxY,item.bounds.bottomRight.y);\r\n                    return acc;\r\n                },{minX:null,minY:null,maxX:null,maxY:null});\r\n                let rect = new paper.Rectangle(new paper.Point(bounds.minX,bounds.minY), new paper.Point(bounds.maxX,bounds.maxY));\r\n                this.matrix.reset();\r\n                this.boundingRect.set({position:rect.center,size:rect.size});\r\n                // this.transforming.forEach(item=>item.rotationAxis=new paper.Point(rect.center));\r\n            }\r\n            \r\n            let br=this.boundingRect;\r\n            this.boundingDisplay.set({position:br.position,size:br.bounds.size});\r\n            Object.values(this.corners).forEach(c=>{\r\n                c.position=br.bounds[c.anchor];\r\n                // if(!useExistingBoundingRect) c.refPt.position = c.position;\r\n                if(!useExistingBoundingRect) c.refPos = c.position;\r\n            })\r\n            this.rotationHandle.set({\r\n                position:br.position.subtract(new paper.Point(0,br.bounds.size.height/2+this.rotationHandle.radius*2))\r\n            });\r\n        }\r\n\r\n\r\n\r\n        this._transformTool.transformItems=function(items){\r\n            //finish applying all transforms to previous items (called during disableTransformToolObject)\r\n            this.transforming.forEach(item=>{\r\n                item.matrix.apply(true,true);\r\n                item.onTransform && item.onTransform('complete');\r\n            })\r\n\r\n            //set up new objects for transforming, and reset matrices of the tool\r\n            this.transforming=items;\r\n            items.forEach(item=>item.applyMatrix=false)\r\n            this.matrix.reset();\r\n            this.boundingRect.matrix.reset();\r\n            this.boundingDisplay.matrix.reset();\r\n            this.setBounds();\r\n        }\r\n        this._transformTool.visible=false;\r\n    }\r\n    enableTransformToolObject(){\r\n        this.project.toolLayer.bringToFront();\r\n        this._transformTool.visible=true;\r\n        this._transformTool.transformItems(this.items);\r\n        // this._transformTool.transformItems(this.getSelectedItems());\r\n        \r\n    }\r\n    disableTransformToolObject(){\r\n        this.project.toolLayer.sendToBack();\r\n        this._transformTool.transformItems([]);\r\n        this._transformTool.visible=false;\r\n    }\r\n    hitTest(coords){\r\n        let hitResult = this.ps.project.hitTest(coords,{\r\n            fill:true,\r\n            stroke:true,\r\n            segments:true,\r\n            tolerance:(5/this.project.getZoom()),\r\n            match:i=>i.item.isGeoJSONFeature || i.item.parent.isGeoJSONFeature,\r\n        })\r\n        if(hitResult && !hitResult.item.isGeoJSONFeature){\r\n            hitResult.item = hitResult.item.parent;\r\n        }\r\n        return hitResult;\r\n    }\r\n}\r\n\r\nclass TransformToolbar extends _annotationUITool_mjs__WEBPACK_IMPORTED_MODULE_0__.AnnotationUIToolbarBase{\r\n    constructor(tool){\r\n        super(tool);\r\n        $(this.dropdown).addClass('transform-dropdown');\r\n        let html = $('<i>',{class:'fa-solid fa-up-down-left-right'})[0];\r\n        this.button.configure(html,'Transform Tool');\r\n        \r\n    }\r\n    isEnabledForMode(mode){\r\n        return this.tool.project.paperScope.findSelectedItems().length>0 && [\r\n            'select',\r\n            'multiselection',\r\n            'MultiPolygon',\r\n            'Point:Rectangle',\r\n            'Point:Ellipse',\r\n            'Point',\r\n            'LineString',\r\n            'GeometryCollection:Raster',\r\n        ].includes(mode);\r\n    }\r\n    \r\n}\n\n//# sourceURL=webpack://js/../src/js/papertools/transform.mjs?")},"../src/js/papertools/wand.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WandTool: () => (/* binding */ WandTool)\n/* harmony export */ });\n/* harmony import */ var _annotationUITool_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./annotationUITool.mjs */ \"../src/js/papertools/annotationUITool.mjs\");\n/* harmony import */ var _style_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./style.mjs */ \"../src/js/papertools/style.mjs\");\n/* harmony import */ var _utils_morph_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/morph.mjs */ \"../src/js/utils/morph.mjs\");\n/* harmony import */ var _utils_magicwand_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/magicwand.mjs */ \"../src/js/utils/magicwand.mjs\");\n\r\n\r\n\r\n\r\n\r\nclass WandTool extends _annotationUITool_mjs__WEBPACK_IMPORTED_MODULE_0__.AnnotationUITool{\r\n    constructor(paperScope){\r\n        super(paperScope);\r\n        let self = this;\r\n        let tool = this.tool;   \r\n        this.paperScope = self.project.paperScope;\r\n        \r\n        this.reduceMode = false;\r\n        this.replaceMode = true;\r\n        this.floodMode = true;\r\n        \r\n        this.colors = {\r\n            pixelAllowed: new paper.Color({red:0,green:0,blue:100}),\r\n            pixelNotAllowed: new paper.Color({red:100,green:0,blue:0}),\r\n            currentItem : new paper.Color({red:0,green:100,blue:0,alpha:0.5}),\r\n            nullColor: new paper.Color({red:0,green:0,blue:0,alpha:0}),//transparent pixels if negative\r\n            defaultColor: new paper.Color({red:255,green:255,blue:255}),\r\n        }\r\n        \r\n        this.threshold=10;\r\n        this.minThreshold=-1;\r\n        this.maxThreshold=100;\r\n        this.startThreshold=10;\r\n\r\n        //colorpicker\r\n        let colorPicker = new _style_mjs__WEBPACK_IMPORTED_MODULE_1__.ColorpickerCursor(10,7,self.project.toolLayer);\r\n        colorPicker.element.applyRescale();\r\n\r\n\r\n        this.MagicWand = (0,_utils_magicwand_mjs__WEBPACK_IMPORTED_MODULE_3__.makeMagicWand)();\r\n\r\n        this.setToolbarControl(new WandToolbar(this));\r\n        this.toolbarControl.setThreshold(this.threshold);\r\n\r\n        let callback=function(){\r\n            self.getImageData();\r\n        }\r\n        this.onSelectionChanged = callback; \r\n        this.extensions.onActivate = function(){ \r\n            let item = (self.item || self.itemToCreate);\r\n            self.itemLayer = item ? item.layer : null;\r\n\r\n            self.getImageData();\r\n            self.project.overlay.osdViewer.addHandler('animation-finish',callback);\r\n            self.project.overlay.osdViewer.addHandler('rotate',callback);  \r\n            colorPicker.element.visible=true;\r\n            self.project.toolLayer.bringToFront();\r\n        };\r\n        this.extensions.onDeactivate = function(finished){\r\n            self.project.overlay.osdViewer.removeHandler('animation-finish',callback);\r\n            self.project.overlay.osdViewer.removeHandler('rotate',callback);\r\n            colorPicker.element.visible=false;\r\n            this.preview && this.preview.remove();\r\n            if(finished){\r\n                self.finish();\r\n            }\r\n            self.project.toolLayer.sendToBack();\r\n        };\r\n        \r\n        tool.onMouseDown=function(ev){\r\n            self.startThreshold=self.threshold;\r\n            self.imageData.dragStartMask = self.imageData.binaryMask;\r\n            self.applyMagicWand(ev.point);\r\n            colorPicker.element.visible=false;     \r\n        }\r\n        tool.onMouseDrag=function(ev){\r\n            let delta = ev.point.subtract(ev.downPoint).multiply(self.project.getZoom());\r\n            if(self.reduceMode) delta = delta.multiply(-1); //invert effect of dragging when in reduce mode for more intuitive user experience\r\n            let s=Math.round((delta.x+delta.y*-1)/2);\r\n            self.threshold=Math.min(Math.max(self.startThreshold+s, self.minThreshold), self.maxThreshold);\r\n            if(Number.isNaN(self.threshold)){\r\n                // console.log('wft nan??');\r\n                console.warn('NaN value for threshold')\r\n            }\r\n            self.toolbarControl.setThreshold(self.threshold);\r\n            self.applyMagicWand(ev.downPoint);\r\n        }\r\n        tool.onMouseMove=function(ev){\r\n            colorPicker.updatePosition(ev.point);\r\n        }\r\n        tool.onMouseUp=function(ev){\r\n            colorPicker.element.visible=true;\r\n            colorPicker.element.bringToFront();\r\n            // colorPicker.position=ev.point;\r\n            colorPicker.updatePosition(ev.point);\r\n        }\r\n        \r\n        tool.extensions.onKeyUp=function(ev){\r\n            // console.log(`Key up on ${ev.key} key`)\r\n            if(ev.key=='a'){\r\n                self.applyChanges();\r\n            }\r\n            if(ev.key=='e'){\r\n                self.reduceMode = !self.reduceMode;\r\n                self.toolbarControl.setReduceMode(self.reduceMode);\r\n            }\r\n            if(ev.key=='r'){\r\n                self.replaceMode = !self.replaceMode;\r\n                self.toolbarControl.setReplaceMode(self.replaceMode);\r\n            }\r\n            if(ev.key=='f'){\r\n                self.floodMode = !self.floodMode;\r\n                self.toolbarControl.setFloodMode(self.floodMode);\r\n            }\r\n        }\r\n    }\r\n    finish(){\r\n        // if(item) smoothAndSimplify(item);\r\n        this.itemLayer=null;\r\n        this.preview && this.preview.remove();\r\n        this.deactivate();    \r\n    }\r\n    setThreshold(t){\r\n        this.threshold=parseInt(t);\r\n    }\r\n    setReduceMode(erase){\r\n        this.reduceMode=erase;\r\n    }\r\n    setFloodMode(flood){\r\n        this.floodMode=flood;\r\n    }\r\n    setReplaceMode(replace){\r\n        this.replaceMode=replace;\r\n    }\r\n    \r\n    applyChanges(){\r\n        if(this.itemToCreate){\r\n            this.itemToCreate.initializeGeoJSONFeature('MultiPolygon');\r\n            this.refreshItems();\r\n        }\r\n        let wandOutput = {\r\n            width:this.imageData.width,\r\n            height:this.imageData.height,\r\n            data:this.imageData.binaryMask,\r\n            bounds:{\r\n                minX:0,\r\n                minY:0,\r\n                maxX:this.preview.width,\r\n                maxY:this.preview.height,\r\n            }\r\n        };\r\n        \r\n        \r\n        let viewRect = new paper.Path.Rectangle(new paper.Point(0.1,0.1), new paper.Point(this.preview.width-0.1,this.preview.height-0.1), {insert:false})\r\n        let toUnite = maskToPath(this.MagicWand, wandOutput,);\r\n        let dilated = maskToPath(this.MagicWand, wandOutput,'dilate');\r\n        let toErase = viewRect.subtract(dilated,{insert:false});\r\n        \r\n        [viewRect, toUnite, toErase].forEach(item=>{\r\n            item.translate(-this.preview.width/2, -this.preview.height/2);\r\n            item.matrix = this.preview.matrix;\r\n        });\r\n\r\n        let n1 = this.item.subtract(toErase,{insert:false});\r\n        n1 = n1.toCompoundPath();\r\n        // removeDuplicates(n1);\r\n        \r\n        let newPath = n1.unite(toUnite,{insert:false});\r\n        \r\n        newPath = newPath.toCompoundPath();\r\n        \r\n        toUnite.remove();\r\n        toErase.remove();\r\n        dilated.remove();\r\n        n1.remove();\r\n        newPath.remove();//if wand tool stops working move this back after the swapping of children\r\n        viewRect.remove();\r\n\r\n        let success =  newPath !== n1;\r\n        if(success){\r\n            // console.log('Wand tool setting item children')\r\n            this.item.removeChildren();\r\n            this.item.addChildren(newPath.children);\r\n        }\r\n        \r\n        \r\n        this.getImageData();\r\n        \r\n    };\r\n    \r\n    async getImageData(){\r\n        let self=this;\r\n        let imageData = self.project.overlay.osdViewer.getImageData();\r\n        \r\n        let viewportGroup = new paper.Group({children:[],insert:false});\r\n\r\n        let b = self.tool.view.bounds\r\n        let viewportPath = new paper.Path(b.topLeft, b.topRight, b.bottomRight, b.bottomLeft);\r\n        viewportPath.strokeWidth=0;\r\n        viewportGroup.addChild(viewportPath.clone());\r\n        viewportGroup.addChild(viewportPath);\r\n        viewportGroup.clipped=true;\r\n        \r\n        let boundingItems = this.itemLayer ? this.itemLayer.getItems({match:i=>i.isBoundingElement}) : [];\r\n        //allow all pixels if no bounding item, otherwise disallow all and then allow those inside the bounding item(s);\r\n        viewportPath.fillColor = boundingItems.length==0 ? self.colors.pixelAllowed : self.colors.pixelNotAllowed;\r\n        boundingItems.forEach(item=>{\r\n            let clone = item.clone({insert:false});\r\n            clone.fillColor = self.colors.pixelAllowed;\r\n            clone.strokeWidth=0;\r\n            viewportGroup.addChild(clone);\r\n        })\r\n        if(self.item){\r\n            let clone = self.item.clone({insert:false});\r\n            clone.fillColor = self.colors.currentItem;\r\n            clone.strokeWidth = 0;\r\n            clone.selected=false;\r\n            viewportGroup.addChild(clone);\r\n        }\r\n        \r\n        viewportGroup.selected=false;\r\n\r\n        //hide all annotation layers; add the viewportGroup; render; get image data; remove viewportGroup; restore visibility of layers\r\n        let annotationLayers = self.project.paperScope.project.layers.filter(l=>l.isGeoJSONFeatureCollection);\r\n        let visibility = annotationLayers.map(l=>l.visible);\r\n        annotationLayers.forEach(l=>l.visible=false);\r\n        self.project.toolLayer.addChild(viewportGroup);\r\n        self.tool.view.update();\r\n        let cm = self.tool.view.getImageData();\r\n        viewportGroup.remove();\r\n        annotationLayers.forEach((l,index)=>l.visible = visibility[index]);\r\n        self.tool.view.update();\r\n        \r\n        self.imageData = {\r\n            width:imageData.width,\r\n            height:imageData.height,\r\n            data:imageData.data,\r\n            bytes:4,\r\n            colorMask:cm,\r\n        }\r\n        self.imageData.binaryMask = new Uint8ClampedArray(self.imageData.width * self.imageData.height);\r\n        for(let i = 0, m=0; i<self.imageData.data.length; i+= self.imageData.bytes, m+=1){\r\n            self.imageData.binaryMask[m]=self.imageData.colorMask.data[i+1] ? 1 : 0;//green channel is for current item\r\n        }\r\n        \r\n        if(self.item && self.item.isGeoJSONFeature && self.item.getArea()){\r\n            (0,_style_mjs__WEBPACK_IMPORTED_MODULE_1__.getAverageColor)(self.item).then(sampleColor=>{\r\n                let c = [sampleColor.red*255,sampleColor.green*255,sampleColor.blue*255];\r\n                self.imageData.sampleColor = c;\r\n                self.rasterPreview(self.imageData.binaryMask, c);\r\n            });\r\n        }\r\n        else{\r\n            self.rasterPreview(self.imageData.binaryMask);\r\n        } \r\n        \r\n    }\r\n    applyMagicWand(eventPoint){\r\n        let pt = this.paperScope.view.projectToView(eventPoint);\r\n        //account for pixel density\r\n        let r = this.paperScope.view.pixelRatio\r\n        pt = pt.multiply(r);\r\n\r\n        //use floodFill or thresholdMask depending on current selected option\r\n        let magicWandOutput;\r\n        if(this.floodMode){\r\n            magicWandOutput = this.MagicWand.floodFill(this.imageData,Math.round(pt.x),Math.round(pt.y),this.threshold);\r\n        }\r\n        else{\r\n            magicWandOutput = this.MagicWand.thresholdMask(this.imageData, Math.round(pt.x), Math.round(pt.y), this.threshold);\r\n        }\r\n        \r\n        let bm = this.imageData.binaryMask;\r\n        let ds = this.imageData.dragStartMask;\r\n        let cm = this.imageData.colorMask.data;\r\n        let mw = magicWandOutput.data;\r\n\r\n        //apply rules based on existing mask\r\n        //1) set any pixels outside the bounding area to zero\r\n        //2) if expanding current area, set pixels of existing item to 1\r\n        //3) if reducing current area, use currentMask to remove pixels from existing item\r\n        if(this.replaceMode && !this.reduceMode){ //start from the initial item (cm[i+1]>0) and add pixels from magicWandOutput (mw[m]) if allowed (cm[i]==0)\r\n            for(let i = 0, m=0; i<cm.length; i+= this.imageData.bytes, m+=1){\r\n                bm[m] = cm[i+1]>0 || (cm[i]==0 && mw[m]);\r\n            }\r\n        }\r\n        else if(this.replaceMode && this.reduceMode){ //start from initial item (cm[i+1]>0) and remove pixels from mw[m] if allowed (cm[i]==0)\r\n            for(let i = 0, m=0; i<cm.length; i+= this.imageData.bytes, m+=1){\r\n                bm[m] = cm[i+1]>0 && !(cm[i]==0 && mw[m]);\r\n            }\r\n        }\r\n        else if(!this.replaceMode && !this.reduceMode){ //start from dragstart (ds[m]) and add pixels from mw[m] if allowed (cm[i]==0)\r\n            for(let i = 0, m=0; i<cm.length; i+= this.imageData.bytes, m+=1){\r\n                bm[m] = ds[m] || (cm[i]==0 && mw[m]);\r\n            }\r\n        }\r\n        else if(!this.replaceMode && this.reduceMode){ //start from dragstart (ds[m]) and remove pixels from mw[m] if allowed (cm[i]==0)\r\n            for(let i = 0, m=0; i<cm.length; i+= this.imageData.bytes, m+=1){\r\n                bm[m] = ds[m] && !(cm[i]==0 && mw[m]);\r\n            }\r\n        }\r\n\r\n        // imgPreview(this.getDataURL(this.imageData.binaryMask));\r\n        this.rasterPreview(this.imageData.binaryMask,this.imageData.sampleColor || magicWandOutput.sampleColor);\r\n        \r\n    }\r\n    rasterPreview(binaryMask, sampleColor){\r\n        let self=this;\r\n        let cmap = {0: this.colors.nullColor, 1: this.colors.defaultColor};\r\n        //If a sample color is known, \"invert\" it for better contrast relative to background image\r\n        if(sampleColor){\r\n            cmap[1] = new paper.Color(sampleColor[0],sampleColor[1],sampleColor[2]);\r\n            cmap[1].hue+=180;\r\n            cmap[1].brightness=(180+cmap[1].brightness)%360;\r\n        }\r\n\r\n        this.preview && this.preview.remove();\r\n        \r\n        this.preview = this.project.paperScope.overlay.osdViewer.getViewportRaster(this.project.paperScope.view, false);\r\n        this.project.toolLayer.insertChild(0, this.preview);//add the raster to the bottom of the tool layer\r\n        console.log('New preview',this.preview.id, this.preview.parent.id);\r\n        \r\n        let c;\r\n        let imdata=this.preview.createImageData(this.preview.size);\r\n        for(var ix=0, mx=0; ix<imdata.data.length; ix+=4, mx+=1){\r\n            c = cmap[binaryMask[mx]];\r\n            imdata.data[ix]=c.red;\r\n            imdata.data[ix+1]=c.blue;\r\n            imdata.data[ix+2]=c.green;\r\n            imdata.data[ix+3]=c.alpha*255;\r\n        }\r\n        this.preview.setImageData(imdata, new paper.Point(0,0));\r\n        \r\n        function tween1(){\r\n            // console.log('tween1', self.preview.id)\r\n            self.preview.tweenTo({opacity:0.15},{duration:1200,easing:'easeInQuart'}).then(tween2);\r\n        }\r\n        function tween2(){\r\n            // console.log('tween2', self.preview.id)\r\n            self.preview.tweenTo({opacity:1},{duration:800,easing:'easeOutCubic'}).then(tween1);\r\n        }\r\n        tween1();\r\n    } \r\n    \r\n    \r\n}\r\n\r\nclass WandToolbar extends _annotationUITool_mjs__WEBPACK_IMPORTED_MODULE_0__.AnnotationUIToolbarBase{\r\n    constructor(wandTool){\r\n        super(wandTool);\r\n        let html = $('<i>',{class:\"fa-solid fa-wand-magic-sparkles fa-rotate-270\"})[0];\r\n        this.button.configure(html,'Magic Wand Tool');\r\n        \r\n        let fdd = $('<div>',{'data-tool':'wand',class:'dropdown wand-toolbar'}).appendTo(this.dropdown);\r\n        let thr = $('<div>',{class:'threshold-container'}).appendTo(fdd);\r\n        $('<label>').text('Threshold').appendTo(thr)\r\n        this.thresholdInput=$('<input>',{type:'range',min:-1,max:100,value:20}).appendTo(thr).on('change',function(){\r\n            wandTool.setThreshold($(this).val());\r\n        });\r\n        \r\n        let toggles=$('<div>',{class:'toggles'}).appendTo(fdd);\r\n        \r\n        $('<span>',{class:'option-toggle'}).appendTo(toggles)\r\n            .data({\r\n                prefix:'On click:',\r\n                actions:[{replace:'Start new mask'}, {append:'Add to current'}],\r\n                onclick:function(action){\r\n                    wandTool.setReplaceMode(action=='replace');\r\n                }\r\n            })\r\n        $('<span>',{class:'option-toggle'}).appendTo(toggles)\r\n            .data({\r\n                prefix:'Fill rule:',\r\n                actions:[{flood:'Contiguous'}, {everywhere:'Anywhere'}],\r\n                onclick:function(action){\r\n                    wandTool.setFloodMode(action=='flood')\r\n                }\r\n            });\r\n        $('<span>',{class:'option-toggle'}).appendTo(toggles)\r\n            .data({\r\n                prefix:'Use to:',\r\n                actions:[{expand:'Expand selection'}, {reduce:'Reduce selection'}],\r\n                onclick:function(action){\r\n                    wandTool.setReduceMode(action=='reduce');\r\n                }\r\n            });\r\n        \r\n        toggles.find('.option-toggle').each((index,item)=>{\r\n            // console.log('option-toggle item',item)\r\n            item=$(item);\r\n            let data=item.data();\r\n            $('<span>',{class:'prefix label'}).text(data.prefix).appendTo(item);\r\n            \r\n            data.actions.forEach((action,actionIndex)=>{\r\n                let text=Object.values(action)[0];\r\n                let key = Object.keys(action)[0];\r\n                let option = $('<span>',{class:'option'}).text(text).appendTo(item).data({key:key,index:actionIndex});\r\n                if(actionIndex==0) option.addClass('selected');\r\n            })\r\n            item.on('click',function(){\r\n                let actions=$(this).data('actions');\r\n                let currentIndex = $(this).find('.option.selected').data('index');\r\n                let nextIndex = typeof currentIndex==='undefined' ? 0 : (currentIndex+1) % actions.length;\r\n                $(this).find('.option').removeClass('selected');\r\n                let actionToEnable=$(this).find('.option').filter((idx,item)=>$(item).data('index')==nextIndex).addClass('selected').data('key');\r\n                $(this).data('onclick')(actionToEnable);//use the \r\n            })\r\n        })\r\n\r\n\r\n        \r\n        $('<button>',{class:'btn btn-secondary btn-sm','data-action':'apply'}).appendTo(fdd).text('Apply').on('click',function(){\r\n            wandTool.applyChanges();\r\n        });\r\n        $('<button>',{class:'btn btn-sm', 'data-action':'done'}).appendTo(fdd).text('Done').on('click',function(){\r\n            wandTool.finish();\r\n        });\r\n    }\r\n    isEnabledForMode(mode){\r\n        return ['new','MultiPolygon'].includes(mode);\r\n    }\r\n    \r\n    setThreshold(thr){\r\n        this.thresholdInput.val(thr);\r\n    }\r\n}\r\n\r\n\r\nfunction imgPreview(dataURL){\r\n    if(window.preview) window.preview.remove();\r\n    window.preview = $('<img>',{style:'position:fixed;left:10px;top:10px;width:260px;',src:dataURL}).appendTo('body');\r\n}\r\n\r\n\r\nfunction maskToPath(MagicWand, mask, border){\r\n    let minPathArea = 50;\r\n    let path=new paper.CompoundPath({children:[],fillRule:'evenodd',insert:false});\r\n    if(mask){\r\n        let morph = new _utils_morph_mjs__WEBPACK_IMPORTED_MODULE_2__.Morph(mask);\r\n        mask = morph.addBorder();\r\n        if(border=='dilate') morph.dilate();\r\n        mask.bounds={\r\n            minX:0,\r\n            minY:0,\r\n            maxX:mask.width,\r\n            maxY:mask.height,\r\n        }\r\n        \r\n        \r\n        let contours = MagicWand.traceContours(mask);\r\n        path.children = contours.map(function(c){\r\n            let pts = c.points.map(pt=>new paper.Point(pt));\r\n            let path=new paper.Path(pts,{insert:false});\r\n            path.closed=true;\r\n            return path;\r\n        }).filter(function(p){\r\n            //Use absolute area since inner (hole) paths will have negative area\r\n            if(Math.abs(p.area) >= minPathArea){\r\n                return true;\r\n            }\r\n            //if the item is being filtered out for being too small, it must be removed\r\n            // otherwise paper.js memory usage will spike with all the extra hidden\r\n            // path objects that will remain in the active layer (not having been inserted elsewhere)\r\n            p.remove(); \r\n        })\r\n    }\r\n    \r\n    return path;//.reorient(true,'clockwise');\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://js/../src/js/papertools/wand.mjs?")},"../src/js/utils/editablecontent.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EditableContent: () => (/* binding */ EditableContent)\n/* harmony export */ });\nclass EditableContent{\r\n    constructor(opts){\r\n        let defaultOpts = {\r\n            initialContent:'Enter text...',\r\n        }\r\n        opts = Object.assign({}, defaultOpts, opts);\r\n\r\n        this._element = document.createElement('span');\r\n        this._ec = document.createElement('span');\r\n        this._button = document.createElement('span');\r\n        this._element.appendChild(this._ec);\r\n        this._element.appendChild(this._button);\r\n        this._oldtext='';\r\n\r\n        this._element.classList.add('editablecontent');\r\n        this._ec.classList.add('text-content');\r\n        this._button.classList.add('fa', 'fa-edit', 'edit-button', 'onhover');\r\n\r\n        this._ec.textContent = opts.initialContent;\r\n        //this._ec.setAttribute('contenteditable',true);\r\n\r\n        this._element.addEventListener('focusout',()=>{\r\n            if(!this._element.classList.contains('editing')){\r\n                return;\r\n            }\r\n            let newtext = this._ec.textContent.trim();\r\n            if(newtext !== this.oldtext){\r\n                this.onChanged && this.onChanged(newtext);\r\n            }\r\n            this._element.classList.remove('editing');\r\n            this._ec.setAttribute('contenteditable',false);\r\n        });\r\n\r\n        this._element.addEventListener('keypress',ev=>{\r\n            if(!this._element.classList.contains('editing')){\r\n                return;\r\n            }\r\n            ev.stopPropagation();\r\n            if(ev.key=='Enter'){\r\n                ev.preventDefault();\r\n                this._ec.blur();\r\n            }\r\n        });\r\n\r\n        this._element.addEventListener('keydown keyup',ev=>{\r\n            if(!this._element.classList.contains('editing')){\r\n                return;\r\n            }\r\n            ev.stopPropagation();\r\n        });\r\n\r\n        this._button.addEventListener('click',()=>this._editClicked());\r\n\r\n\r\n    }\r\n    get element(){\r\n        return this._element;\r\n    }\r\n    get onChanged(){\r\n        return this._onChanged;\r\n    }\r\n    set onChanged(func){\r\n        if(typeof func === 'function' || func === null){\r\n            this._onChanged=func;\r\n        } else {\r\n            throw('Value must be a function or null');\r\n        }\r\n    }\r\n    setText(text){\r\n        this._ec.textContent = text;\r\n    }\r\n    _editClicked(){\r\n        this._element.classList.add('editing');\r\n        this._ec.setAttribute('contenteditable',true);\r\n        this._oldtext = this._ec.textContent.trim();\r\n        let range = document.createRange();\r\n        range.selectNodeContents(this._ec);\r\n        let selection = window.getSelection();\r\n        selection.removeAllRanges();\r\n        selection.addRange(range);\r\n        // let header = this._element.find('.editablecontent');\r\n        // header.addClass('editing');\r\n        // let ce = header.find('.edit').attr('contenteditable',true).focus();\r\n        // ce.data('previous-text',ce.text());\r\n        // let range = document.createRange();\r\n        // range.selectNodeContents(ce[0]);\r\n        // let selection = window.getSelection();\r\n        // selection.removeAllRanges();\r\n        // selection.addRange(range);\r\n    }\r\n}\n\n//# sourceURL=webpack://js/../src/js/utils/editablecontent.mjs?")},"../src/js/utils/magicwand.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   makeMagicWand: () => (/* binding */ makeMagicWand)\n/* harmony export */ });\n////// MagicWand.js\r\n    // https://github.com/Tamersoul/magic-wand-js a3b0903 last modified Oct 13, 2020, downloaded 9/21/21 \r\n    // The MIT License (MIT)\r\n\r\n    // Copyright (c) 2014, Ryasnoy Paul (ryasnoypaul@gmail.com)\r\n\r\n    // Permission is hereby granted, free of charge, to any person obtaining a copy\r\n    // of this software and associated documentation files (the "Software"), to deal\r\n    // in the Software without restriction, including without limitation the rights\r\n    // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n    // copies of the Software, and to permit persons to whom the Software is\r\n    // furnished to do so, subject to the following conditions:\r\n\r\n    // The above copyright notice and this permission notice shall be included in all\r\n    // copies or substantial portions of the Software.\r\n\r\n    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n    // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n    // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n    // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n    // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n    // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n    // SOFTWARE.\r\n    \r\n    \r\n    function makeMagicWand() {\r\n        var lib = {};\r\n    \r\n        /** Create a binary mask on the image by color threshold\r\n         * Algorithm: Scanline flood fill (http://en.wikipedia.org/wiki/Flood_fill)\r\n         * @param {Object} image: {Uint8Array} data, {int} width, {int} height, {int} bytes\r\n         * @param {int} x of start pixel\r\n         * @param {int} y of start pixel\r\n         * @param {int} color threshold\r\n         * @param {Uint8Array} mask of visited points (optional) \r\n         * @param {boolean} [includeBorders=false] indicate whether to include borders pixels\r\n         * @return {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds\r\n         */\r\n        lib.floodFill = function(image, px, py, colorThreshold, mask, includeBorders) {\r\n            return includeBorders\r\n                ? floodFillWithBorders(image, px, py, colorThreshold, mask)\r\n                : floodFillWithoutBorders(image, px, py, colorThreshold, mask);\r\n        };\r\n    \r\n        function floodFillWithoutBorders(image, px, py, colorThreshold, mask) {\r\n    \r\n            var c, x, newY, el, xr, xl, dy, dyl, dyr, checkY,\r\n                data = image.data,\r\n                w = image.width,\r\n                h = image.height,\r\n                bytes = image.bytes, // number of bytes in the color\r\n                maxX = -1, minX = w + 1, maxY = -1, minY = h + 1,\r\n                i = py * w + px, // start point index in the mask data\r\n                result = new Uint8Array(w * h), // result mask\r\n                visited = new Uint8Array(mask ? mask : w * h); // mask of visited points\r\n    \r\n            if (visited[i] === 1) return null;\r\n    \r\n            i = i * bytes; // start point index in the image data\r\n            var sampleColor = [data[i], data[i + 1], data[i + 2], data[i + 3]]; // start point color (sample)\r\n    \r\n            var stack = [{ y: py, left: px - 1, right: px + 1, dir: 1 }]; // first scanning line\r\n            do {\r\n                el = stack.shift(); // get line for scanning\r\n    \r\n                checkY = false;\r\n                for (x = el.left + 1; x < el.right; x++) {\r\n                    dy = el.y * w;\r\n                    i = (dy + x) * bytes; // point index in the image data\r\n    \r\n                    if (visited[dy + x] === 1) continue; // check whether the point has been visited\r\n                    \r\n                    // compare the color of the sample\r\n                    c = data[i] - sampleColor[0]; // check by red\r\n                    if (c > colorThreshold || c < -colorThreshold) continue;\r\n                    c = data[i + 1] - sampleColor[1]; // check by green\r\n                    if (c > colorThreshold || c < -colorThreshold) continue;\r\n                    c = data[i + 2] - sampleColor[2]; // check by blue\r\n                    if (c > colorThreshold || c < -colorThreshold) continue;\r\n                    \r\n                    //ignore transparent points\r\n                    if(data[i+3] === 0) continue;\r\n    \r\n                    checkY = true; // if the color of the new point(x,y) is similar to the sample color need to check minmax for Y \r\n    \r\n                    result[dy + x] = 1; // mark a new point in mask\r\n                    visited[dy + x] = 1; // mark a new point as visited\r\n    \r\n                    xl = x - 1;\r\n                    // walk to left side starting with the left neighbor\r\n                    while (xl > -1) {\r\n                        dyl = dy + xl;\r\n                        i = dyl * bytes; // point index in the image data\r\n                        if (visited[dyl] === 1) break; // check whether the point has been visited\r\n                        // compare the color of the sample\r\n                        c = data[i] - sampleColor[0]; // check by red\r\n                        if (c > colorThreshold || c < -colorThreshold) break;\r\n                        c = data[i + 1] - sampleColor[1]; // check by green\r\n                        if (c > colorThreshold || c < -colorThreshold) break;\r\n                        c = data[i + 2] - sampleColor[2]; // check by blue\r\n                        if (c > colorThreshold || c < -colorThreshold) break;\r\n\r\n                        //ignore transparent points\r\n                        if(data[i+3] === 0) break;\r\n    \r\n                        result[dyl] = 1;\r\n                        visited[dyl] = 1;\r\n    \r\n                        xl--;\r\n                    }\r\n                    xr = x + 1;\r\n                    // walk to right side starting with the right neighbor\r\n                    while (xr < w) {\r\n                        dyr = dy + xr;\r\n                        i = dyr * bytes; // index point in the image data\r\n                        if (visited[dyr] === 1) break; // check whether the point has been visited\r\n                        // compare the color of the sample\r\n                        c = data[i] - sampleColor[0]; // check by red\r\n                        if (c > colorThreshold || c < -colorThreshold) break;\r\n                        c = data[i + 1] - sampleColor[1]; // check by green\r\n                        if (c > colorThreshold || c < -colorThreshold) break;\r\n                        c = data[i + 2] - sampleColor[2]; // check by blue\r\n                        if (c > colorThreshold || c < -colorThreshold) break;\r\n\r\n                        //ignore transparent points\r\n                        if(data[i+3] === 0) break;\r\n    \r\n                        result[dyr] = 1;\r\n                        visited[dyr] = 1;\r\n    \r\n                        xr++;\r\n                    }\r\n    \r\n                    // check minmax for X\r\n                    if (xl < minX) minX = xl + 1;\r\n                    if (xr > maxX) maxX = xr - 1;\r\n    \r\n                    newY = el.y - el.dir;\r\n                    if (newY >= 0 && newY < h) { // add two scanning lines in the opposite direction (y - dir) if necessary\r\n                        if (xl < el.left) stack.push({ y: newY, left: xl, right: el.left, dir: -el.dir }); // from "new left" to "current left"\r\n                        if (el.right < xr) stack.push({ y: newY, left: el.right, right: xr, dir: -el.dir }); // from "current right" to "new right"\r\n                    }\r\n                    newY = el.y + el.dir;\r\n                    if (newY >= 0 && newY < h) { // add the scanning line in the direction (y + dir) if necessary\r\n                        if (xl < xr) stack.push({ y: newY, left: xl, right: xr, dir: el.dir }); // from "new left" to "new right"\r\n                    }\r\n                }\r\n                // check minmax for Y if necessary\r\n                if (checkY) {\r\n                    if (el.y < minY) minY = el.y;\r\n                    if (el.y > maxY) maxY = el.y;\r\n                }\r\n            } while (stack.length > 0);\r\n    \r\n            return {\r\n                data: result,\r\n                width: image.width,\r\n                height: image.height,\r\n                bounds: {\r\n                    minX: minX,\r\n                    minY: minY,\r\n                    maxX: maxX,\r\n                    maxY: maxY\r\n                },\r\n                sampleColor:sampleColor,\r\n            };\r\n        };\r\n    \r\n        function floodFillWithBorders(image, px, py, colorThreshold, mask) {\r\n    \r\n            var c, x, newY, el, xr, xl, dy, dyl, dyr, checkY,\r\n                data = image.data,\r\n                w = image.width,\r\n                h = image.height,\r\n                bytes = image.bytes, // number of bytes in the color\r\n                maxX = -1, minX = w + 1, maxY = -1, minY = h + 1,\r\n                i = py * w + px, // start point index in the mask data\r\n                result = new Uint8Array(w * h), // result mask\r\n                visited = new Uint8Array(mask ? mask : w * h); // mask of visited points\r\n    \r\n            if (visited[i] === 1) return null;\r\n    \r\n            i = i * bytes; // start point index in the image data\r\n            var sampleColor = [data[i], data[i + 1], data[i + 2], data[i + 3]]; // start point color (sample)\r\n    \r\n            var stack = [{ y: py, left: px - 1, right: px + 1, dir: 1 }]; // first scanning line\r\n            do {\r\n                el = stack.shift(); // get line for scanning\r\n    \r\n                checkY = false;\r\n                for (x = el.left + 1; x < el.right; x++) {\r\n                    dy = el.y * w;\r\n                    i = (dy + x) * bytes; // point index in the image data\r\n    \r\n                    if (visited[dy + x] === 1) continue; // check whether the point has been visited\r\n    \r\n                    checkY = true; // if the color of the new point(x,y) is similar to the sample color need to check minmax for Y \r\n    \r\n                    result[dy + x] = 1; // mark a new point in mask\r\n                    visited[dy + x] = 1; // mark a new point as visited\r\n\r\n                    // compare the color of the sample\r\n                    c = data[i] - sampleColor[0]; // check by red\r\n                    if (c > colorThreshold || c < -colorThreshold) continue;\r\n                    c = data[i + 1] - sampleColor[1]; // check by green\r\n                    if (c > colorThreshold || c < -colorThreshold) continue;\r\n                    c = data[i + 2] - sampleColor[2]; // check by blue\r\n                    if (c > colorThreshold || c < -colorThreshold) continue;\r\n\r\n                    //ignore transparent points\r\n                    if(data[i+3] === 0) continue;\r\n    \r\n                    xl = x - 1;\r\n                    // walk to left side starting with the left neighbor\r\n                    while (xl > -1) {\r\n                        dyl = dy + xl;\r\n                        i = dyl * bytes; // point index in the image data\r\n                        if (visited[dyl] === 1) break; // check whether the point has been visited\r\n    \r\n                        result[dyl] = 1;\r\n                        visited[dyl] = 1;\r\n                        xl--;\r\n    \r\n                        // compare the color of the sample\r\n                        c = data[i] - sampleColor[0]; // check by red\r\n                        if (c > colorThreshold || c < -colorThreshold) break;\r\n                        c = data[i + 1] - sampleColor[1]; // check by green\r\n                        if (c > colorThreshold || c < -colorThreshold) break;\r\n                        c = data[i + 2] - sampleColor[2]; // check by blue\r\n                        if (c > colorThreshold || c < -colorThreshold) break;\r\n\r\n                        //ignore transparent points\r\n                        if(data[i+3] === 0) break;\r\n                    }\r\n                    xr = x + 1;\r\n                    // walk to right side starting with the right neighbor\r\n                    while (xr < w) {\r\n                        dyr = dy + xr;\r\n                        i = dyr * bytes; // index point in the image data\r\n                        if (visited[dyr] === 1) break; // check whether the point has been visited\r\n    \r\n                        result[dyr] = 1;\r\n                        visited[dyr] = 1;\r\n                        xr++;\r\n    \r\n                        // compare the color of the sample\r\n                        c = data[i] - sampleColor[0]; // check by red\r\n                        if (c > colorThreshold || c < -colorThreshold) break;\r\n                        c = data[i + 1] - sampleColor[1]; // check by green\r\n                        if (c > colorThreshold || c < -colorThreshold) break;\r\n                        c = data[i + 2] - sampleColor[2]; // check by blue\r\n                        if (c > colorThreshold || c < -colorThreshold) break;\r\n\r\n                        //ignore transparent points\r\n                        if(data[i+3] === 0) break;\r\n                    }\r\n    \r\n                    // check minmax for X\r\n                    if (xl < minX) minX = xl + 1;\r\n                    if (xr > maxX) maxX = xr - 1;\r\n    \r\n                    newY = el.y - el.dir;\r\n                    if (newY >= 0 && newY < h) { // add two scanning lines in the opposite direction (y - dir) if necessary\r\n                        if (xl < el.left) stack.push({ y: newY, left: xl, right: el.left, dir: -el.dir }); // from "new left" to "current left"\r\n                        if (el.right < xr) stack.push({ y: newY, left: el.right, right: xr, dir: -el.dir }); // from "current right" to "new right"\r\n                    }\r\n                    newY = el.y + el.dir;\r\n                    if (newY >= 0 && newY < h) { // add the scanning line in the direction (y + dir) if necessary\r\n                        if (xl < xr) stack.push({ y: newY, left: xl, right: xr, dir: el.dir }); // from "new left" to "new right"\r\n                    }\r\n                }\r\n                // check minmax for Y if necessary\r\n                if (checkY) {\r\n                    if (el.y < minY) minY = el.y;\r\n                    if (el.y > maxY) maxY = el.y;\r\n                }\r\n            } while (stack.length > 0);\r\n    \r\n            return {\r\n                data: result,\r\n                width: image.width,\r\n                height: image.height,\r\n                bounds: {\r\n                    minX: minX,\r\n                    minY: minY,\r\n                    maxX: maxX,\r\n                    maxY: maxY\r\n                },\r\n                sampleColor:sampleColor,\r\n            };\r\n        };\r\n    \r\n        lib.thresholdMask = function(image, px, py, colorThreshold, masks={}) {\r\n    \r\n            let c, r,\r\n                data = image.data,\r\n                w = image.width,\r\n                h = image.height,\r\n                bytes = image.bytes, // number of bytes in the color\r\n                i = py * w + px, // start point index in the mask data\r\n                result = new Uint8Array(masks.append ? masks.append :w * h), // result mask\r\n                ignore = new Uint8Array(masks.ignore ? masks.ignore : w * h); // mask of points to ignore\r\n    \r\n            if (ignore[i] === 1) return null;\r\n    \r\n            i = i * bytes; // start point index in the image data\r\n            var sampleColor = [data[i], data[i + 1], data[i + 2], data[i + 3]]; // start point color (sample)\r\n            \r\n            for(i = 0, r = 0; i<data.length; i+=4, r+=1){\r\n                if(ignore[r] || result[r]) continue;\r\n\r\n                //ignore transparent points\r\n                if(data[i+3] === 0) continue;\r\n\r\n                // compare the color of the sample\r\n                c = data[i] - sampleColor[0]; // check by red\r\n                if (c > colorThreshold || c < -colorThreshold) continue;\r\n                c = data[i + 1] - sampleColor[1]; // check by green\r\n                if (c > colorThreshold || c < -colorThreshold) continue;\r\n                c = data[i + 2] - sampleColor[2]; // check by blue\r\n                if (c > colorThreshold || c < -colorThreshold) continue;\r\n    \r\n                result[r]=1;\r\n    \r\n            }\r\n    \r\n            return {\r\n                data: result,\r\n                width: image.width,\r\n                height: image.height,\r\n                bounds: {\r\n                    minX: 0,\r\n                    minY: 0,\r\n                    maxX: w,\r\n                    maxY: h\r\n                },\r\n                sampleColor:sampleColor,\r\n            };\r\n        };\r\n    \r\n    \r\n        /** Apply the gauss-blur filter to binary mask\r\n            * Algorithms: http://blog.ivank.net/fastest-gaussian-blur.html\r\n            * http://www.librow.com/articles/article-9\r\n            * http://elynxsdk.free.fr/ext-docs/Blur/Fast_box_blur.pdf\r\n            * @param {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds\r\n            * @param {int} blur radius\r\n            * @return {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds\r\n            */\r\n        lib.gaussBlur = function(mask, radius) {\r\n    \r\n            var i, k, k1, x, y, val, start, end,\r\n                n = radius * 2 + 1, // size of the pattern for radius-neighbors (from -r to +r with the center point)\r\n                s2 = radius * radius,\r\n                wg = new Float32Array(n), // weights\r\n                total = 0, // sum of weights(used for normalization)\r\n                w = mask.width,\r\n                h = mask.height,\r\n                data = mask.data,\r\n                minX = mask.bounds.minX,\r\n                maxX = mask.bounds.maxX,\r\n                minY = mask.bounds.minY,\r\n                maxY = mask.bounds.maxY;\r\n    \r\n            // calc gauss weights\r\n            for (i = 0; i < radius; i++) {\r\n                var dsq = (radius - i) * (radius - i);\r\n                var ww = Math.exp(-dsq / (2.0 * s2)) / (2 * Math.PI * s2);\r\n                wg[radius + i] = wg[radius - i] = ww;\r\n                total += 2 * ww;\r\n            }\r\n            // normalization weights\r\n            for (i = 0; i < n; i++) {\r\n                wg[i] /= total;\r\n            }\r\n    \r\n            var result = new Uint8Array(w * h), // result mask\r\n                endX = radius + w,\r\n                endY = radius + h;\r\n    \r\n            //walk through all source points for blur\r\n            for (y = minY; y < maxY + 1; y++)\r\n                for (x = minX; x < maxX + 1; x++) {\r\n                    val = 0;\r\n                    k = y * w + x; // index of the point\r\n                    start = radius - x > 0 ? radius - x : 0;\r\n                    end = endX - x < n ? endX - x : n; // Math.min((((w - 1) - x) + radius) + 1, n);\r\n                    k1 = k - radius;\r\n                    // walk through x-neighbors\r\n                    for (i = start; i < end; i++) {\r\n                        val += data[k1 + i] * wg[i];\r\n                    }\r\n                    start = radius - y > 0 ? radius - y : 0;\r\n                    end = endY - y < n ? endY - y : n; // Math.min((((h - 1) - y) + radius) + 1, n);\r\n                    k1 = k - radius * w;\r\n                    // walk through y-neighbors\r\n                    for (i = start; i < end; i++) {\r\n                        val += data[k1 + i * w] * wg[i];\r\n                    }\r\n                    result[k] = val > 0.5 ? 1 : 0;\r\n                }\r\n    \r\n            return {\r\n                data: result,\r\n                width: w,\r\n                height: h,\r\n                bounds: {\r\n                    minX: minX,\r\n                    minY: minY,\r\n                    maxX: maxX,\r\n                    maxY: maxY\r\n                }\r\n            };\r\n        };\r\n    \r\n        /** Create a border index array of boundary points of the mask with radius-neighbors\r\n            * @param {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds\r\n            * @param {int} blur radius\r\n            * @param {Uint8Array} visited: mask of visited points (optional) \r\n            * @return {Array} border index array of boundary points with radius-neighbors (only points need for blur)\r\n            */\r\n        function createBorderForBlur(mask, radius, visited) {\r\n    \r\n            var x, i, j, y, k, k1, k2,\r\n                w = mask.width,\r\n                h = mask.height,\r\n                data = mask.data,\r\n                visitedData = new Uint8Array(data),\r\n                minX = mask.bounds.minX,\r\n                maxX = mask.bounds.maxX,\r\n                minY = mask.bounds.minY,\r\n                maxY = mask.bounds.maxY,\r\n                len = w * h,\r\n                temp = new Uint8Array(len), // auxiliary array to check uniqueness\r\n                border = [], // only border points\r\n                x0 = Math.max(minX, 1),\r\n                x1 = Math.min(maxX, w - 2),\r\n                y0 = Math.max(minY, 1),\r\n                y1 = Math.min(maxY, h - 2);\r\n    \r\n            if (visited && visited.length > 0) {\r\n                // copy visited points (only "black")\r\n                for (k = 0; k < len; k++) {\r\n                    if (visited[k] === 1) visitedData[k] = 1;\r\n                }\r\n            }\r\n    \r\n            // walk through inner values except points on the boundary of the image\r\n            for (y = y0; y < y1 + 1; y++)\r\n                for (x = x0; x < x1 + 1; x++) {\r\n                    k = y * w + x;\r\n                    if (data[k] === 0) continue; // "white" point isn\'t the border\r\n                    k1 = k + w; // y + 1\r\n                    k2 = k - w; // y - 1\r\n                    // check if any neighbor with a "white" color\r\n                    if (visitedData[k + 1] === 0 || visitedData[k - 1] === 0 ||\r\n                        visitedData[k1] === 0 || visitedData[k1 + 1] === 0 || visitedData[k1 - 1] === 0 ||\r\n                        visitedData[k2] === 0 || visitedData[k2 + 1] === 0 || visitedData[k2 - 1] === 0) {\r\n                        //if (visitedData[k + 1] + visitedData[k - 1] + \r\n                        //    visitedData[k1] + visitedData[k1 + 1] + visitedData[k1 - 1] +\r\n                        //    visitedData[k2] + visitedData[k2 + 1] + visitedData[k2 - 1] == 8) continue;\r\n                        border.push(k);\r\n                    }\r\n                }\r\n    \r\n            // walk through points on the boundary of the image if necessary\r\n            // if the "black" point is adjacent to the boundary of the image, it is a border point\r\n            if (minX == 0)\r\n                for (y = minY; y < maxY + 1; y++)\r\n                    if (data[y * w] === 1)\r\n                        border.push(y * w);\r\n    \r\n            if (maxX == w - 1)\r\n                for (y = minY; y < maxY + 1; y++)\r\n                    if (data[y * w + maxX] === 1)\r\n                        border.push(y * w + maxX);\r\n    \r\n            if (minY == 0)\r\n                for (x = minX; x < maxX + 1; x++)\r\n                    if (data[x] === 1)\r\n                        border.push(x);\r\n    \r\n            if (maxY == h - 1)\r\n                for (x = minX; x < maxX + 1; x++)\r\n                    if (data[maxY * w + x] === 1)\r\n                        border.push(maxY * w + x);\r\n    \r\n            var result = [], // border points with radius-neighbors\r\n                start, end,\r\n                endX = radius + w,\r\n                endY = radius + h,\r\n                n = radius * 2 + 1; // size of the pattern for radius-neighbors (from -r to +r with the center point)\r\n    \r\n            len = border.length;\r\n            // walk through radius-neighbors of border points and add them to the result array\r\n            for (j = 0; j < len; j++) {\r\n                k = border[j]; // index of the border point\r\n                temp[k] = 1; // mark border point\r\n                result.push(k); // save the border point\r\n                x = k % w; // calc x by index\r\n                y = (k - x) / w; // calc y by index\r\n                start = radius - x > 0 ? radius - x : 0;\r\n                end = endX - x < n ? endX - x : n; // Math.min((((w - 1) - x) + radius) + 1, n);\r\n                k1 = k - radius;\r\n                // walk through x-neighbors\r\n                for (i = start; i < end; i++) {\r\n                    k2 = k1 + i;\r\n                    if (temp[k2] === 0) { // check the uniqueness\r\n                        temp[k2] = 1;\r\n                        result.push(k2);\r\n                    }\r\n                }\r\n                start = radius - y > 0 ? radius - y : 0;\r\n                end = endY - y < n ? endY - y : n; // Math.min((((h - 1) - y) + radius) + 1, n);\r\n                k1 = k - radius * w;\r\n                // walk through y-neighbors\r\n                for (i = start; i < end; i++) {\r\n                    k2 = k1 + i * w;\r\n                    if (temp[k2] === 0) { // check the uniqueness\r\n                        temp[k2] = 1;\r\n                        result.push(k2);\r\n                    }\r\n                }\r\n            }\r\n    \r\n            return result;\r\n        };\r\n    \r\n        /** Apply the gauss-blur filter ONLY to border points with radius-neighbors\r\n            * Algorithms: http://blog.ivank.net/fastest-gaussian-blur.html\r\n            * http://www.librow.com/articles/article-9\r\n            * http://elynxsdk.free.fr/ext-docs/Blur/Fast_box_blur.pdf\r\n            * @param {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds\r\n            * @param {int} blur radius\r\n            * @param {Uint8Array} visited: mask of visited points (optional) \r\n            * @return {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds\r\n            */\r\n        lib.gaussBlurOnlyBorder = function(mask, radius, visited) {\r\n    \r\n            var border = createBorderForBlur(mask, radius, visited), // get border points with radius-neighbors\r\n                ww, dsq, i, j, k, k1, x, y, val, start, end,\r\n                n = radius * 2 + 1, // size of the pattern for radius-neighbors (from -r to +r with center point)\r\n                s2 = 2 * radius * radius,\r\n                wg = new Float32Array(n), // weights\r\n                total = 0, // sum of weights(used for normalization)\r\n                w = mask.width,\r\n                h = mask.height,\r\n                data = mask.data,\r\n                minX = mask.bounds.minX,\r\n                maxX = mask.bounds.maxX,\r\n                minY = mask.bounds.minY,\r\n                maxY = mask.bounds.maxY,\r\n                len = border.length;\r\n    \r\n            // calc gauss weights\r\n            for (i = 0; i < radius; i++) {\r\n                dsq = (radius - i) * (radius - i);\r\n                ww = Math.exp(-dsq / s2) / Math.PI;\r\n                wg[radius + i] = wg[radius - i] = ww;\r\n                total += 2 * ww;\r\n            }\r\n            // normalization weights\r\n            for (i = 0; i < n; i++) {\r\n                wg[i] /= total;\r\n            }\r\n    \r\n            var result = new Uint8Array(data), // copy the source mask\r\n                endX = radius + w,\r\n                endY = radius + h;\r\n    \r\n            //walk through all border points for blur\r\n            for (i = 0; i < len; i++) {\r\n                k = border[i]; // index of the border point\r\n                val = 0;\r\n                x = k % w; // calc x by index\r\n                y = (k - x) / w; // calc y by index\r\n                start = radius - x > 0 ? radius - x : 0;\r\n                end = endX - x < n ? endX - x : n; // Math.min((((w - 1) - x) + radius) + 1, n);\r\n                k1 = k - radius;\r\n                // walk through x-neighbors\r\n                for (j = start; j < end; j++) {\r\n                    val += data[k1 + j] * wg[j];\r\n                }\r\n                if (val > 0.5) {\r\n                    result[k] = 1;\r\n                    // check minmax\r\n                    if (x < minX) minX = x;\r\n                    if (x > maxX) maxX = x;\r\n                    if (y < minY) minY = y;\r\n                    if (y > maxY) maxY = y;\r\n                    continue;\r\n                }\r\n                start = radius - y > 0 ? radius - y : 0;\r\n                end = endY - y < n ? endY - y : n; // Math.min((((h - 1) - y) + radius) + 1, n);\r\n                k1 = k - radius * w;\r\n                // walk through y-neighbors\r\n                for (j = start; j < end; j++) {\r\n                    val += data[k1 + j * w] * wg[j];\r\n                }\r\n                if (val > 0.5) {\r\n                    result[k] = 1;\r\n                    // check minmax\r\n                    if (x < minX) minX = x;\r\n                    if (x > maxX) maxX = x;\r\n                    if (y < minY) minY = y;\r\n                    if (y > maxY) maxY = y;\r\n                } else {\r\n                    result[k] = 0;\r\n                }\r\n            }\r\n    \r\n            return {\r\n                data: result,\r\n                width: w,\r\n                height: h,\r\n                bounds: {\r\n                    minX: minX,\r\n                    minY: minY,\r\n                    maxX: maxX,\r\n                    maxY: maxY\r\n                }\r\n            };\r\n        };\r\n    \r\n        /** Create a border mask (only boundary points)\r\n            * @param {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds\r\n            * @return {Object} border mask: {Uint8Array} data, {int} width, {int} height, {Object} offset\r\n            */\r\n        lib.createBorderMask = function(mask) {\r\n    \r\n            var x, y, k, k1, k2,\r\n                w = mask.width,\r\n                h = mask.height,\r\n                data = mask.data,\r\n                minX = mask.bounds.minX,\r\n                maxX = mask.bounds.maxX,\r\n                minY = mask.bounds.minY,\r\n                maxY = mask.bounds.maxY,\r\n                rw = maxX - minX + 1, // bounds size\r\n                rh = maxY - minY + 1,\r\n                result = new Uint8Array(rw * rh), // reduced mask (bounds size)\r\n                x0 = Math.max(minX, 1),\r\n                x1 = Math.min(maxX, w - 2),\r\n                y0 = Math.max(minY, 1),\r\n                y1 = Math.min(maxY, h - 2);\r\n    \r\n            // walk through inner values except points on the boundary of the image\r\n            for (y = y0; y < y1 + 1; y++)\r\n                for (x = x0; x < x1 + 1; x++) {\r\n                    k = y * w + x;\r\n                    if (data[k] === 0) continue; // "white" point isn\'t the border\r\n                    k1 = k + w; // y + 1\r\n                    k2 = k - w; // y - 1\r\n                    // check if any neighbor with a "white" color\r\n                    if (data[k + 1] === 0 || data[k - 1] === 0 ||\r\n                        data[k1] === 0 || data[k1 + 1] === 0 || data[k1 - 1] === 0 ||\r\n                        data[k2] === 0 || data[k2 + 1] === 0 || data[k2 - 1] === 0) {\r\n                        //if (data[k + 1] + data[k - 1] + \r\n                        //    data[k1] + data[k1 + 1] + data[k1 - 1] +\r\n                        //    data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;\r\n                        result[(y - minY) * rw + (x - minX)] = 1;\r\n                    }\r\n                }\r\n    \r\n            // walk through points on the boundary of the image if necessary\r\n            // if the "black" point is adjacent to the boundary of the image, it is a border point\r\n            if (minX == 0)\r\n                for (y = minY; y < maxY + 1; y++)\r\n                    if (data[y * w] === 1)\r\n                        result[(y - minY) * rw] = 1;\r\n    \r\n            if (maxX == w - 1)\r\n                for (y = minY; y < maxY + 1; y++)\r\n                    if (data[y * w + maxX] === 1)\r\n                        result[(y - minY) * rw + (maxX - minX)] = 1;\r\n    \r\n            if (minY == 0)\r\n                for (x = minX; x < maxX + 1; x++)\r\n                    if (data[x] === 1)\r\n                        result[x - minX] = 1;\r\n    \r\n            if (maxY == h - 1)\r\n                for (x = minX; x < maxX + 1; x++)\r\n                    if (data[maxY * w + x] === 1)\r\n                        result[(maxY - minY) * rw + (x - minX)] = 1;\r\n    \r\n            return {\r\n                data: result,\r\n                width: rw,\r\n                height: rh,\r\n                offset: { x: minX, y: minY }\r\n            };\r\n        };\r\n        \r\n        /** Create a border index array of boundary points of the mask\r\n            * @param {Object} mask: {Uint8Array} data, {int} width, {int} height\r\n            * @return {Array} border index array boundary points of the mask\r\n            */\r\n        lib.getBorderIndices = function(mask) {\r\n    \r\n            var x, y, k, k1, k2,\r\n                w = mask.width,\r\n                h = mask.height,\r\n                data = mask.data,\r\n                border = [], // only border points\r\n                x1 = w - 1,\r\n                y1 = h - 1;\r\n    \r\n            // walk through inner values except points on the boundary of the image\r\n            for (y = 1; y < y1; y++)\r\n                for (x = 1; x < x1; x++) {\r\n                    k = y * w + x;\r\n                    if (data[k] === 0) continue; // "white" point isn\'t the border\r\n                    k1 = k + w; // y + 1\r\n                    k2 = k - w; // y - 1\r\n                    // check if any neighbor with a "white" color\r\n                    if (data[k + 1] === 0 || data[k - 1] === 0 ||\r\n                        data[k1] === 0 || data[k1 + 1] === 0 || data[k1 - 1] === 0 ||\r\n                        data[k2] === 0 || data[k2 + 1] === 0 || data[k2 - 1] === 0) {\r\n                        //if (data[k + 1] + data[k - 1] + \r\n                        //    data[k1] + data[k1 + 1] + data[k1 - 1] +\r\n                        //    data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;\r\n                        border.push(k);\r\n                    }\r\n                }\r\n    \r\n            // walk through points on the boundary of the image if necessary\r\n            // if the "black" point is adjacent to the boundary of the image, it is a border point\r\n            for (y = 0; y < h; y++)\r\n                if (data[y * w] === 1)\r\n                    border.push(y * w);\r\n    \r\n            for (x = 0; x < w; x++)\r\n                if (data[x] === 1)\r\n                    border.push(x);\r\n    \r\n            k = w - 1;\r\n            for (y = 0; y < h; y++)\r\n                if (data[y * w + k] === 1)\r\n                    border.push(y * w + k);\r\n    \r\n            k = (h - 1) * w;\r\n            for (x = 0; x < w; x++)\r\n                if (data[k + x] === 1)\r\n                    border.push(k + x);\r\n    \r\n            return border;\r\n        };\r\n        \r\n        /** Create a compressed mask with a "white" border (1px border with zero values) for the contour tracing\r\n            * @param {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds\r\n            * @return {Object} border mask: {Uint8Array} data, {int} width, {int} height, {Object} offset\r\n            */\r\n        function prepareMask(mask) {\r\n            var x, y,\r\n                w = mask.width,\r\n                data = mask.data,\r\n                minX = mask.bounds.minX,\r\n                maxX = mask.bounds.maxX,\r\n                minY = mask.bounds.minY,\r\n                maxY = mask.bounds.maxY,\r\n                rw = maxX - minX + 3, // bounds size +1 px on each side (a "white" border)\r\n                rh = maxY - minY + 3,\r\n                result = new Uint8Array(rw * rh); // reduced mask (bounds size)\r\n    \r\n            // walk through inner values and copy only "black" points to the result mask\r\n            for (y = minY; y < maxY + 1; y++)\r\n                for (x = minX; x < maxX + 1; x++) {\r\n                    if (data[y * w + x] === 1)\r\n                        result[(y - minY + 1) * rw + (x - minX + 1)] = 1;\r\n                }\r\n    \r\n            return {\r\n                data: result,\r\n                width: rw,\r\n                height: rh,\r\n                offset: { x: minX - 1, y: minY - 1 }\r\n            };\r\n        };\r\n            \r\n        /** Create a contour array for the binary mask\r\n            * Algorithm: http://www.sciencedirect.com/science/article/pii/S1077314203001401\r\n            * @param {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds\r\n            * @return {Array} contours: {Array} points, {bool} inner, {int} label\r\n            */\r\n        lib.traceContours = function(mask) {\r\n            var m = prepareMask(mask),\r\n                contours = [],\r\n                label = 0,\r\n                w = m.width,\r\n                w2 = w * 2,\r\n                h = m.height,\r\n                src = m.data,\r\n                dx = m.offset.x,\r\n                dy = m.offset.y,\r\n                dest = new Uint8Array(src), // label matrix\r\n                i, j, x, y, k, k1, c, inner, dir, first, second, current, previous, next, d;\r\n    \r\n            // all [dx,dy] pairs (array index is the direction)\r\n            // 5 6 7\r\n            // 4 X 0\r\n            // 3 2 1\r\n            var directions = [[1, 0], [1, 1], [0, 1], [-1, 1], [-1, 0], [-1, -1], [0, -1], [1, -1]];\r\n    \r\n            for (y = 1; y < h - 1; y++)\r\n                for (x = 1; x < w - 1; x++) {\r\n                    k = y * w + x;\r\n                    if (src[k] === 1) {\r\n                        for (i = -w; i < w2; i += w2) { // k - w: outer tracing (y - 1), k + w: inner tracing (y + 1)\r\n                            if (src[k + i] === 0 && dest[k + i] === 0) { // need contour tracing\r\n                                inner = i === w; // is inner contour tracing ?\r\n                                label++; // label for the next contour\r\n    \r\n                                c = [];\r\n                                dir = inner ? 2 : 6; // start direction\r\n                                current = previous = first = { x: x, y: y };\r\n                                second = null;\r\n                                while (true) {\r\n                                    dest[current.y * w + current.x] = label; // mark label for the current point \r\n                                    // bypass all the neighbors around the current point in a clockwise\r\n                                    for (j = 0; j < 8; j++) {\r\n                                        dir = (dir + 1) % 8;\r\n    \r\n                                        // get the next point by new direction\r\n                                        d = directions[dir]; // index as direction\r\n                                        next = { x: current.x + d[0], y: current.y + d[1] };\r\n    \r\n                                        k1 = next.y * w + next.x;\r\n                                        if (src[k1] === 1) // black boundary pixel\r\n                                        {\r\n                                            dest[k1] = label; // mark a label\r\n                                            break;\r\n                                        }\r\n                                        dest[k1] = -1; // mark a white boundary pixel\r\n                                        next = null;\r\n                                    }\r\n                                    if (next === null) break; // no neighbours (one-point contour)\r\n                                    current = next;\r\n                                    if (second) {\r\n                                        if (previous.x === first.x && previous.y === first.y && current.x === second.x && current.y === second.y) {\r\n                                            break; // creating the contour completed when returned to original position\r\n                                        }\r\n                                    } else {\r\n                                        second = next;\r\n                                    }\r\n                                    c.push({ x: previous.x + dx, y: previous.y + dy });\r\n                                    previous = current;\r\n                                    dir = (dir + 4) % 8; // next dir (symmetrically to the current direction)\r\n                                }\r\n    \r\n                                if (next != null) {\r\n                                    c.push({ x: first.x + dx, y: first.y + dy }); // close the contour\r\n                                    contours.push({ inner: inner, label: label, points: c }); // add contour to the list\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n    \r\n            return contours;\r\n        };\r\n        \r\n        /** Simplify contours\r\n            * Algorithms: http://psimpl.sourceforge.net/douglas-peucker.html \r\n            * http://neerc.ifmo.ru/wiki/index.php?title=%D0%A3%D0%BF%D1%80%D0%BE%D1%89%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BF%D0%BE%D0%BB%D0%B8%D0%B3%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B9_%D1%86%D0%B5%D0%BF%D0%B8\r\n            * @param {Array} contours: {Array} points, {bool} inner, {int} label\r\n            * @param {float} simplify tolerant\r\n            * @param {int} simplify count: min number of points when the contour is simplified\r\n            * @return {Array} contours: {Array} points, {bool} inner, {int} label, {int} initialCount\r\n            */\r\n        lib.simplifyContours = function(contours, simplifyTolerant, simplifyCount) {\r\n            var lenContours = contours.length,\r\n                result = [],\r\n                i, j, k, c, points, len, resPoints, lst, stack, ids,\r\n                maxd, maxi, dist, r1, r2, r12, dx, dy, pi, pf, pl;\r\n    \r\n            // walk through all contours \r\n            for (j = 0; j < lenContours; j++) {\r\n                c = contours[j];\r\n                points = c.points;\r\n                len = c.points.length;\r\n    \r\n                if (len < simplifyCount) { // contour isn\'t simplified\r\n                    resPoints = [];\r\n                    for (k = 0; k < len; k++) {\r\n                        resPoints.push({ x: points[k].x, y: points[k].y });\r\n                    }\r\n                    result.push({ inner: c.inner, label: c.label, points: resPoints, initialCount: len });\r\n                    continue;\r\n                }\r\n    \r\n                lst = [0, len - 1]; // always add first and last points\r\n                stack = [{ first: 0, last: len - 1 }]; // first processed edge\r\n    \r\n                do {\r\n                    ids = stack.shift();\r\n                    if (ids.last <= ids.first + 1) // no intermediate points\r\n                    {\r\n                        continue;\r\n                    }\r\n    \r\n                    maxd = -1.0; // max distance from point to current edge\r\n                    maxi = ids.first; // index of maximally distant point\r\n    \r\n                    for (i = ids.first + 1; i < ids.last; i++) // bypass intermediate points in edge\r\n                    {\r\n                        // calc the distance from current point to edge\r\n                        pi = points[i];\r\n                        pf = points[ids.first];\r\n                        pl = points[ids.last];\r\n                        dx = pi.x - pf.x;\r\n                        dy = pi.y - pf.y;\r\n                        r1 = Math.sqrt(dx * dx + dy * dy);\r\n                        dx = pi.x - pl.x;\r\n                        dy = pi.y - pl.y;\r\n                        r2 = Math.sqrt(dx * dx + dy * dy);\r\n                        dx = pf.x - pl.x;\r\n                        dy = pf.y - pl.y;\r\n                        r12 = Math.sqrt(dx * dx + dy * dy);\r\n                        if (r1 >= Math.sqrt(r2 * r2 + r12 * r12)) dist = r2;\r\n                        else if (r2 >= Math.sqrt(r1 * r1 + r12 * r12)) dist = r1;\r\n                        else dist = Math.abs((dy * pi.x - dx * pi.y + pf.x * pl.y - pl.x * pf.y) / r12);\r\n    \r\n                        if (dist > maxd) {\r\n                            maxi = i; // save the index of maximally distant point\r\n                            maxd = dist;\r\n                        }\r\n                    }\r\n    \r\n                    if (maxd > simplifyTolerant) // if the max "deviation" is larger than allowed then...\r\n                    {\r\n                        lst.push(maxi); // add index to the simplified list\r\n                        stack.push({ first: ids.first, last: maxi }); // add the left part for processing\r\n                        stack.push({ first: maxi, last: ids.last }); // add the right part for processing\r\n                    }\r\n    \r\n                } while (stack.length > 0);\r\n    \r\n                resPoints = [];\r\n                len = lst.length;\r\n                lst.sort(function(a, b) { return a - b; }); // restore index order\r\n                for (k = 0; k < len; k++) {\r\n                    resPoints.push({ x: points[lst[k]].x, y: points[lst[k]].y }); // add result points to the correct order\r\n                }\r\n                result.push({ inner: c.inner, label: c.label, points: resPoints, initialCount: c.points.length });\r\n            }\r\n    \r\n            return result;\r\n        };\r\n        \r\n    \r\n        return lib;\r\n    };\r\n    \n\n//# sourceURL=webpack://js/../src/js/utils/magicwand.mjs?')},"../src/js/utils/morph.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Morph: () => (/* binding */ Morph)\n/* harmony export */ });\n\r\nclass Morph {\r\n    constructor(initmask) {\r\n        this.width = initmask.width,\r\n            this.height = initmask.height,\r\n            this.data = new Uint8Array(initmask.data);\r\n        if (this.data) {\r\n            if (this.height * this.width != this.data.length)\r\n                throw 'MORPH_DIMENSION_ERROR: incorrect dimensions';\r\n        }\r\n        else {\r\n            // this.data = Array.apply(null, new Array(this.height * this.width)).map(Number.prototype.valueOf,0);\r\n            this.data = Array(this.width * this.height).fill(0);\r\n        }\r\n        this.dilate = function () {\r\n            // this.addBorder()\r\n            let o = Array.from(this.data);\r\n            let w = this.width;\r\n            let h = this.height;\r\n            for (var y = 0; y < h; y++) {\r\n                for (var x = 0; x < w; x++) {\r\n                    var ind = y * w + x;\r\n                    this.data[ind] = o[ind] ? o[ind] : (this.adjacentIndices(ind).some(function (i) { return o[i]; }) ? 1 : 0);\r\n                }\r\n            }\r\n            return {\r\n                width: this.width,\r\n                height: this.height,\r\n                data: this.data\r\n            };\r\n        };\r\n        this.addBorder = function () {\r\n            this.width = this.width + 2;\r\n            this.height = this.height + 2;\r\n            let orig = this.data;\r\n            this.data = new Uint8Array(this.width * this.height).fill(0);\r\n            for (var y = 1; y < this.height - 1; y++) {\r\n                for (var x = 1; x < this.width - 1; x++) {\r\n                    this.data[y * this.width + x] = orig[(y - 1) * (this.width - 2) + (x - 1)];\r\n                }\r\n            }\r\n            return {\r\n                width: this.width,\r\n                height: this.height,\r\n                data: this.data\r\n            };\r\n        };\r\n        this.adjacentIndices = function (ind) {\r\n            var ul = ind - this.width - 1;\r\n            var ll = ind + this.width - 1;\r\n            let len = this.data.length;\r\n            return [ul, ul + 1, ul + 2, ind - 1, ind + 1, ll, ll + 1, ll + 2].filter(function (i) { return i >= 0 && i < len; });\r\n        };\r\n    }\r\n}\n\n//# sourceURL=webpack://js/../src/js/utils/morph.mjs?")}},__webpack_module_cache__={};function __webpack_require__(e){var r=__webpack_module_cache__[e];if(void 0!==r)return r.exports;var n=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e](n,n.exports,__webpack_require__),n.exports}__webpack_require__.d=(e,r)=>{for(var n in r)__webpack_require__.o(r,n)&&!__webpack_require__.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:r[n]})},__webpack_require__.o=(e,r)=>Object.prototype.hasOwnProperty.call(e,r),__webpack_require__.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__("../main.mjs")})();